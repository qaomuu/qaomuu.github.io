(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,s,o=e[0],l=e[1],c=e[2],d=0,p=[];d<o.length;d++)s=o[d],Object.prototype.hasOwnProperty.call(i,s)&&i[s]&&p.push(i[s][0]),i[s]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(u&&u(e);p.length;)p.shift()();return r.push.apply(r,c||[]),t()}function t(){for(var n,e=0;e<r.length;e++){for(var t=r[e],a=!0,o=1;o<t.length;o++){var l=t[o];0!==i[l]&&(a=!1)}a&&(r.splice(e--,1),n=s(s.s=t[0]))}return n}var a={},i={1:0},r=[];function s(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=i[n]=[e,a]}));e.push(t[2]=a);var r,o=document.createElement("script");o.charset="utf-8",o.timeout=120,s.nc&&o.setAttribute("nonce",s.nc),o.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"06b51e28",3:"04a7b8c9",4:"23b49261",5:"cf7ce6d9",6:"de48cd74",7:"5fd9e1bc",8:"31885ab6",9:"88734d8e",10:"25ab3c87",11:"0710d907",12:"b69f61e1",13:"7c680a8f",14:"c2a530ec",15:"0344ac89",16:"8ba3e333",17:"d5aa2799",18:"220bdb83",19:"67fc625a",20:"8a296438",21:"bebe2d14",22:"a2f38cf1",23:"584f4a98",24:"b4f54e0d",25:"4e296918",26:"e9f8a341",27:"d1e12903",28:"aad73944",29:"1f69ecb2",30:"31228ad4",31:"876161e0",32:"00970883",33:"d6286171",34:"6f7f8dea",35:"61b61fb3",36:"ff818b3d",37:"3b4a7cce",38:"c3e4cbf3"}[n]+".js"}(n);var l=new Error;r=function(e){o.onerror=o.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),r=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+r+")",l.name="ChunkLoadError",l.type=a,l.request=r,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){r({type:"timeout",target:o})}),12e4);o.onerror=o.onload=r,document.head.appendChild(o)}return Promise.all(e)},s.m=n,s.c=a,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)s.d(t,a,function(e){return n[e]}.bind(null,a));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/",s.oe=function(n){throw console.error(n),n};var o=window.webpackJsonp=window.webpackJsonp||[],l=o.push.bind(o);o.push=e,o=o.slice();for(var c=0;c<o.length;c++)e(o[c]);var u=l;r.push([103,0]),t()}([function(n,e,t){var a=t(55),i=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===i}:function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var a=t(28),i=Function.prototype,r=i.call,s=a&&i.bind.bind(r,r);n.exports=a?s:function(n){return function(){return r.apply(n,arguments)}}},function(n,e,t){var a=t(2);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(69),i="object"==typeof self&&self&&self.Object===Object&&self,r=a||i||Function("return this")();n.exports=r},function(n,e,t){"use strict";function a(n,e,t,a,i,r,s,o){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),r&&(c._scopeId="data-v-"+r),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):i&&(l=o?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(3),i=t(31),r=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return r(i(n),e)}},function(n,e,t){var a=t(0),i=t(55),r=i.all;n.exports=i.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===r}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(162),i=t(165);n.exports=function(n,e){var t=i(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return r})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return k}));t(13);const a=/#.*$/,i=/\.(md|html)$/,r=/\/$/,s=/^[a-z]+:/i;function o(n){return decodeURI(n).replace(a,"").replace(i,"")}function l(n){return s.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",i=o(n);return r.test(i)?n:i+".html"+t}function p(n,e){const t=n.hash,i=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(i&&t!==i)return!1;return o(n.path)===o(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const i=e.split("/");t&&i[i.length-1]||i.pop();const r=n.replace(/^\//,"").split("/");for(let n=0;n<r.length;n++){const e=r[n];".."===e?i.pop():"."!==e&&i.push(e)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));const a=o(e);for(let e=0;e<n.length;e++)if(o(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:i,themeConfig:r}=t,s=a&&r.locales&&r.locales[a]||r;if("auto"===(n.frontmatter.sidebar||s.sidebar||r.sidebar))return g(n);const o=s.sidebar||r.sidebar;if(o){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,o);return"auto"===a?g(n):a?a.map(n=>function n(e,t,a,i=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const r=e.children||[];return 0===r.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:r.map(e=>n(e,t,a,i+1)),collapsable:!1!==e.collapsable}}}(n,i,t)):[]}return[]}function g(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var a=t(27),i=t(31),r=t(32),s=t(128),o=t(130),l=t(2)((function(){return 4294967297!==[].push.call({length:4294967296},1)})),c=!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}();a({target:"Array",proto:!0,arity:1,forced:l||c},{push:function(n){var e=i(this),t=r(e),a=arguments.length;o(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return s(e,t),t}})},function(n,e,t){var a=t(15),i=t(147),r=t(148),s=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?i(n):r(n)}},function(n,e,t){var a=t(6).Symbol;n.exports=a},function(n,e,t){var a=t(4),i=t(64),r=t(99),s=t(26),o=t(54),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=a?r?function(n,e,t){if(s(n),e=o(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=u(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=o(e),s(t),i)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(3),i=a({}.toString),r=a("".slice);n.exports=function(n){return r(i(n),8,-1)}},function(n,e,t){var a=t(1),i=t(0),r=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?r(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(4),i=t(16),r=t(34);n.exports=a?function(n,e,t){return i.f(n,e,r(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(152),i=t(153),r=t(154),s=t(155),o=t(156);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=r,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var a=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(174);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(44);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function r(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),u=a.speed,d=a.easing;return l.offsetWidth,s((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),o(c,function(n,e,t){var i;return(i="translate3d"===a.positionUsing?{transform:"translate3d("+r(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+r(n)+"%,0)"}:{"margin-left":r(n)+"%"}).transition="all "+e+"ms "+t,i}(n,u,d)),1===n?(o(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){o(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var i,s=e.querySelector(a.barSelector),l=n?"-100":r(t.status||0),u=document.querySelector(a.parent);return o(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(i=e.querySelector(a.spinnerSelector))&&p(i),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),o=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,i=n.length,r=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((a=n[i]+r)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,i,r=arguments;if(2==r.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&a(n,t,i);else a(n,r[1],r[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function u(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=i)},function(n,e,t){var a=t(9),i=String,r=TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not an object")}},function(n,e,t){var a=t(1),i=t(51).f,r=t(19),s=t(111),o=t(36),l=t(65),c=t(124);n.exports=function(n,e){var t,u,d,p,m,h=n.target,g=n.global,f=n.stat;if(t=g?a:f?a[h]||o(h,{}):(a[h]||{}).prototype)for(u in e){if(p=e[u],d=n.dontCallGetSet?(m=i(t,u))&&m.value:t[u],!c(g?u:h+(f?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&r(p,"sham",!0),s(t,u,p,n)}}},function(n,e,t){var a=t(2);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(46),i=t(52);n.exports=function(n){return a(i(n))}},function(n,e,t){var a=t(1),i=t(61),r=t(8),s=t(63),o=t(59),l=t(58),c=i("wks"),u=a.Symbol,d=u&&u.for,p=l?u:u&&u.withoutSetter||s;n.exports=function(n){if(!r(c,n)||!o&&"string"!=typeof c[n]){var e="Symbol."+n;o&&r(u,n)?c[n]=u[n]:c[n]=l&&d?d(e):p(e)}return c[n]}},function(n,e,t){var a=t(52),i=Object;n.exports=function(n){return i(a(n))}},function(n,e,t){var a=t(122);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(28),i=Function.prototype.call;n.exports=a?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(1),i=t(36),r=a["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=r},function(n,e,t){var a=t(1),i=Object.defineProperty;n.exports=function(n,e){try{i(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(146),i=t(12),r=Object.prototype,s=r.hasOwnProperty,o=r.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return i(n)&&s.call(n,"callee")&&!o.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(6),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(166),i=t(173),r=t(175),s=t(176),o=t(177);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=r,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(5),i=t(44),r=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(s.test(n)||!r.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(14),i=t(12);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(3),i=t(2),r=t(17),s=Object,o=a("".split);n.exports=i((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==r(n)?o(n,""):s(n)}:s},function(n,e,t){var a=t(0),i=t(109),r=TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,r=/^0o[0-7]+$/i,s=parseInt,o="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=o||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var o=i.test(n);return o||r.test(n)?s(n.slice(2),o?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,i,r,s,o,l,c=0,u=!1,f=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=a,r=i;return a=i=void 0,c=e,s=n.apply(r,t)}function y(n){return c=n,o=setTimeout(x,e),u?v(n):s}function k(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=r}function x(){var n=m();if(k(n))return w(n);o=setTimeout(x,function(n){var t=e-(n-l);return f?p(t,r-(n-c)):t}(n))}function w(n){return o=void 0,b&&a?v(n):(a=i=void 0,s)}function E(){var n=m(),t=k(n);if(a=arguments,i=this,l=n,t){if(void 0===o)return y(l);if(f)return o=setTimeout(x,e),v(l)}return void 0===o&&(o=setTimeout(x,e)),s}return e=g(e)||0,h(t)&&(u=!!t.leading,r=(f="maxWait"in t)?d(g(t.maxWait)||0,e):r,b="trailing"in t?!!t.trailing:b),E.cancel=function(){void 0!==o&&clearTimeout(o),c=0,a=l=i=o=void 0},E.flush=function(){return void 0===o?s:w(m())},E}},function(n,e,t){var a=t(4),i=t(33),r=t(105),s=t(34),o=t(29),l=t(54),c=t(8),u=t(64),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=o(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return s(!i(r.f,n,e),n[e])}},function(n,e,t){var a=t(53),i=TypeError;n.exports=function(n){if(a(n))throw i("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(106),i=t(56);n.exports=function(n){var e=a(n,"string");return i(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(18),i=t(0),r=t(57),s=t(58),o=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return i(e)&&r(e.prototype,o(n))}},function(n,e,t){var a=t(3);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(59);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(60),i=t(2);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,i,r=t(1),s=t(107),o=r.process,l=r.Deno,c=o&&o.versions||l&&l.version,u=c&&c.v8;u&&(i=(a=u.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!i&&s&&(!(a=s.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=s.match(/Chrome\/(\d+)/))&&(i=+a[1]),n.exports=i},function(n,e,t){var a=t(62),i=t(35);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.26.1",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(3),i=0,r=Math.random(),s=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++i+r,36)}},function(n,e,t){var a=t(4),i=t(2),r=t(98);n.exports=!a&&!i((function(){return 7!=Object.defineProperty(r("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(8),i=t(117),r=t(51),s=t(16);n.exports=function(n,e,t){for(var o=i(e),l=s.f,c=r.f,u=0;u<o.length;u++){var d=o[u];a(n,d)||t&&a(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var a=t(121);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(3),i=t(26),r=t(134);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return i(t),r(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,i=n.length;++t<a;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(20),i=t(157),r=t(158),s=t(159),o=t(160),l=t(161);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=r,c.prototype.get=s,c.prototype.has=o,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(14),i=t(39);n.exports=function(n){if(!i(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(178),i=t(12);n.exports=function n(e,t,r,s,o){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:a(e,t,r,s,n,o))}},function(n,e,t){var a=t(76),i=t(181),r=t(77);n.exports=function(n,e,t,s,o,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,g=!0,f=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var b=n[h],v=e[h];if(s)var y=c?s(v,b,h,e,n,l):s(b,v,h,n,e,l);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!i(e,(function(n,e){if(!r(f,e)&&(b===n||o(b,n,t,s,l)))return f.push(e)}))){g=!1;break}}else if(b!==v&&!o(b,v,t,s,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var a=t(40),i=t(179),r=t(180);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=i,s.prototype.has=r,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(191),i=t(197),r=t(82);n.exports=function(n){return r(n)?a(n):i(n)}},function(n,e,t){(function(n){var a=t(6),i=t(193),r=e&&!e.nodeType&&e,s=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=s&&s.exports===r?a.Buffer:void 0,l=(o?o.isBuffer:void 0)||i;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(194),i=t(195),r=t(196),s=r&&r.isTypedArray,o=s?i(s):a;n.exports=o},function(n,e,t){var a=t(72),i=t(42);n.exports=function(n){return null!=n&&i(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(6),"Set");n.exports=a},function(n,e,t){var a=t(39);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(87),i=t(24);n.exports=function(n,e){for(var t=0,r=(e=a(e,n)).length;null!=n&&t<r;)n=n[i(e[t++])];return t&&t==r?n:void 0}},function(n,e,t){var a=t(5),i=t(43),r=t(208),s=t(211);n.exports=function(n,e){return a(n)?n:i(n,e)?[n]:r(s(n))}},function(n,e){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(144),i=t(149),r=t(220),s=t(228),o=t(237),l=t(102),c=r((function(n){var e=l(n);return o(e)&&(e=void 0),s(a(n,1,o,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=a.exec(t);if(!i)return t;var r="",s=0,o=0;for(s=i.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}o!==s&&(r+=t.substring(o,s)),o=s+1,r+=e}return o!==s?r+t.substring(o,s):r}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(240),t(7)),r=Object(i.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=r.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},i=(t(241),t(7)),r=Object(i.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=r.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(1),i=t(9),r=a.document,s=i(r)&&i(r.createElement);n.exports=function(n){return s?r.createElement(n):{}}},function(n,e,t){var a=t(4),i=t(2);n.exports=a&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(61),i=t(63),r=a("keys");n.exports=function(n){return r[n]||(r[n]=i(n))}},function(n,e,t){var a=t(3),i=t(8),r=t(29),s=t(119).indexOf,o=t(48),l=a([].push);n.exports=function(n,e){var t,a=r(n),c=0,u=[];for(t in a)!i(o,t)&&i(a,t)&&l(u,t);for(;e.length>c;)i(a,t=e[c++])&&(~s(u,t)||l(u,t));return u}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(246)},function(n,e,t){"use strict";var a=t(27),i=t(125).left,r=t(126),s=t(60),o=t(127);a({target:"Array",proto:!0,forced:!r("reduce")||!o&&s>79&&s<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,r=i&&!a.call({1:2},1);e.f=r?function(n){var e=i(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(33),i=t(9),r=t(56),s=t(108),o=t(110),l=t(30),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!i(n)||r(n))return n;var t,l=s(n,u);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!i(t)||r(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),o(n,e)}},function(n,e,t){var a=t(18);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(47),i=t(53);n.exports=function(n,e){var t=n[e];return i(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(33),i=t(0),r=t(9),s=TypeError;n.exports=function(n,e){var t,o;if("string"===e&&i(t=n.toString)&&!r(o=a(t,n)))return o;if(i(t=n.valueOf)&&!r(o=a(t,n)))return o;if("string"!==e&&i(t=n.toString)&&!r(o=a(t,n)))return o;throw s("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),i=t(16),r=t(112),s=t(36);n.exports=function(n,e,t,o){o||(o={});var l=o.enumerable,c=void 0!==o.name?o.name:e;if(a(t)&&r(t,c,o),o.global)l?n[e]=t:s(e,t);else{try{o.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:i.f(n,e,{value:t,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return n}},function(n,e,t){var a=t(2),i=t(0),r=t(8),s=t(4),o=t(113).CONFIGURABLE,l=t(114),c=t(115),u=c.enforce,d=c.get,p=Object.defineProperty,m=s&&!a((function(){return 8!==p((function(){}),"length",{value:8}).length})),h=String(String).split("String"),g=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!r(n,"name")||o&&n.name!==e)&&(s?p(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&r(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity});try{t&&r(t,"constructor")&&t.constructor?s&&p(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=u(n);return r(a,"source")||(a.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=g((function(){return i(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var a=t(4),i=t(8),r=Function.prototype,s=a&&Object.getOwnPropertyDescriptor,o=i(r,"name"),l=o&&"something"===function(){}.name,c=o&&(!a||a&&s(r,"name").configurable);n.exports={EXISTS:o,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a=t(3),i=t(0),r=t(35),s=a(Function.toString);i(r.inspectSource)||(r.inspectSource=function(n){return s(n)}),n.exports=r.inspectSource},function(n,e,t){var a,i,r,s=t(116),o=t(1),l=t(9),c=t(19),u=t(8),d=t(35),p=t(100),m=t(48),h=o.TypeError,g=o.WeakMap;if(s||d.state){var f=d.state||(d.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,a=function(n,e){if(f.has(n))throw h("Object already initialized");return e.facade=n,f.set(n,e),e},i=function(n){return f.get(n)||{}},r=function(n){return f.has(n)}}else{var b=p("state");m[b]=!0,a=function(n,e){if(u(n,b))throw h("Object already initialized");return e.facade=n,c(n,b,e),e},i=function(n){return u(n,b)?n[b]:{}},r=function(n){return u(n,b)}}n.exports={set:a,get:i,has:r,enforce:function(n){return r(n)?i(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=i(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(1),i=t(0),r=a.WeakMap;n.exports=i(r)&&/native code/.test(String(r))},function(n,e,t){var a=t(18),i=t(3),r=t(118),s=t(123),o=t(26),l=i([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=r.f(o(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(101),i=t(97).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,i)}},function(n,e,t){var a=t(29),i=t(120),r=t(32),s=function(n){return function(e,t,s){var o,l=a(e),c=r(l),u=i(s,c);if(n&&t!=t){for(;c>u;)if((o=l[u++])!=o)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){var a=t(66),i=Math.max,r=Math.min;n.exports=function(n,e){var t=a(n);return t<0?i(t+e,0):r(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(66),i=Math.min;n.exports=function(n){return n>0?i(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(2),i=t(0),r=/#|\.prototype\./,s=function(n,e){var t=l[o(n)];return t==u||t!=c&&(i(e)?a(e):!!e)},o=s.normalize=function(n){return String(n).replace(r,".").toLowerCase()},l=s.data={},c=s.NATIVE="N",u=s.POLYFILL="P";n.exports=s},function(n,e,t){var a=t(47),i=t(31),r=t(46),s=t(32),o=TypeError,l=function(n){return function(e,t,l,c){a(t);var u=i(e),d=r(u),p=s(u),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw o("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in d&&(c=t(c,d[m],m,u));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(2);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(17),i=t(1);n.exports="process"==a(i.process)},function(n,e,t){"use strict";var a=t(4),i=t(129),r=TypeError,s=Object.getOwnPropertyDescriptor,o=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=o?function(n,e){if(i(n)&&!s(n,"length").writable)throw r("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(17);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(27),i=t(1),r=t(132),s=t(133),o=i.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(o&&o[n]){var t={};t[n]=s("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return r(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return r(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return r(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return r(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return r(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return r(n,this,arguments)}})),c("URIError",(function(n){return function(e){return r(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return r(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return r(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return r(n,this,arguments)}}))},function(n,e,t){var a=t(28),i=Function.prototype,r=i.apply,s=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?s.bind(r):function(){return s.apply(r,arguments)})},function(n,e,t){"use strict";var a=t(18),i=t(8),r=t(19),s=t(57),o=t(67),l=t(65),c=t(135),u=t(136),d=t(137),p=t(141),m=t(142),h=t(143),g=t(4),f=t(62);n.exports=function(n,e,t,b){var v=b?2:1,y=n.split("."),k=y[y.length-1],x=a.apply(null,y);if(x){var w=x.prototype;if(!f&&i(w,"cause")&&delete w.cause,!t)return x;var E=a("Error"),_=e((function(n,e){var t=d(b?e:n,void 0),a=b?new x(n):new x;return void 0!==t&&r(a,"message",t),h&&r(a,"stack",m(a.stack,2)),this&&s(w,this)&&u(a,this,_),arguments.length>v&&p(a,arguments[v]),a}));if(_.prototype=w,"Error"!==k?o?o(_,E):l(_,E,{name:!0}):g&&"stackTraceLimit"in x&&(c(_,x,"stackTraceLimit"),c(_,x,"prepareStackTrace")),l(_,x),!f)try{w.name!==k&&r(w,"name",k),w.constructor=_}catch(n){}return _}}},function(n,e,t){var a=t(0),i=String,r=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw r("Can't set "+i(n)+" as a prototype")}},function(n,e,t){var a=t(16).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),i=t(9),r=t(67);n.exports=function(n,e,t){var s,o;return r&&a(s=e.constructor)&&s!==t&&i(o=s.prototype)&&o!==t.prototype&&r(n,o),n}},function(n,e,t){var a=t(138);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(139),i=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var a=t(140),i=t(0),r=t(17),s=t(30)("toStringTag"),o=Object,l="Arguments"==r(function(){return arguments}());n.exports=a?r:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=o(n),s))?t:l?r(e):"Object"==(a=r(e))&&i(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(30)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),i=t(19);n.exports=function(n,e){a(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var a=t(3),i=Error,r=a("".replace),s=String(i("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,l=o.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=r(n,o,"");return n}},function(n,e,t){var a=t(2),i=t(34);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(68),i=t(145);n.exports=function n(e,t,r,s,o){var l=-1,c=e.length;for(r||(r=i),o||(o=[]);++l<c;){var u=e[l];t>0&&r(u)?t>1?n(u,t-1,r,s,o):a(o,u):s||(o[o.length]=u)}return o}},function(n,e,t){var a=t(15),i=t(37),r=t(5),s=a?a.isConcatSpreadable:void 0;n.exports=function(n){return r(n)||i(n)||!!(s&&n&&n[s])}},function(n,e,t){var a=t(14),i=t(12);n.exports=function(n){return i(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),i=Object.prototype,r=i.hasOwnProperty,s=i.toString,o=a?a.toStringTag:void 0;n.exports=function(n){var e=r.call(n,o),t=n[o];try{n[o]=void 0;var a=!0}catch(n){}var i=s.call(n);return a&&(e?n[o]=t:delete n[o]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(150),i=t(206),r=t(45),s=t(5),o=t(217);n.exports=function(n){return"function"==typeof n?n:null==n?r:"object"==typeof n?s(n)?i(n[0],n[1]):a(n):o(n)}},function(n,e,t){var a=t(151),i=t(205),r=t(85);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?r(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(70),i=t(74);n.exports=function(n,e,t,r){var s=t.length,o=s,l=!r;if(null==n)return!o;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<o;){var u=(c=t[s])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var m=new a;if(r)var h=r(d,p,u,n,e,m);if(!(void 0===h?i(p,d,3,r,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(21),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(21);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(21);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=this.__data__,i=a(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var a=t(20);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(20),i=t(38),r=t(40);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var s=t.__data__;if(!i||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new r(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(72),i=t(163),r=t(39),s=t(73),o=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!r(n)||i(n))&&(a(n)?p:o).test(s(n))}},function(n,e,t){var a,i=t(164),r=(a=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!r&&r in n}},function(n,e,t){var a=t(6)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(167),i=t(20),r=t(38);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(r||i),string:new a}}},function(n,e,t){var a=t(168),i=t(169),r=t(170),s=t(171),o=t(172);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=i,l.prototype.get=r,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var a=t(22);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(22),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(22),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(23);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(23);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(23);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(23);n.exports=function(n,e){var t=a(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var a=t(70),i=t(75),r=t(182),s=t(185),o=t(201),l=t(5),c=t(79),u=t(81),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=l(n),b=l(e),v=f?"[object Array]":o(n),y=b?"[object Array]":o(e),k=(v="[object Arguments]"==v?d:v)==d,x=(y="[object Arguments]"==y?d:y)==d,w=v==y;if(w&&c(n)){if(!c(e))return!1;f=!0,k=!1}if(w&&!k)return g||(g=new a),f||u(n)?i(n,e,t,m,h,g):r(n,e,v,t,m,h,g);if(!(1&t)){var E=k&&p.call(n,"__wrapped__"),_=x&&p.call(e,"__wrapped__");if(E||_){var S=E?n.value():n,C=_?e.value():e;return g||(g=new a),h(S,C,t,m,g)}}return!!w&&(g||(g=new a),s(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),i=t(183),r=t(71),s=t(75),o=t(184),l=t(41),c=a?a.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return r(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=o;case"[object Set]":var h=1&a;if(m||(m=l),n.size!=e.size&&!h)return!1;var g=p.get(n);if(g)return g==e;a|=2,p.set(n,e);var f=s(m(n),m(e),a,c,d,p);return p.delete(n),f;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var a=t(6).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(186),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,r,s,o){var l=1&t,c=a(n),u=c.length;if(u!=a(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:i.call(e,p)))return!1}var m=o.get(n),h=o.get(e);if(m&&h)return m==e&&h==n;var g=!0;o.set(n,e),o.set(e,n);for(var f=l;++d<u;){var b=n[p=c[d]],v=e[p];if(r)var y=l?r(v,b,p,e,n,o):r(b,v,p,n,e,o);if(!(void 0===y?b===v||s(b,v,t,r,o):y)){g=!1;break}f||(f="constructor"==p)}if(g&&!f){var k=n.constructor,x=e.constructor;k==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof x&&x instanceof x||(g=!1)}return o.delete(n),o.delete(e),g}},function(n,e,t){var a=t(187),i=t(188),r=t(78);n.exports=function(n){return a(n,r,i)}},function(n,e,t){var a=t(68),i=t(5);n.exports=function(n,e,t){var r=e(n);return i(n)?r:a(r,t(n))}},function(n,e,t){var a=t(189),i=t(190),r=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,o=s?function(n){return null==n?[]:(n=Object(n),a(s(n),(function(e){return r.call(n,e)})))}:i;n.exports=o},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=0,r=[];++t<a;){var s=n[t];e(s,t,n)&&(r[i++]=s)}return r}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(192),i=t(37),r=t(5),s=t(79),o=t(80),l=t(81),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=r(n),u=!t&&i(n),d=!t&&!u&&s(n),p=!t&&!u&&!d&&l(n),m=t||u||d||p,h=m?a(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||d&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||o(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(14),i=t(42),r=t(12),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return r(n)&&i(n.length)&&!!s[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(69),i=e&&!e.nodeType&&e,r=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=r&&r.exports===i&&a.process,o=function(){try{var n=r&&r.require&&r.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=o}).call(this,t(49)(n))},function(n,e,t){var a=t(198),i=t(199),r=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return i(n);var e=[];for(var t in Object(n))r.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(200)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(202),i=t(38),r=t(203),s=t(83),o=t(204),l=t(14),c=t(73),u=c(a),d=c(i),p=c(r),m=c(s),h=c(o),g=l;(a&&"[object DataView]"!=g(new a(new ArrayBuffer(1)))||i&&"[object Map]"!=g(new i)||r&&"[object Promise]"!=g(r.resolve())||s&&"[object Set]"!=g(new s)||o&&"[object WeakMap]"!=g(new o))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var a=t(10)(t(6),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(6),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(6),"WeakMap");n.exports=a},function(n,e,t){var a=t(84),i=t(78);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var r=e[t],s=n[r];e[t]=[r,s,a(s)]}return e}},function(n,e,t){var a=t(74),i=t(207),r=t(214),s=t(43),o=t(84),l=t(85),c=t(24);n.exports=function(n,e){return s(n)&&o(e)?l(c(n),e):function(t){var s=i(t,n);return void 0===s&&s===e?r(t,n):a(e,s,3)}}},function(n,e,t){var a=t(86);n.exports=function(n,e,t){var i=null==n?void 0:a(n,e);return void 0===i?t:i}},function(n,e,t){var a=t(209),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,r=/\\(\\)?/g,s=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,a,i){e.push(a?i.replace(r,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var a=t(210);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(40);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,i=e?e.apply(this,a):a[0],r=t.cache;if(r.has(i))return r.get(i);var s=n.apply(this,a);return t.cache=r.set(i,s)||r,s};return t.cache=new(i.Cache||a),t}i.Cache=a,n.exports=i},function(n,e,t){var a=t(212);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),i=t(213),r=t(5),s=t(44),o=a?a.prototype:void 0,l=o?o.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(r(e))return i(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,i=Array(a);++t<a;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var a=t(215),i=t(216);n.exports=function(n,e){return null!=n&&i(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(87),i=t(37),r=t(5),s=t(80),o=t(42),l=t(24);n.exports=function(n,e,t){for(var c=-1,u=(e=a(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&o(u)&&s(p,u)&&(r(n)||i(n))}},function(n,e,t){var a=t(218),i=t(219),r=t(43),s=t(24);n.exports=function(n){return r(n)?a(s(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(86);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(45),i=t(221),r=t(223);n.exports=function(n,e){return r(i(n,e,a),n+"")}},function(n,e,t){var a=t(222),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var r=arguments,s=-1,o=i(r.length-e,0),l=Array(o);++s<o;)l[s]=r[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=r[s];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(224),i=t(227)(a);n.exports=i},function(n,e,t){var a=t(225),i=t(226),r=t(45),s=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:r;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),i=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var i=t(),r=16-(i-a);if(a=i,r>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(76),i=t(229),r=t(234),s=t(77),o=t(235),l=t(41);n.exports=function(n,e,t){var c=-1,u=i,d=n.length,p=!0,m=[],h=m;if(t)p=!1,u=r;else if(d>=200){var g=e?null:o(n);if(g)return l(g);p=!1,u=s,h=new a}else h=e?[]:m;n:for(;++c<d;){var f=n[c],b=e?e(f):f;if(f=t||0!==f?f:0,p&&b==b){for(var v=h.length;v--;)if(h[v]===b)continue n;e&&h.push(b),m.push(f)}else u(h,b,t)||(h!==m&&h.push(b),m.push(f))}return m}},function(n,e,t){var a=t(230);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(231),i=t(232),r=t(233);n.exports=function(n,e,t){return e==e?r(n,e,t):a(n,i,t)}},function(n,e){n.exports=function(n,e,t,a){for(var i=n.length,r=t+(a?1:-1);a?r--:++r<i;)if(e(n[r],r,n))return r;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,i=n.length;++a<i;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,i=null==n?0:n.length;++a<i;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(83),i=t(236),r=t(41),s=a&&1/r(new a([,-0]))[1]==1/0?function(n){return new a(n)}:i;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(82),i=t(12);n.exports=function(n){return i(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),i=Array.isArray;function r(n){return null==n}function s(n){return null!=n}function o(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),a=n.split(","),i=0;i<a.length;i++)t[a[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var y=v("key,ref,slot,slot-scope,is");function k(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function E(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,S=E((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),C=E((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),j=/\B([A-Z])/g,T=E((function(n){return n.replace(j,"-$1").toLowerCase()}));var q=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function R(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function M(n,e){for(var t in e)n[t]=e[t];return n}function A(n){for(var e={},t=0;t<n.length;t++)n[t]&&M(e,n[t]);return e}function z(n,e,t){}var I=function(n,e,t){return!1},B=function(n){return n};function O(n,e){if(n===e)return!0;var t=u(n),a=u(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var i=Array.isArray(n),r=Array.isArray(e);if(i&&r)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||r)return!1;var s=Object.keys(n),o=Object.keys(e);return s.length===o.length&&s.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function P(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function Q(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function D(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var L=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:I,isReservedAttr:I,isUnknownElement:I,getTagNamespace:z,parsePlatformTagName:B,mustUseProp:I,async:!0,_lifecycleHooks:N},$=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function J(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function F(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var G=new RegExp("[^".concat($.source,".$_\\d]"));var H="__proto__"in{},K="undefined"!=typeof window,X=K&&window.navigator.userAgent.toLowerCase(),V=X&&/msie|trident/.test(X),W=X&&X.indexOf("msie 9.0")>0,Y=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var Z=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var nn,en=X&&X.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(K)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var sn=function(){return void 0===nn&&(nn=!K&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},on=K&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,un="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function pn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,i,r,s,o){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=i,this.ns=void 0,this.context=r,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function fn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=[],yn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var kn=[];function xn(n){kn.push(n),yn.target=n}function wn(){kn.pop(),yn.target=kn[kn.length-1]}var En=Array.prototype,_n=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];F(_n,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var i,r=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&s.observeArray(i),s.dep.notify(),r}))}));var Sn=Object.getOwnPropertyNames(_n),Cn={},jn=!0;function Tn(n){jn=n}var qn={notify:z,depend:z,addSub:z,removeSub:z},Rn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?qn:new yn,this.vmCount=0,F(n,"__ob__",this),i(n)){if(!t)if(H)n.__proto__=_n;else for(var a=0,r=Sn.length;a<r;a++){F(n,o=Sn[a],_n[o])}e||this.observeArray(n)}else{var s=Object.keys(n);for(a=0;a<s.length;a++){var o;An(n,o=s[a],Cn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Mn(n[e],!1,this.mock)},n}();function Mn(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof Rn?n.__ob__:!jn||!t&&sn()||!i(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Dn(n)||n instanceof mn?void 0:new Rn(n,e,t)}function An(n,e,t,a,r,s){var o=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,u=l&&l.set;c&&!u||t!==Cn&&2!==arguments.length||(t=n[e]);var d=!r&&Mn(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(o.depend(),d&&(d.dep.depend(),i(e)&&Bn(e))),Dn(e)&&!r?e.value:e},set:function(e){var a=c?c.call(n):t;if(D(a,e)){if(u)u.call(n,e);else{if(c)return;if(!r&&Dn(a)&&!Dn(e))return void(a.value=e);t=e}d=!r&&Mn(e,!1,s),o.notify()}}}),o}}function zn(n,e,t){if(!Qn(n)){var a=n.__ob__;return i(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Mn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(An(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function In(n,e){if(i(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Qn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Bn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),i(e)&&Bn(e)}function On(n){return Pn(n,!0),F(n,"__v_isShallow",!0),n}function Pn(n,e){if(!Qn(n)){Mn(n,e,sn());0}}function Qn(n){return!(!n||!n.__v_isReadonly)}function Dn(n){return!(!n||!0!==n.__v_isRef)}function Ln(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Dn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Dn(a)&&!Dn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Nn;var Un=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Nn,!n&&Nn&&(this.index=(Nn.scopes||(Nn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Nn;try{return Nn=this,n()}finally{Nn=e}}else 0},n.prototype.on=function(){Nn=this},n.prototype.off=function(){Nn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function $n(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Jn=E((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Fn(n,e){function t(){var n=t.fns;if(!i(n))return je(n,null,arguments,e,"v-on handler");for(var a=n.slice(),r=0;r<a.length;r++)je(a[r],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,a,i,s){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=Jn(l),r(c)||(r(u)?(r(c.fns)&&(c=n[l]=Fn(c,s)),o(d.once)&&(c=n[l]=i(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)r(n[l])&&a((d=Jn(l)).name,e[l],d.capture)}function Hn(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),k(a.fns,l)}r(i)?a=Fn([l]):s(i.fns)&&o(i.merged)?(a=i).fns.push(l):a=Fn([i,l]),a.merged=!0,n[e]=a}function Kn(n,e,t,a,i){if(s(e)){if(w(e,t))return n[t]=e[t],i||delete e[t],!0;if(w(e,a))return n[t]=e[a],i||delete e[a],!0}return!1}function Xn(n){return l(n)?[gn(n)]:i(n)?function n(e,t){var a,c,u,d,p=[];for(a=0;a<e.length;a++)r(c=e[a])||"boolean"==typeof c||(u=p.length-1,d=p[u],i(c)?c.length>0&&(Vn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Vn(d)&&(p[u]=gn(d.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Vn(d)?p[u]=gn(d.text+c):""!==c&&p.push(gn(c)):Vn(c)&&Vn(d)?p[u]=gn(d.text+c.text):(o(e._isVList)&&s(c.tag)&&r(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),p.push(c)));return p}(n):void 0}function Vn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Wn(n,e){var t,a,r,o,l=null;if(i(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(r=Object.keys(n),l=new Array(r.length),t=0,a=r.length;t<a;t++)o=r[t],l[t]=e(n[o],o,t);return s(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,a){var i,r=this.$scopedSlots[n];r?(t=t||{},a&&(t=M(M({},a),t)),i=r(t)||(c(e)?e():e)):i=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},i):i}function Zn(n){return Rt(this.$options,"filters",n,!0)||B}function ne(n,e){return i(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,i){var r=U.keyCodes[e]||t;return i&&a&&!U.keyCodes[e]?ne(i,a):r?ne(r,n):a?T(a)!==e:void 0===n}function te(n,e,t,a,r){if(t)if(u(t)){i(t)&&(t=A(t));var s=void 0,o=function(i){if("class"===i||"style"===i||y(i))s=n;else{var o=n.attrs&&n.attrs.type;s=a||U.mustUseProp(e,o,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=S(i),c=T(i);l in s||c in s||(s[i]=t[i],r&&((n.on||(n.on={}))["update:".concat(i)]=function(n){t[i]=n}))};for(var l in t)o(l)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||re(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function ie(n,e,t){return re(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function re(n,e,t){if(i(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&se(n[a],"".concat(e,"_").concat(a),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function oe(n,e){if(e)if(p(e)){var t=n.on=n.on?M({},n.on):{};for(var a in e){var i=t[a],r=e[a];t[a]=i?[].concat(i,r):r}}else;return n}function le(n,e,t,a){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var s=n[r];i(s)?le(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return a&&(e.$key=a),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function ue(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=ie,n._n=b,n._s=f,n._l=Wn,n._t=Yn,n._q=O,n._i=P,n._m=ae,n._f=Zn,n._k=ee,n._b=te,n._v=gn,n._e=hn,n._u=le,n._g=oe,n._d=ce,n._p=ue}function pe(n,e){if(!n||!n.length)return{};for(var t={},a=0,i=n.length;a<i;a++){var r=n[a],s=r.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,r.context!==e&&r.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(r);else{var o=s.slot,l=t[o]||(t[o]=[]);"template"===r.tag?l.push.apply(l,r.children||[]):l.push(r)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,i){var r,s=Object.keys(t).length>0,o=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(o&&i&&i!==a&&l===i.$key&&!s&&!i.$hasNormal)return i;for(var c in r={},e)e[c]&&"$"!==c[0]&&(r[c]=fe(n,t,c,e[c]))}else r={};for(var u in t)u in r||(r[u]=be(t,u));return e&&Object.isExtensible(e)&&(e._normalized=r),F(r,"$stable",o),F(r,"$key",l),F(r,"$hasNormal",s),r}function fe(n,e,t,a){var r=function(){var e=dn;pn(n);var t=arguments.length?a.apply(null,arguments):a({}),r=(t=t&&"object"==typeof t&&!i(t)?[t]:Xn(t))&&t[0];return pn(e),t&&(!r||1===t.length&&r.isComment&&!he(r))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:r,enumerable:!0,configurable:!0}),r}function be(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};F(e,"_v_attr_proxy",!0),ye(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:q(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Ln(n,e,t)}))}}}function ye(n,e,t,a,i){var r=!1;for(var s in e)s in n?e[s]!==t[s]&&(r=!0):(r=!0,ke(n,s,a,i));for(var s in n)s in e||(r=!0,delete n[s]);return r}function ke(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function Ee(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function _e(n){if(i(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||he(t)))return t}}function Se(n,e,t,a,d,p){return(i(t)||l(t))&&(d=a,a=t,t=void 0),o(p)&&(d=2),function(n,e,t,a,l){if(s(t)&&s(t.__ob__))return hn();s(t)&&s(t.is)&&(e=t.is);if(!e)return hn();0;i(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Xn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(i(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var d,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||U.getTagNamespace(e),d=U.isReservedTag(e)?new mn(U.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!s(m=Rt(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):kt(m,t,n,a,e)}else d=kt(e,t,n,a);return i(d)?d:s(d)?(s(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(s(e.children))for(var i=0,l=e.children.length;i<l;i++){var c=e.children[i];s(c.tag)&&(r(c.ns)||o(a)&&"svg"!==c.tag)&&n(c,t,a)}}(d,p),s(t)&&function(n){u(n.style)&&Ue(n.style);u(n.class)&&Ue(n.class)}(t),d):hn()}(n,e,t,a,d)}function Ce(n,e,t){xn();try{if(e)for(var a=e;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var r=0;r<i.length;r++)try{if(!1===i[r].call(a,n,e,t))return}catch(n){Te(n,a,"errorCaptured hook")}}Te(n,e,t)}finally{wn()}}function je(n,e,t,a,i){var r;try{(r=t?n.apply(e,t):n.call(e))&&!r._isVue&&g(r)&&!r._handled&&(r.catch((function(n){return Ce(n,a,i+" (Promise/async)")})),r._handled=!0)}catch(n){Ce(n,a,i)}return r}function Te(n,e,t){if(U.errorHandler)try{return U.errorHandler.call(null,n,e,t)}catch(e){e!==n&&qe(e,null,"config.errorHandler")}qe(n,e,t)}function qe(n,e,t){if(!K||"undefined"==typeof console)throw n;console.error(n)}var Re,Me=!1,Ae=[],ze=!1;function Ie(){ze=!1;var n=Ae.slice(0);Ae.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Be=Promise.resolve();Re=function(){Be.then(Ie),Z&&setTimeout(z)},Me=!0}else if(V||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Re="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Ie)}:function(){setTimeout(Ie,0)};else{var Oe=1,Pe=new MutationObserver(Ie),Qe=document.createTextNode(String(Oe));Pe.observe(Qe,{characterData:!0}),Re=function(){Oe=(Oe+1)%2,Qe.data=String(Oe)},Me=!0}function De(n,e){var t;if(Ae.push((function(){if(n)try{n.call(e)}catch(n){Ce(n,e,"nextTick")}else t&&t(e)})),ze||(ze=!0,Re()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Le(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var a=n.$options;a[e]=Ct(a[e],t)}(t,n,e)}}Le("beforeMount"),Le("mounted"),Le("beforeUpdate"),Le("updated"),Le("beforeDestroy"),Le("destroyed"),Le("activated"),Le("deactivated"),Le("serverPrefetch"),Le("renderTracked"),Le("renderTriggered"),Le("errorCaptured");var Ne=new cn;function Ue(n){return function n(e,t){var a,r,s=i(e);if(!s&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(a=e.length;a--;)n(e[a],t);else if(Dn(e))n(e.value,t);else for(r=Object.keys(e),a=r.length;a--;)n(e[r[a]],t)}(n,Ne),Ne.clear(),n}var $e,Je=0,Fe=function(){function n(n,e,t,a,i){var r,s;r=this,void 0===(s=Nn&&!Nn._vm?Nn:n?n._scope:void 0)&&(s=Nn),s&&s.active&&s.effects.push(r),(this.vm=n)&&i&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Je,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ce(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ue(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');je(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){$e.$on(n,e)}function He(n,e){$e.$off(n,e)}function Ke(n,e){var t=$e;return function a(){var i=e.apply(null,arguments);null!==i&&t.$off(n,a)}}function Xe(n,e,t){$e=n,Gn(e,t||{},Ge,He,Ke,n),$e=void 0}var Ve=null;function We(n){var e=Ve;return Ve=n,function(){Ve=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ze(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ze(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),xn();var i=dn;a&&pn(n);var r=n.$options[e],s="".concat(e," hook");if(r)for(var o=0,l=r.length;o<l;o++)je(r[o],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),a&&pn(i),wn()}var et=[],tt=[],at={},it=!1,rt=!1,st=0;var ot=0,lt=Date.now;if(K&&!V){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var ut=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(ot=lt(),rt=!0,et.sort(ut),st=0;st<et.length;st++)(n=et[st]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();st=et.length=tt.length=0,at={},it=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ze(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),on&&U.devtools&&on.emit("flush")}function pt(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,rt){for(var t=et.length-1;t>st&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);it||(it=!0,De(dt))}}function mt(n,e){if(n){for(var t=Object.create(null),a=un?Reflect.ownKeys(n):Object.keys(n),i=0;i<a.length;i++){var r=a[i];if("__ob__"!==r){var s=n[r].from;if(s in e._provided)t[r]=e._provided[s];else if("default"in n[r]){var o=n[r].default;t[r]=c(o)?o.call(e):o}else 0}}return t}}function ht(n,e,t,r,s){var l,c=this,u=s.options;w(r,"_uid")?(l=Object.create(r))._original=r:(l=r,r=r._original);var d=o(u._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=mt(u.inject,r),this.slots=function(){return c.$slots||ge(r,n.scopedSlots,c.$slots=pe(t,r)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(r,n.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ge(r,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,a){var s=Se(l,n,e,t,a,p);return s&&!i(s)&&(s.fnScopeId=u._scopeId,s.fnContext=r),s}:this._c=function(n,e,t,a){return Se(l,n,e,t,a,p)}}function gt(n,e,t,a,i){var r=fn(n);return r.fnContext=t,r.fnOptions=a,e.slot&&((r.data||(r.data={})).slot=e.slot),r}function ft(n,e){for(var t in e)n[S(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}de(ht.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;s(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ve)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,i,r){var s=i.data.scopedSlots,o=n.$scopedSlots,l=!!(s&&!s.$stable||o!==a&&!o.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(r||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=i,n.$vnode=i,n._vnode&&(n._vnode.parent=i),n.$options._renderChildren=r;var d=i.data.attrs||a;n._attrsProxy&&ye(n._attrsProxy,d,u.data&&u.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,p),e&&n.$options.props){Tn(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],b=n.$options.props;m[f]=Mt(f,b,e,n)}Tn(!0),n.$options.propsData=e}c&&(n.$slots=pe(r,i.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Ze(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(vt);function kt(n,e,t,l,c){if(!r(n)){var d=t.$options._base;if(u(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(r(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=we;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),o(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var a=n.owners=[t],i=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return k(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=Q((function(t){n.resolved=Ee(t,e),i?a.length=0:d(!0)})),m=Q((function(e){s(n.errorComp)&&(n.error=!0,d(!0))})),h=n(p,m);return u(h)&&(g(h)?r(n.resolved)&&h.then(p,m):g(h.component)&&(h.component.then(p,m),s(h.error)&&(n.errorComp=Ee(h.error,e)),s(h.loading)&&(n.loadingComp=Ee(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,r(n.resolved)&&r(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),s(h.timeout)&&(c=setTimeout((function(){c=null,r(n.resolved)&&m(null)}),h.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,a,i){var r=hn();return r.asyncFactory=n,r.asyncMeta={data:e,context:t,children:a,tag:i},r}(p,e,t,l,c);e=e||{},Ft(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),o=r[a],l=e.model.callback;s(o)?(i(o)?-1===o.indexOf(l):o!==l)&&(r[a]=[l].concat(o)):r[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!r(a)){var i={},o=n.attrs,l=n.props;if(s(o)||s(l))for(var c in a){var u=T(c);Kn(i,l,c,u,!0)||Kn(i,o,c,u,!1)}return i}}(e,n);if(o(n.options.functional))return function(n,e,t,r,o){var l=n.options,c={},u=l.props;if(s(u))for(var d in u)c[d]=Mt(d,u,e||a);else s(t.attrs)&&ft(c,t.attrs),s(t.props)&&ft(c,t.props);var p=new ht(t,c,o,r,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return gt(m,t,p.parent,l,p);if(i(m)){for(var h=Xn(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=gt(h[f],t,p.parent,l,p);return g}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var a=yt[t],i=e[a],r=vt[a];i===r||i&&i._merged||(e[a]=i?xt(r,i):r)}}(e);var b=bt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function xt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var wt=z,Et=U.optionMergeStrategies;function _t(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,i,r,s=un?Reflect.ownKeys(e):Object.keys(e),o=0;o<s.length;o++)"__ob__"!==(a=s[o])&&(i=n[a],r=e[a],t&&w(n,a)?i!==r&&p(i)&&p(r)&&_t(i,r):zn(n,a,r));return n}function St(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,i=c(n)?n.call(t,t):n;return a?_t(a,i):i}:e?n?function(){return _t(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ct(n,e){var t=e?n?n.concat(e):i(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function jt(n,e,t,a){var i=Object.create(n||null);return e?M(i,e):i}Et.data=function(n,e,t){return t?St(n,e,t):e&&"function"!=typeof e?n:St(n,e)},N.forEach((function(n){Et[n]=Ct})),L.forEach((function(n){Et[n+"s"]=jt})),Et.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var s in M(r,n),e){var o=r[s],l=e[s];o&&!i(o)&&(o=[o]),r[s]=o?o.concat(l):i(l)?l:[l]}return r},Et.props=Et.methods=Et.inject=Et.computed=function(n,e,t,a){if(!n)return e;var i=Object.create(null);return M(i,n),e&&M(i,e),i},Et.provide=function(n,e){return n?function(){var t=Object.create(null);return _t(t,c(n)?n.call(this):n),e&&_t(t,c(e)?e.call(this):e,!1),t}:e};var Tt=function(n,e){return void 0===e?n:e};function qt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,r,s={};if(i(t))for(a=t.length;a--;)"string"==typeof(r=t[a])&&(s[S(r)]={type:null});else if(p(t))for(var o in t)r=t[o],s[S(o)]=p(r)?r:{type:r};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(i(t))for(var r=0;r<t.length;r++)a[t[r]]={from:t[r]};else if(p(t))for(var s in t){var o=t[s];a[s]=p(o)?M({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=qt(n,e.extends,t)),e.mixins))for(var a=0,r=e.mixins.length;a<r;a++)n=qt(n,e.mixins[a],t);var s,o={};for(s in n)l(s);for(s in e)w(n,s)||l(s);function l(a){var i=Et[a]||Tt;o[a]=i(n[a],e[a],t,a)}return o}function Rt(n,e,t,a){if("string"==typeof t){var i=n[e];if(w(i,t))return i[t];var r=S(t);if(w(i,r))return i[r];var s=C(r);return w(i,s)?i[s]:i[t]||i[r]||i[s]}}function Mt(n,e,t,a){var i=e[n],r=!w(t,n),s=t[n],o=Bt(Boolean,i.type);if(o>-1)if(r&&!w(i,"default"))s=!1;else if(""===s||s===T(n)){var l=Bt(String,i.type);(l<0||o<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==zt(e.type)?a.call(n):a}(a,i,n);var u=jn;Tn(!0),Mn(s),Tn(u)}return s}var At=/^\s*function (\w+)/;function zt(n){var e=n&&n.toString().match(At);return e?e[1]:""}function It(n,e){return zt(n)===zt(e)}function Bt(n,e){if(!i(e))return It(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(It(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:z,set:z};function Pt(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Qt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=On({}),i=n.$options._propKeys=[];n.$parent&&Tn(!1);var r=function(r){i.push(r);var s=Mt(r,e,t,n);An(a,r,s),r in n||Pt(n,"_props",r)};for(var s in e)r(s);Tn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=ve(n);pn(n),xn();var i=je(t,null,[n._props||On({}),a],n,"setup");if(wn(),pn(),c(i))e.render=i;else if(u(i))if(n._setupState=i,i.__sfc){var r=n._setupProxy={};for(var s in i)"__sfc"!==s&&Ln(r,i,s)}else for(var s in i)J(s)||Ln(n,i,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:q(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return Ce(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var r=t[i];0,a&&w(a,r)||J(r)||Pt(n,"_data",r)}var s=Mn(e);s&&s.vmCount++}(n);else{var t=Mn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=sn();for(var i in e){var r=e[i],s=c(r)?r:r.get;0,a||(t[i]=new Fe(n,s||z,z,Dt)),i in n||Lt(n,i,r)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(i(a))for(var r=0;r<a.length;r++)$t(n,t,a[r]);else $t(n,t,a)}}(n,e.watch)}var Dt={lazy:!0};function Lt(n,e,t){var a=!sn();c(t)?(Ot.get=a?Nt(e):Ut(t),Ot.set=z):(Ot.get=t.get?a&&!1!==t.cache?Nt(e):Ut(t.get):z,Ot.set=t.set||z),Object.defineProperty(n,e,Ot)}function Nt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ut(n){return function(){return n.call(this,this)}}function $t(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Jt=0;function Ft(n){var e=n.options;if(n.super){var t=Ft(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var i in t)t[i]!==a[i]&&(e||(e={}),e[i]=t[i]);return e}(n);a&&M(n.extendOptions,a),(e=n.options=qt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function Ht(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,i=n._Ctor||(n._Ctor={});if(i[a])return i[a];var r=bt(n)||bt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=qt(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)Pt(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)Lt(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,L.forEach((function(n){s[n]=t[n]})),r&&(s.options.components[r]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=M({},s.options),i[a]=s,s}}function Kt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Xt(n,e){return i(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Vt(n,e){var t=n.cache,a=n.keys,i=n._vnode;for(var r in t){var s=t[r];if(s){var o=s.name;o&&!e(o)&&Wt(t,r,a,i)}}}function Wt(n,e,t,a){var i=n[e];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),n[e]=null,k(t,e)}Gt.prototype._init=function(n){var e=this;e._uid=Jt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Un(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var i=a.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=qt(Ft(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,i=t&&t.context;n.$slots=pe(e._renderChildren,i),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,i){return Se(n,e,t,a,i,!1)},n.$createElement=function(e,t,a,i){return Se(n,e,t,a,i,!0)};var r=t&&t.data;An(n,"$attrs",r&&r.attrs||a,null,!0),An(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(Tn(!1),Object.keys(e).forEach((function(t){An(n,t,e[t])})),Tn(!0))}(e),Qt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var a=$n(n),i=un?Reflect.ownKeys(t):Object.keys(t),r=0;r<i.length;r++){var s=i[r];Object.defineProperty(a,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=zn,n.prototype.$delete=In,n.prototype.$watch=function(n,e,t){if(p(e))return $t(this,n,e,t);(t=t||{}).user=!0;var a=new Fe(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'.concat(a.expression,'"');xn(),je(e,this,[a.value],this,i),wn()}return function(){a.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(i(n))for(var r=0,s=n.length;r<s;r++)a.$on(n[r],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(n)){for(var a=0,r=n.length;a<r;a++)t.$off(n[a],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((s=o[l])===e||s.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?R(t):t;for(var a=R(arguments,1),i='event handler for "'.concat(n,'"'),r=0,s=t.length;r<s;r++)je(t[r],e,a,e,i)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,i=t._vnode,r=We(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),r(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||k(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return De(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,r=t._parentVnode;r&&e._isMounted&&(e.$scopedSlots=ge(e.$parent,r.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=r;try{pn(e),we=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Ce(t,e,"render"),n=e._vnode}finally{we=null,pn()}return i(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=r,n}}(Gt);var Yt=[String,RegExp,Array],Zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var i=t.tag,r=t.componentInstance,s=t.componentOptions;n[a]={name:Kt(s),tag:i,componentInstance:r},e.push(a),this.max&&e.length>parseInt(this.max)&&Wt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Wt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Vt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Vt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=_e(n),t=e&&e.componentOptions;if(t){var a=Kt(t),i=this.include,r=this.exclude;if(i&&(!a||!Xt(i,a))||r&&a&&Xt(r,a))return e;var s=this.cache,o=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,k(o,l),o.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return U}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:M,mergeOptions:qt,defineReactive:An},n.set=zn,n.delete=In,n.nextTick=De,n.observable=function(n){return Mn(n),n},n.options=Object.create(null),L.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,M(n.options.components,Zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=R(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=qt(this.options,n),this}}(n),Ht(n),function(n){L.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:sn}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:ht}),Gt.version="2.7.14";var na=v("style,class"),ea=v("input,textarea,option,select,progress"),ta=v("contenteditable,draggable,spellcheck"),aa=v("events,caret,typing,plaintext-only"),ia=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ra="http://www.w3.org/1999/xlink",sa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},oa=function(n){return sa(n)?n.slice(6,n.length):""},la=function(n){return null==n||!1===n};function ca(n){for(var e=n.data,t=n,a=n;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=ua(a.data,e));for(;s(t=t.parent);)t&&t.data&&(e=ua(e,t.data));return function(n,e){if(s(n)||s(e))return da(n,pa(e));return""}(e.staticClass,e.class)}function ua(n,e){return{staticClass:da(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function da(n,e){return n?e?n+" "+e:n:e||""}function pa(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,i=n.length;a<i;a++)s(e=pa(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ma={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ga=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fa=function(n){return ha(n)||ga(n)};var ba=Object.create(null);var va=v("text,number,password,search,email,tel,url");var ya=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ma[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),ka={create:function(n,e){xa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xa(n,!0),xa(e))},destroy:function(n){xa(n,!0)}};function xa(n,e){var t=n.data.ref;if(s(t)){var a=n.context,r=n.componentInstance||n.elm,o=e?null:r,l=e?void 0:r;if(c(t))je(t,a,[o],a,"template ref function");else{var u=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=Dn(t),m=a.$refs;if(d||p)if(u){var h=d?m[t]:t.value;e?i(h)&&k(h,r):i(h)?h.includes(r)||h.push(r):d?(m[t]=[r],wa(a,t,m[t])):t.value=[r]}else if(d){if(e&&m[t]!==r)return;m[t]=l,wa(a,t,o)}else if(p){if(e&&t.value!==r)return;t.value=o}else 0}}}function wa(n,e,t){var a=n._setupState;a&&w(a,e)&&(Dn(a[e])?a[e].value=t:a[e]=t)}var Ea=new mn("",{},[]),_a=["create","activate","update","remove","destroy"];function Sa(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=s(t=n.data)&&s(t=t.attrs)&&t.type,i=s(t=e.data)&&s(t=t.attrs)&&t.type;return a===i||va(a)&&va(i)}(n,e)||o(n.isAsyncPlaceholder)&&r(e.asyncFactory.error))}function Ca(n,e,t){var a,i,r={};for(a=e;a<=t;++a)s(i=n[a].key)&&(r[i]=a);return r}var ja={create:Ta,update:Ta,destroy:function(n){Ta(n,Ea)}};function Ta(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,i,r=n===Ea,s=e===Ea,o=Ra(n.data.directives,n.context),l=Ra(e.data.directives,e.context),c=[],u=[];for(t in l)a=o[t],i=l[t],a?(i.oldValue=a.value,i.oldArg=a.arg,Aa(i,"update",e,n),i.def&&i.def.componentUpdated&&u.push(i)):(Aa(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var d=function(){for(var t=0;t<c.length;t++)Aa(c[t],"inserted",e,n)};r?Hn(e,"insert",d):d()}u.length&&Hn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)Aa(u[t],"componentUpdated",e,n)}));if(!r)for(t in o)l[t]||Aa(o[t],"unbind",n,n,s)}(n,e)}var qa=Object.create(null);function Ra(n,e){var t,a,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=qa),i[Ma(a)]=a,e._setupState&&e._setupState.__sfc){var r=a.def||Rt(e,"_setupState","v-"+a.name);a.def="function"==typeof r?{bind:r,update:r}:r}a.def=a.def||Rt(e.$options,"directives",a.name)}return i}function Ma(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Aa(n,e,t,a,i){var r=n.def&&n.def[e];if(r)try{r(t.elm,n,t,a,i)}catch(a){Ce(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var za=[ka,ja];function Ia(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||r(n.data.attrs)&&r(e.data.attrs))){var a,i,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(a in(s(u.__ob__)||o(u._v_attr_proxy))&&(u=e.data.attrs=M({},u)),u)i=u[a],c[a]!==i&&Ba(l,a,i,e.data.pre);for(a in(V||Y)&&u.value!==c.value&&Ba(l,"value",u.value),c)r(u[a])&&(sa(a)?l.removeAttributeNS(ra,oa(a)):ta(a)||l.removeAttribute(a))}}function Ba(n,e,t,a){a||n.tagName.indexOf("-")>-1?Oa(n,e,t):ia(e)?la(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return la(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):sa(e)?la(t)?n.removeAttributeNS(ra,oa(e)):n.setAttributeNS(ra,e,t):Oa(n,e,t)}function Oa(n,e,t){if(la(t))n.removeAttribute(e);else{if(V&&!W&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Pa={create:Ia,update:Ia};function Qa(n,e){var t=e.elm,a=e.data,i=n.data;if(!(r(a.staticClass)&&r(a.class)&&(r(i)||r(i.staticClass)&&r(i.class)))){var o=ca(e),l=t._transitionClasses;s(l)&&(o=da(o,pa(l))),o!==t._prevClass&&(t.setAttribute("class",o),t._prevClass=o)}}var Da,La={create:Qa,update:Qa};function Na(n,e,t){var a=Da;return function i(){var r=e.apply(null,arguments);null!==r&&Ja(n,i,t,a)}}var Ua=Me&&!(en&&Number(en[1])<=53);function $a(n,e,t,a){if(Ua){var i=ot,r=e;e=r._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return r.apply(this,arguments)}}Da.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Ja(n,e,t,a){(a||Da).removeEventListener(n,e._wrapper||e,t)}function Fa(n,e){if(!r(n.data.on)||!r(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Da=e.elm||n.elm,function(n){if(s(n.__r)){var e=V?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,a,$a,Ja,Na,e.context),Da=void 0}}var Ga,Ha={create:Fa,update:Fa,destroy:function(n){return Fa(n,Ea)}};function Ka(n,e){if(!r(n.data.domProps)||!r(e.data.domProps)){var t,a,i=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||o(c._v_attr_proxy))&&(c=e.data.domProps=M({},c)),l)t in c||(i[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=a;var u=r(a)?"":String(a);Xa(i,u)&&(i.value=u)}else if("innerHTML"===t&&ga(i.tagName)&&r(i.innerHTML)){(Ga=Ga||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var d=Ga.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(a!==l[t])try{i[t]=a}catch(n){}}}}function Xa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(s(a)){if(a.number)return b(t)!==b(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Va={create:Ka,update:Ka},Wa=E((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ya(n){var e=Za(n.style);return n.staticStyle?M(n.staticStyle,e):e}function Za(n){return Array.isArray(n)?A(n):"string"==typeof n?Wa(n):n}var ni,ei=/^--/,ti=/\s*!important$/,ai=function(n,e,t){if(ei.test(e))n.style.setProperty(e,t);else if(ti.test(t))n.style.setProperty(T(e),t.replace(ti,""),"important");else{var a=ri(e);if(Array.isArray(t))for(var i=0,r=t.length;i<r;i++)n.style[a]=t[i];else n.style[a]=t}},ii=["Webkit","Moz","ms"],ri=E((function(n){if(ni=ni||document.createElement("div").style,"filter"!==(n=S(n))&&n in ni)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ii.length;t++){var a=ii[t]+e;if(a in ni)return a}}));function si(n,e){var t=e.data,a=n.data;if(!(r(t.staticStyle)&&r(t.style)&&r(a.staticStyle)&&r(a.style))){var i,o,l=e.elm,c=a.staticStyle,u=a.normalizedStyle||a.style||{},d=c||u,p=Za(e.data.style)||{};e.data.normalizedStyle=s(p.__ob__)?M({},p):p;var m=function(n,e){var t,a={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Ya(i.data))&&M(a,t);(t=Ya(n.data))&&M(a,t);for(var r=n;r=r.parent;)r.data&&(t=Ya(r.data))&&M(a,t);return a}(e,!0);for(o in d)r(m[o])&&ai(l,o,"");for(o in m)(i=m[o])!==d[o]&&ai(l,o,null==i?"":i)}}var oi={create:si,update:si},li=/\s+/;function ci(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(li).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ui(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(li).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function di(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&M(e,pi(n.name||"v")),M(e,n),e}return"string"==typeof n?pi(n):void 0}}var pi=E((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mi=K&&!W,hi="transition",gi="transitionend",fi="animation",bi="animationend";mi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hi="WebkitTransition",gi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fi="WebkitAnimation",bi="webkitAnimationEnd"));var vi=K?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yi(n){vi((function(){vi(n)}))}function ki(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ci(n,e))}function xi(n,e){n._transitionClasses&&k(n._transitionClasses,e),ui(n,e)}function wi(n,e,t){var a=_i(n,e),i=a.type,r=a.timeout,s=a.propCount;if(!i)return t();var o="transition"===i?gi:bi,l=0,c=function(){n.removeEventListener(o,u),t()},u=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),r+1),n.addEventListener(o,u)}var Ei=/\b(transform|all)(,|$)/;function _i(n,e){var t,a=window.getComputedStyle(n),i=(a[hi+"Delay"]||"").split(", "),r=(a[hi+"Duration"]||"").split(", "),s=Si(i,r),o=(a[fi+"Delay"]||"").split(", "),l=(a[fi+"Duration"]||"").split(", "),c=Si(o,l),u=0,d=0;return"transition"===e?s>0&&(t="transition",u=s,d=r.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?r.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&Ei.test(a[hi+"Property"])}}function Si(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ci(e)+Ci(n[t])})))}function Ci(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ji(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=di(n.data.transition);if(!r(a)&&!s(t._enterCb)&&1===t.nodeType){for(var i=a.css,o=a.type,l=a.enterClass,d=a.enterToClass,p=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,g=a.appearActiveClass,f=a.beforeEnter,v=a.enter,y=a.afterEnter,k=a.enterCancelled,x=a.beforeAppear,w=a.appear,E=a.afterAppear,_=a.appearCancelled,S=a.duration,C=Ve,j=Ve.$vnode;j&&j.parent;)C=j.context,j=j.parent;var T=!C._isMounted||!n.isRootInsert;if(!T||w||""===w){var q=T&&m?m:l,R=T&&g?g:p,M=T&&h?h:d,A=T&&x||f,z=T&&c(w)?w:v,I=T&&E||y,B=T&&_||k,O=b(u(S)?S.enter:S);0;var P=!1!==i&&!W,D=Ri(z),L=t._enterCb=Q((function(){P&&(xi(t,M),xi(t,R)),L.cancelled?(P&&xi(t,q),B&&B(t)):I&&I(t),t._enterCb=null}));n.data.show||Hn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,L)})),A&&A(t),P&&(ki(t,q),ki(t,R),yi((function(){xi(t,q),L.cancelled||(ki(t,M),D||(qi(O)?setTimeout(L,O):wi(t,o,L)))}))),n.data.show&&(e&&e(),z&&z(t,L)),P||D||L()}}}function Ti(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=di(n.data.transition);if(r(a)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var i=a.css,o=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,p=a.beforeLeave,m=a.leave,h=a.afterLeave,g=a.leaveCancelled,f=a.delayLeave,v=a.duration,y=!1!==i&&!W,k=Ri(m),x=b(u(v)?v.leave:v);0;var w=t._leaveCb=Q((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(xi(t,c),xi(t,d)),w.cancelled?(y&&xi(t,l),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(E):E()}function E(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(ki(t,l),ki(t,d),yi((function(){xi(t,l),w.cancelled||(ki(t,c),k||(qi(x)?setTimeout(w,x):wi(t,o,w)))}))),m&&m(t,w),y||k||w())}}function qi(n){return"number"==typeof n&&!isNaN(n)}function Ri(n){if(r(n))return!1;var e=n.fns;return s(e)?Ri(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Mi(n,e){!0!==e.data.show&&ji(e)}var Ai=function(n){var e,t,a={},c=n.modules,u=n.nodeOps;for(e=0;e<_a.length;++e)for(a[_a[e]]=[],t=0;t<c.length;++t)s(c[t][_a[e]])&&a[_a[e]].push(c[t][_a[e]]);function d(n){var e=u.parentNode(n);s(e)&&u.removeChild(e,n)}function p(n,e,t,i,r,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=fn(n)),n.isRootInsert=!r,!function(n,e,t,i){var r=n.data;if(s(r)){var l=s(n.componentInstance)&&r.keepAlive;if(s(r=r.hook)&&s(r=r.init)&&r(n,!1),s(n.componentInstance))return m(n,e),h(t,n.elm,i),o(l)&&function(n,e,t,i){var r,o=n;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(r=o.data)&&s(r=r.transition)){for(r=0;r<a.activate.length;++r)a.activate[r](Ea,o);e.push(o);break}h(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var d=n.data,p=n.children,f=n.tag;s(f)?(n.elm=n.ns?u.createElementNS(n.ns,f):u.createElement(f,n),y(n),g(n,p,e),s(d)&&b(n,e),h(t,n.elm,i)):o(n.isComment)?(n.elm=u.createComment(n.text),h(t,n.elm,i)):(n.elm=u.createTextNode(n.text),h(t,n.elm,i))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(b(n,e),y(n)):(xa(n),e.push(n))}function h(n,e,t){s(n)&&(s(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function g(n,e,t){if(i(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function b(n,t){for(var i=0;i<a.create.length;++i)a.create[i](Ea,n);s(e=n.data.hook)&&(s(e.create)&&e.create(Ea,n),s(e.insert)&&t.push(n))}function y(n){var e;if(s(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;s(e=Ve)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function k(n,e,t,a,i,r){for(;a<=i;++a)p(t[a],r,n,e,!1,t,a)}function x(n){var e,t,i=n.data;if(s(i))for(s(e=i.hook)&&s(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];s(a)&&(s(a.tag)?(E(a),x(a)):d(a.elm))}}function E(n,e){if(s(e)||s(n.data)){var t,i=a.remove.length+1;for(s(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,i),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&E(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else d(n.elm)}function _(n,e,t,a){for(var i=t;i<a;i++){var r=e[i];if(s(r)&&Sa(n,r))return i}}function S(n,e,t,i,l,c){if(n!==e){s(e.elm)&&s(i)&&(e=i[l]=fn(e));var d=e.elm=n.elm;if(o(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?T(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;s(h)&&s(m=h.hook)&&s(m=m.prepatch)&&m(n,e);var g=n.children,b=e.children;if(s(h)&&f(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);s(m=h.hook)&&s(m=m.update)&&m(n,e)}r(e.text)?s(g)&&s(b)?g!==b&&function(n,e,t,a,i){var o,l,c,d=0,m=0,h=e.length-1,g=e[0],f=e[h],b=t.length-1,v=t[0],y=t[b],x=!i;for(0;d<=h&&m<=b;)r(g)?g=e[++d]:r(f)?f=e[--h]:Sa(g,v)?(S(g,v,a,t,m),g=e[++d],v=t[++m]):Sa(f,y)?(S(f,y,a,t,b),f=e[--h],y=t[--b]):Sa(g,y)?(S(g,y,a,t,b),x&&u.insertBefore(n,g.elm,u.nextSibling(f.elm)),g=e[++d],y=t[--b]):Sa(f,v)?(S(f,v,a,t,m),x&&u.insertBefore(n,f.elm,g.elm),f=e[--h],v=t[++m]):(r(o)&&(o=Ca(e,d,h)),r(l=s(v.key)?o[v.key]:_(v,e,d,h))?p(v,a,n,g.elm,!1,t,m):Sa(c=e[l],v)?(S(c,v,a,t,m),e[l]=void 0,x&&u.insertBefore(n,c.elm,g.elm)):p(v,a,n,g.elm,!1,t,m),v=t[++m]);d>h?k(n,r(t[b+1])?null:t[b+1].elm,t,m,b,a):m>b&&w(e,d,h)}(d,g,b,t,c):s(b)?(s(n.text)&&u.setTextContent(d,""),k(d,null,b,0,b.length-1,t)):s(g)?w(g,0,g.length-1):s(n.text)&&u.setTextContent(d,""):n.text!==e.text&&u.setTextContent(d,e.text),s(h)&&s(m=h.hook)&&s(m=m.postpatch)&&m(n,e)}}}function C(n,e,t){if(o(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var j=v("attrs,class,staticClass,staticStyle,key");function T(n,e,t,a){var i,r=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,o(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(i=l.hook)&&s(i=i.init)&&i(e,!0),s(i=e.componentInstance)))return m(e,t),!0;if(s(r)){if(s(c))if(n.hasChildNodes())if(s(i=l)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,p=0;p<c.length;p++){if(!d||!T(d,c[p],t,a)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else g(e,c,t);if(s(l)){var h=!1;for(var f in l)if(!j(f)){h=!0,b(e,t);break}!h&&l.class&&Ue(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!r(e)){var l,c=!1,d=[];if(r(n))c=!0,p(e,d);else{var m=s(n.nodeType);if(!m&&Sa(n,e))S(n,e,d,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&T(n,e,d))return C(e,d,!0),n;l=n,n=new mn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=u.parentNode(h);if(p(e,d,h._leaveCb?null:g,u.nextSibling(h)),s(e.parent))for(var b=e.parent,v=f(e);b;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](b);if(b.elm=e.elm,v){for(var k=0;k<a.create.length;++k)a.create[k](Ea,b);var E=b.data.hook.insert;if(E.merged)for(var _=1;_<E.fns.length;_++)E.fns[_]()}else xa(b);b=b.parent}s(g)?w([n],0,0):s(n.tag)&&x(n)}}return C(e,d,c),e.elm}s(n)&&x(n)}}({nodeOps:ya,modules:[Pa,La,Ha,Va,oi,K?{create:Mi,activate:Mi,remove:function(n,e){!0!==n.data.show?Ti(n,e):e()}}:{}].concat(za)});W&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Li(n,"input")}));var zi={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Hn(t,"postpatch",(function(){zi.componentUpdated(n,e,t)})):Ii(n,e,t.context),n._vOptions=[].map.call(n.options,Pi)):("textarea"===t.tag||va(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Qi),n.addEventListener("compositionend",Di),n.addEventListener("change",Di),W&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ii(n,e,t.context);var a=n._vOptions,i=n._vOptions=[].map.call(n.options,Pi);if(i.some((function(n,e){return!O(n,a[e])})))(n.multiple?e.value.some((function(n){return Oi(n,i)})):e.value!==e.oldValue&&Oi(e.value,i))&&Li(n,"change")}}};function Ii(n,e,t){Bi(n,e,t),(V||Y)&&setTimeout((function(){Bi(n,e,t)}),0)}function Bi(n,e,t){var a=e.value,i=n.multiple;if(!i||Array.isArray(a)){for(var r,s,o=0,l=n.options.length;o<l;o++)if(s=n.options[o],i)r=P(a,Pi(s))>-1,s.selected!==r&&(s.selected=r);else if(O(Pi(s),a))return void(n.selectedIndex!==o&&(n.selectedIndex=o));i||(n.selectedIndex=-1)}}function Oi(n,e){return e.every((function(e){return!O(e,n)}))}function Pi(n){return"_value"in n?n._value:n.value}function Qi(n){n.target.composing=!0}function Di(n){n.target.composing&&(n.target.composing=!1,Li(n.target,"input"))}function Li(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ni(n){return!n.componentInstance||n.data&&n.data.transition?n:Ni(n.componentInstance._vnode)}var Ui={model:zi,show:{bind:function(n,e,t){var a=e.value,i=(t=Ni(t)).data&&t.data.transition,r=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&i?(t.data.show=!0,ji(t,(function(){n.style.display=r}))):n.style.display=a?r:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ni(t)).data&&t.data.transition?(t.data.show=!0,a?ji(t,(function(){n.style.display=n.__vOriginalDisplay})):Ti(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,i){i||(n.style.display=n.__vOriginalDisplay)}}},$i={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ji(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ji(_e(e.children)):n}function Fi(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var i=t._parentListeners;for(var a in i)e[S(a)]=i[a];return e}function Gi(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Hi=function(n){return n.tag||he(n)},Ki=function(n){return"show"===n.name},Xi={name:"transition",props:$i,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Hi)).length){0;var a=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var r=Ji(i);if(!r)return i;if(this._leaving)return Gi(n,i);var s="__transition-".concat(this._uid,"-");r.key=null==r.key?r.isComment?s+"comment":s+r.tag:l(r.key)?0===String(r.key).indexOf(s)?r.key:s+r.key:r.key;var o=(r.data||(r.data={})).transition=Fi(this),c=this._vnode,u=Ji(c);if(r.data.directives&&r.data.directives.some(Ki)&&(r.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(r,u)&&!he(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=M({},o);if("out-in"===a)return this._leaving=!0,Hn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Gi(n,i);if("in-out"===a){if(he(r))return c;var p,m=function(){p()};Hn(o,"afterEnter",m),Hn(o,"enterCancelled",m),Hn(d,"delayLeave",(function(n){p=n}))}}return i}}},Vi=M({tag:String,moveClass:String},$i);function Wi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Yi(n){n.data.newPos=n.elm.getBoundingClientRect()}function Zi(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,i=e.top-t.top;if(a||i){n.data.moved=!0;var r=n.elm.style;r.transform=r.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),r.transitionDuration="0s"}}delete Vi.mode;var nr={Transition:Xi,TransitionGroup:{props:Vi,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var i=We(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],r=this.children=[],s=Fi(this),o=0;o<i.length;o++){if((u=i[o]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))r.push(u),t[u.key]=u,(u.data||(u.data={})).transition=s;else;}if(a){var l=[],c=[];for(o=0;o<a.length;o++){var u;(u=a[o]).data.transition=s,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,r)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Wi),n.forEach(Yi),n.forEach(Zi),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;ki(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(gi,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(gi,n),t._moveCb=null,xi(t,e))})}})))},methods:{hasMove:function(n,e){if(!mi)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ui(t,n)})),ci(t,e),t.style.display="none",this.$el.appendChild(t);var a=_i(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function er(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=fa,Gt.config.isReservedAttr=na,Gt.config.getTagNamespace=function(n){return ga(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!K)return!0;if(fa(n))return!1;if(n=n.toLowerCase(),null!=ba[n])return ba[n];var e=document.createElement(n);return n.indexOf("-")>-1?ba[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ba[n]=/HTMLUnknownElement/.test(e.toString())},M(Gt.options.directives,Ui),M(Gt.options.components,nr),Gt.prototype.__patch__=K?Ai:z,Gt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new Fe(n,a,z,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var i=n._preWatchers;if(i)for(var r=0;r<i.length;r++)i[r].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&K?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},K&&setTimeout((function(){U.devtools&&on&&on.emit("init",Gt)}),0);var tr=/[!'()*]/g,ar=function(n){return"%"+n.charCodeAt(0).toString(16)},ir=/%2C/g,rr=function(n){return encodeURIComponent(n).replace(tr,ar).replace(ir,",")};function sr(n){try{return decodeURIComponent(n)}catch(n){0}return n}var or=function(n){return null==n||"object"==typeof n?n:String(n)};function lr(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=sr(t.shift()),i=t.length>0?sr(t.join("=")):null;void 0===e[a]?e[a]=i:Array.isArray(e[a])?e[a].push(i):e[a]=[e[a],i]})),e):e}function cr(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return rr(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(rr(e)):a.push(rr(e)+"="+rr(n)))})),a.join("&")}return rr(e)+"="+rr(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ur=/\/?$/;function dr(n,e,t,a){var i=a&&a.options.stringifyQuery,r=e.query||{};try{r=pr(r)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:r,params:e.params||{},fullPath:gr(e,i),matched:n?hr(n):[]};return t&&(s.redirectedFrom=gr(t,i)),Object.freeze(s)}function pr(n){if(Array.isArray(n))return n.map(pr);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pr(n[t]);return e}return n}var mr=dr(null,{path:"/"});function hr(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function gr(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||cr)(a)+i}function fr(n,e,t){return e===mr?n===e:!!e&&(n.path&&e.path?n.path.replace(ur,"")===e.path.replace(ur,"")&&(t||n.hash===e.hash&&br(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&br(n.query,e.query)&&br(n.params,e.params))))}function br(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,i){var r=n[t];if(a[i]!==t)return!1;var s=e[t];return null==r||null==s?r===s:"object"==typeof r&&"object"==typeof s?br(r,s):String(r)===String(s)}))}function vr(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var i=t.instances[a],r=t.enteredCbs[a];if(i&&r){delete t.enteredCbs[a];for(var s=0;s<r.length;s++)i._isBeingDestroyed||r[s](i)}}}}var yr={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,r=e.data;r.routerView=!0;for(var s=i.$createElement,o=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),u=0,d=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&u++,p.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(r.routerViewDepth=u,d){var m=c[o],h=m&&m.component;return h?(m.configProps&&kr(h,r,m.route,m.configProps),s(h,r,a)):s()}var g=l.matched[u],f=g&&g.components[o];if(!g||!f)return c[o]=null,s();c[o]={component:f},r.registerRouteInstance=function(n,e){var t=g.instances[o];(e&&t!==n||!e&&t===n)&&(g.instances[o]=e)},(r.hook||(r.hook={})).prepatch=function(n,e){g.instances[o]=e.componentInstance},r.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[o]&&(g.instances[o]=n.componentInstance),vr(l)};var b=g.props&&g.props[o];return b&&(er(c[o],{route:l,configProps:b}),kr(f,r,l,b)),s(f,r,a)}};function kr(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=er({},i);var r=e.attrs=e.attrs||{};for(var s in i)n.props&&s in n.props||(r[s]=i[s],delete i[s])}}function xr(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var r=n.replace(/^\//,"").split("/"),s=0;s<r.length;s++){var o=r[s];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function wr(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Er=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},_r=Qr,Sr=Rr,Cr=function(n,e){return Ar(Rr(n,e),e)},jr=Ar,Tr=Pr,qr=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Rr(n,e){for(var t,a=[],i=0,r=0,s="",o=e&&e.delimiter||"/";null!=(t=qr.exec(n));){var l=t[0],c=t[1],u=t.index;if(s+=n.slice(r,u),r=u+l.length,c)s+=c[1];else{var d=n[r],p=t[2],m=t[3],h=t[4],g=t[5],f=t[6],b=t[7];s&&(a.push(s),s="");var v=null!=p&&null!=d&&d!==p,y="+"===f||"*"===f,k="?"===f||"*"===f,x=t[2]||o,w=h||g;a.push({name:m||i++,prefix:p||"",delimiter:x,optional:k,repeat:y,partial:v,asterisk:!!b,pattern:w?Ir(w):b?".*":"[^"+zr(x)+"]+?"})}}return r<n.length&&(s+=n.substr(r)),s&&a.push(s),a}function Mr(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Ar(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Or(e)));return function(e,a){for(var i="",r=e||{},s=(a||{}).pretty?Mr:encodeURIComponent,o=0;o<n.length;o++){var l=n[o];if("string"!=typeof l){var c,u=r[l.name];if(null==u){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Er(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=s(u[d]),!t[o].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(u),!t[o].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function zr(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Ir(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Br(n,e){return n.keys=e,n}function Or(n){return n&&n.sensitive?"":"i"}function Pr(n,e,t){Er(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,i=!1!==t.end,r="",s=0;s<n.length;s++){var o=n[s];if("string"==typeof o)r+=zr(o);else{var l=zr(o.prefix),c="(?:"+o.pattern+")";e.push(o),o.repeat&&(c+="(?:"+l+c+")*"),r+=c=o.optional?o.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=zr(t.delimiter||"/"),d=r.slice(-u.length)===u;return a||(r=(d?r.slice(0,-u.length):r)+"(?:"+u+"(?=$))?"),r+=i?"$":a&&d?"":"(?="+u+"|$)",Br(new RegExp("^"+r,Or(t)),e)}function Qr(n,e,t){return Er(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Br(n,e)}(n,e):Er(n)?function(n,e,t){for(var a=[],i=0;i<n.length;i++)a.push(Qr(n[i],e,t).source);return Br(new RegExp("(?:"+a.join("|")+")",Or(t)),e)}(n,e,t):function(n,e,t){return Pr(Rr(n,t),e,t)}(n,e,t)}_r.parse=Sr,_r.compile=Cr,_r.tokensToFunction=jr,_r.tokensToRegExp=Tr;var Dr=Object.create(null);function Lr(n,e,t){e=e||{};try{var a=Dr[n]||(Dr[n]=_r.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Nr(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var r=(i=er({},n)).params;return r&&"object"==typeof r&&(i.params=er({},r)),i}if(!i.path&&i.params&&e){(i=er({},i))._normalized=!0;var s=er(er({},e.params),i.params);if(e.name)i.name=e.name,i.params=s;else if(e.matched.length){var o=e.matched[e.matched.length-1].path;i.path=Lr(o,s,e.path)}else 0;return i}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",u=l.path?xr(l.path,c,t||i.append):c,d=function(n,e,t){void 0===e&&(e={});var a,i=t||lr;try{a=i(n||"")}catch(n){a={}}for(var r in e){var s=e[r];a[r]=Array.isArray(s)?s.map(or):or(s)}return a}(l.query,i.query,a&&a.options.parseQuery),p=i.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var Ur,$r=function(){},Jr={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),r=i.location,s=i.route,o=i.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,m=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=s.redirectedFrom?dr(null,Nr(s.redirectedFrom),null,t):s;l[h]=fr(a,g,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ur,"/").indexOf(e.path.replace(ur,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,g);var f=l[h]?this.ariaCurrentValue:null,b=function(n){Fr(n)&&(e.replace?t.replace(r,$r):t.push(r,$r))},v={click:Fr};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=b})):v[this.event]=b;var y={class:l},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:s,navigate:b,isActive:l[m],isExactActive:l[h]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)y.on=v,y.attrs={href:o,"aria-current":f};else{var x=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=er({},x.data);for(var E in w.on=w.on||{},w.on){var _=w.on[E];E in v&&(w.on[E]=Array.isArray(_)?_:[_])}for(var S in v)S in w.on?w.on[S].push(v[S]):w.on[S]=b;var C=x.data.attrs=er({},x.data.attrs);C.href=o,C["aria-current"]=f}else y.on=v}return n(this.tag,y,this.$slots.default)}};function Fr(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Gr="undefined"!=typeof window;function Hr(n,e,t,a,i){var r=e||[],s=t||Object.create(null),o=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,i,r,s){var o=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return wr(e.path+"/"+n)}(o,r,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var d={path:u,regex:Kr(u,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:r,matchAs:s,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var r=s?wr(s+"/"+i.path):void 0;n(e,t,a,i,d,r)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:i.children};n(e,t,a,h,r,d.path||"/")}l&&(a[l]||(a[l]=d))}(r,s,o,n,i)}));for(var l=0,c=r.length;l<c;l++)"*"===r[l]&&(r.push(r.splice(l,1)[0]),c--,l--);return{pathList:r,pathMap:s,nameMap:o}}function Kr(n,e){return _r(n,[],e)}function Xr(n,e){var t=Hr(n),a=t.pathList,i=t.pathMap,r=t.nameMap;function s(n,t,s){var o=Nr(n,t,!1,e),c=o.name;if(c){var u=r[c];if(!u)return l(null,o);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof o.params&&(o.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in o.params)&&d.indexOf(p)>-1&&(o.params[p]=t.params[p]);return o.path=Lr(u.path,o.params),l(u,o,s)}if(o.path){o.params={};for(var m=0;m<a.length;m++){var h=a[m],g=i[h];if(Vr(g.regex,o.path,o.params))return l(g,o,s)}}return l(null,o)}function o(n,t){var a=n.redirect,i="function"==typeof a?a(dr(n,t,null,e)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var o=i,c=o.name,u=o.path,d=t.query,p=t.hash,m=t.params;if(d=o.hasOwnProperty("query")?o.query:d,p=o.hasOwnProperty("hash")?o.hash:p,m=o.hasOwnProperty("params")?o.params:m,c){r[c];return s({_normalized:!0,name:c,query:d,hash:p,params:m},void 0,t)}if(u){var h=function(n,e){return xr(n,e.parent?e.parent.path:"/",!0)}(u,n);return s({_normalized:!0,path:Lr(h,m),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?o(n,a||t):n&&n.matchAs?function(n,e,t){var a=s({_normalized:!0,path:Lr(t,e.params)});if(a){var i=a.matched,r=i[i.length-1];return e.params=a.params,l(r,e)}return l(null,e)}(0,t,n.matchAs):dr(n,t,a,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?r[n]:void 0;Hr([e||n],a,i,r,t),t&&t.alias.length&&Hr(t.alias.map((function(n){return{path:n,children:[e]}})),a,i,r,t)},getRoutes:function(){return a.map((function(n){return i[n]}))},addRoutes:function(n){Hr(n,a,i,r)}}}function Vr(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var i=1,r=a.length;i<r;++i){var s=n.keys[i-1];s&&(t[s.name||"pathMatch"]="string"==typeof a[i]?sr(a[i]):a[i])}return!0}var Wr=Gr&&window.performance&&window.performance.now?window.performance:Date;function Yr(){return Wr.now().toFixed(3)}var Zr=Yr();function ns(){return Zr}function es(n){return Zr=n}var ts=Object.create(null);function as(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=er({},window.history.state);return t.key=ns(),window.history.replaceState(t,"",e),window.addEventListener("popstate",ss),function(){window.removeEventListener("popstate",ss)}}function is(n,e,t,a){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var r=function(){var n=ns();if(n)return ts[n]}(),s=i.call(n,e,t,a?r:null);s&&("function"==typeof s.then?s.then((function(n){ds(n,r)})).catch((function(n){0})):ds(s,r))}))}}function rs(){var n=ns();n&&(ts[n]={x:window.pageXOffset,y:window.pageYOffset})}function ss(n){rs(),n.state&&n.state.key&&es(n.state.key)}function os(n){return cs(n.x)||cs(n.y)}function ls(n){return{x:cs(n.x)?n.x:window.pageXOffset,y:cs(n.y)?n.y:window.pageYOffset}}function cs(n){return"number"==typeof n}var us=/^#\d/;function ds(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var i=us.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var r=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(i,r={x:cs((t=r).x)?t.x:0,y:cs(t.y)?t.y:0})}else os(n)&&(e=ls(n))}else a&&os(n)&&(e=ls(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ps,ms=Gr&&((-1===(ps=window.navigator.userAgent).indexOf("Android 2.")&&-1===ps.indexOf("Android 4.0")||-1===ps.indexOf("Mobile Safari")||-1!==ps.indexOf("Chrome")||-1!==ps.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function hs(n,e){rs();var t=window.history;try{if(e){var a=er({},t.state);a.key=ns(),t.replaceState(a,"",n)}else t.pushState({key:es(Yr())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function gs(n){hs(n,!0)}var fs={redirected:2,aborted:4,cancelled:8,duplicated:16};function bs(n,e){return ys(n,e,fs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ks.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function vs(n,e){return ys(n,e,fs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ys(n,e,t,a){var i=new Error(a);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var ks=["params","query","hash"];function xs(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ws(n,e){return xs(n)&&n._isRouter&&(null==e||n.type===e)}function Es(n,e,t){var a=function(i){i>=n.length?t():n[i]?e(n[i],(function(){a(i+1)})):a(i+1)};a(0)}function _s(n){return function(e,t,a){var i=!1,r=0,s=null;Ss(n,(function(n,e,t,o){if("function"==typeof n&&void 0===n.cid){i=!0,r++;var l,c=Ts((function(e){var i;((i=e).__esModule||js&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ur.extend(e),t.components[o]=e,--r<=0&&a()})),u=Ts((function(n){var e="Failed to resolve async component "+o+": "+n;s||(s=xs(n)?n:new Error(e),a(s))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),i||a()}}function Ss(n,e){return Cs(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Cs(n){return Array.prototype.concat.apply([],n)}var js="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ts(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var qs=function(n,e){this.router=n,this.base=function(n){if(!n)if(Gr){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mr,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Rs(n,e,t,a){var i=Ss(n,(function(n,a,i,r){var s=function(n,e){"function"!=typeof n&&(n=Ur.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,a,i,r)})):t(s,a,i,r)}));return Cs(a?i.reverse():i)}function Ms(n,e){if(e)return function(){return n.apply(e,arguments)}}qs.prototype.listen=function(n){this.cb=n},qs.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},qs.prototype.onError=function(n){this.errorCbs.push(n)},qs.prototype.transitionTo=function(n,e,t){var a,i=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var r=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),e&&e(a),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(a,r)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!i.ready&&(ws(n,fs.redirected)&&r===mr||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},qs.prototype.confirmTransition=function(n,e,t){var a=this,i=this.current;this.pending=n;var r,s,o=function(n){!ws(n)&&xs(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(fr(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&is(this.router,i,n,!1),o(((s=ys(r=i,n,fs.duplicated,'Avoided redundant navigation to current location: "'+r.fullPath+'".')).name="NavigationDuplicated",s));var u=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,m=u.activated,h=[].concat(function(n){return Rs(n,"beforeRouteLeave",Ms,!0)}(p),this.router.beforeHooks,function(n){return Rs(n,"beforeRouteUpdate",Ms)}(d),m.map((function(n){return n.beforeEnter})),_s(m)),g=function(e,t){if(a.pending!==n)return o(vs(i,n));try{e(n,i,(function(e){!1===e?(a.ensureURL(!0),o(function(n,e){return ys(n,e,fs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):xs(e)?(a.ensureURL(!0),o(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(o(bs(i,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){o(n)}};Es(h,g,(function(){Es(function(n){return Rs(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,i,r){return n(a,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),r(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),g,(function(){if(a.pending!==n)return o(vs(i,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){vr(n)}))}))}))},qs.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},qs.prototype.setupListeners=function(){},qs.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mr,this.pending=null};var As=function(n){function e(e,t){n.call(this,e,t),this._startLocation=zs(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=ms&&t;a&&this.listeners.push(as());var i=function(){var t=n.current,i=zs(n.base);n.current===mr&&i===n._startLocation||n.transitionTo(i,(function(n){a&&is(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){hs(wr(a.base+n.fullPath)),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){gs(wr(a.base+n.fullPath)),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(zs(this.base)!==this.current.fullPath){var e=wr(this.base+this.current.fullPath);n?hs(e):gs(e)}},e.prototype.getCurrentLocation=function(){return zs(this.base)},e}(qs);function zs(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(wr(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Is=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=zs(n);if(!/^\/#/.test(e))return window.location.replace(wr(n+"/#"+e)),!0}(this.base)||Bs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ms&&e;t&&this.listeners.push(as());var a=function(){var e=n.current;Bs()&&n.transitionTo(Os(),(function(a){t&&is(n.router,a,e,!0),ms||Ds(a.fullPath)}))},i=ms?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},e.prototype.push=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Qs(n.fullPath),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,i=this.current;this.transitionTo(n,(function(n){Ds(n.fullPath),is(a.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Os()!==e&&(n?Qs(e):Ds(e))},e.prototype.getCurrentLocation=function(){return Os()},e}(qs);function Bs(){var n=Os();return"/"===n.charAt(0)||(Ds("/"+n),!1)}function Os(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ps(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Qs(n){ms?hs(Ps(n)):window.location.hash=n}function Ds(n){ms?gs(Ps(n)):window.location.replace(Ps(n))}var Ls=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){ws(n,fs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(qs),Ns=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Xr(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ms&&!1!==n.fallback,this.fallback&&(e="hash"),Gr||(e="abstract"),this.mode=e,e){case"history":this.history=new As(this,n.base);break;case"hash":this.history=new Is(this,n.base,this.fallback);break;case"abstract":this.history=new Ls(this,n.base);break;default:0}},Us={currentRoute:{configurable:!0}};Ns.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Us.currentRoute.get=function(){return this.history&&this.history.current},Ns.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof As||t instanceof Is){var a=function(n){t.setupListeners(),function(n){var a=t.current,i=e.options.scrollBehavior;ms&&i&&"fullPath"in n&&is(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ns.prototype.beforeEach=function(n){return Js(this.beforeHooks,n)},Ns.prototype.beforeResolve=function(n){return Js(this.resolveHooks,n)},Ns.prototype.afterEach=function(n){return Js(this.afterHooks,n)},Ns.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ns.prototype.onError=function(n){this.history.onError(n)},Ns.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Ns.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ns.prototype.go=function(n){this.history.go(n)},Ns.prototype.back=function(){this.go(-1)},Ns.prototype.forward=function(){this.go(1)},Ns.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ns.prototype.resolve=function(n,e,t){var a=Nr(n,e=e||this.history.current,t,this),i=this.match(a,e),r=i.redirectedFrom||i.fullPath;return{location:a,route:i,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?wr(n+"/"+a):a}(this.history.base,r,this.mode),normalizedTo:a,resolved:i}},Ns.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ns.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mr&&this.history.transitionTo(this.history.getCurrentLocation())},Ns.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mr&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ns.prototype,Us);var $s=Ns;function Js(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ns.install=function n(e){if(!n.installed||Ur!==e){n.installed=!0,Ur=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yr),e.component("RouterLink",Jr);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},Ns.version="3.6.5",Ns.isNavigationFailure=ws,Ns.NavigationFailureType=fs,Ns.START_LOCATION=mr,Gr&&window.Vue&&window.Vue.use(Ns);t(104);t(13),t(131);var Fs={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,327)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,326))},Gs={"v-4ef1cd73":()=>t.e(5).then(t.bind(null,328)),"v-14111292":()=>t.e(7).then(t.bind(null,329)),"v-20278ad4":()=>t.e(6).then(t.bind(null,330)),"v-73a2391c":()=>t.e(9).then(t.bind(null,331)),"v-2e82d988":()=>t.e(8).then(t.bind(null,332)),"v-7d77e79a":()=>t.e(10).then(t.bind(null,333)),"v-fbe99ed8":()=>t.e(13).then(t.bind(null,334)),"v-62132423":()=>t.e(14).then(t.bind(null,335)),"v-786c2dcf":()=>t.e(16).then(t.bind(null,336)),"v-604f08d4":()=>t.e(15).then(t.bind(null,337)),"v-951a3cee":()=>t.e(11).then(t.bind(null,338)),"v-3fbbc302":()=>t.e(17).then(t.bind(null,339)),"v-39560dc6":()=>t.e(18).then(t.bind(null,340)),"v-01b3aea8":()=>t.e(19).then(t.bind(null,341)),"v-064b0f4d":()=>t.e(12).then(t.bind(null,342)),"v-5ea527a0":()=>t.e(20).then(t.bind(null,343)),"v-09e33dd4":()=>t.e(21).then(t.bind(null,344)),"v-1efa53dd":()=>t.e(22).then(t.bind(null,345)),"v-61a56867":()=>t.e(24).then(t.bind(null,346)),"v-676e814a":()=>t.e(23).then(t.bind(null,347)),"v-176b8424":()=>t.e(25).then(t.bind(null,348)),"v-313f6d8e":()=>t.e(26).then(t.bind(null,349)),"v-504527c9":()=>t.e(27).then(t.bind(null,350)),"v-6bf9b24a":()=>t.e(28).then(t.bind(null,351)),"v-61944210":()=>t.e(29).then(t.bind(null,352)),"v-72d51d8a":()=>t.e(30).then(t.bind(null,353)),"v-62914f02":()=>t.e(31).then(t.bind(null,354)),"v-1813f0ae":()=>t.e(32).then(t.bind(null,355)),"v-2d4c79d3":()=>t.e(33).then(t.bind(null,356)),"v-f3d5199e":()=>t.e(34).then(t.bind(null,357)),"v-452796f4":()=>t.e(35).then(t.bind(null,358)),"v-cfdc7134":()=>t.e(36).then(t.bind(null,359)),"v-8d31a9f4":()=>t.e(37).then(t.bind(null,360)),"v-25f34b1c":()=>t.e(38).then(t.bind(null,361))};function Hs(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ks=/-(\w)/g,Xs=Hs(n=>n.replace(Ks,(n,e)=>e?e.toUpperCase():"")),Vs=/\B([A-Z])/g,Ws=Hs(n=>n.replace(Vs,"-$1").toLowerCase()),Ys=Hs(n=>n.charAt(0).toUpperCase()+n.slice(1));function Zs(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ys(Xs(e))):n(Ys(e))||n(Ws(e))}const no=Object.assign({},Fs,Gs),eo=n=>no[n],to=n=>Gs[n],ao=n=>Fs[n],io=n=>Gt.component(n);function ro(n){return Zs(to,n)}function so(n){return Zs(ao,n)}function oo(n){return Zs(eo,n)}function lo(n){return Zs(io,n)}function co(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!lo(n)&&oo(n)){const e=await oo(n)();Gt.component(n,e.default)}}))}function uo(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var po=t(93),mo=t.n(po),ho=t(94),go=t.n(ho),fo={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${go()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vo(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=yo(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return mo()([{name:"description",content:this.$description}],n,this.siteMeta,ko)},updateCanonicalLink(){bo(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vo(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){yo(null,this.currentMetaTags),bo()}};function bo(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vo(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function yo(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ko(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var xo=t(50),wo={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xo)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let n=0;n<e.length;n++){const r=e[n],s=e[n+1],o=0===n&&0===t||t>=r.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(o&&l!==decodeURIComponent(r.hash)){const t=r;if(i===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Eo=t(25),_o=t.n(Eo),So={mounted(){_o.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||_o.a.start(),t()}),this.$router.afterEach(()=>{_o.a.done(),this.isSidebarOpen=!1})}};t(238),t(239);class Co{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var jo={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Co).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},To="auto",qo="zoom-in",Ro="zoom-out",Mo="grab",Ao="move";function zo(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};a?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Io(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Bo(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Oo(n,e,t){!function(n){var e=Po,t=Qo;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var a=n.style,i={};for(var r in e)t&&(i[r]=a[r]||""),a[r]=e[r];return i}var Po="transition",Qo="transform",Do="transform",Lo="transitionend";var No=function(){},Uo={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:No,onClose:No,onGrab:No,onMove:No,onRelease:No,onBeforeOpen:No,onBeforeClose:No,onBeforeGrab:No,onBeforeRelease:No,onImageLoading:No,onImageLoaded:No},$o={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Fo(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,r=this.options.scrollThreshold;(Math.abs(i)>=r||Math.abs(a)>=r)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Jo(n)&&!Fo(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Jo(n)&&!Fo(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Jo(n){return 0===n.button}function Fo(n){return n.metaKey||n.ctrlKey}var Go={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Oo(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),zo(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Oo(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ho="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Ko=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),Xo=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},Vo={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Bo(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Mo:Ro,transition:Do+"\n        "+a+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Oo(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Oo(this.el,{transform:"none"})},grab:function(n,e,t){var a=Wo(),i=a.x-n,r=a.y-e;Oo(this.el,{cursor:Ao,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=Wo(),i=a.x-n,r=a.y-e;Oo(this.el,{transition:Do,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+r)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Oo(this.el,this.styleClose)},restoreOpenStyle:function(){Oo(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Wo(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,i=a.customSize,r=a.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Ho(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var s=this.rect.width/2,o=this.rect.height/2,l=Wo(),c={x:l.x-s,y:l.y-o},u=c.x/s,d=c.y/o,p=r+Math.min(u,d);if(i&&"string"==typeof i){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(i)*m/(100*this.rect.width),f=parseFloat(i)*h/(100*this.rect.height);if(p>g||p>f)return{x:g,y:f}}return{x:p,y:p}}};function Wo(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Yo(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){zo(n,a,e[a],t)}))}var Zo=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Vo),this.overlay=Object.create(Go),this.handler=Object.create($o),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Xo({},Uo,e),this.overlay.init(this),this.handler.init(this)}return Ko(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=qo,zo(n,"click",this.handler.click),this.options.preloadImage&&Io(Bo(n)));return this}},{key:"config",value:function(n){return n?(Xo(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(a),Io(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),zo(document,"scroll",this.handler.scroll),zo(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&zo(window,"resize",this.handler.resizeWindow);var r=function n(){zo(a,Lo,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Yo(document,e.handler,!0),t(a)};return zo(a,Lo,r),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=To,this.overlay.fadeOut(),this.target.zoomOut(),zo(document,"scroll",this.handler.scroll,!1),zo(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&zo(window,"resize",this.handler.resizeWindow,!1);var a=function a(){zo(t,Lo,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Yo(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return zo(t,Lo,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var r=function n(){zo(i,Lo,n,!1),a(i)};return zo(i,Lo,r),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ao,this.target.move(n,e,t);var i=this.target.el,r=function n(){zo(i,Lo,n,!1),a(i)};return zo(i,Lo,r),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=To,this.target.restoreOpenStyle();var a=function a(){zo(t,Lo,a,!1),n.lock=!1,n.released=!0,e(t)};return zo(t,Lo,a),this}}}]),n}();const nl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),el=Number("500");class tl{constructor(){this.instance=new Zo(nl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=el){setTimeout(()=>this.update(n),e)}}var al=[fo,wo,So,jo,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new tl,this.$vuepress.zooming.updateDelay()}}],il={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return uo("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},rl=t(7),sl=Object(rl.a)(il,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(sl,"mixins",al);const ol=[{name:"v-4ef1cd73",path:"/pages/kas755c4/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-4ef1cd73").then(t)}},{path:"/pages/kas755c4/index.html",redirect:"/pages/kas755c4/"},{path:"/01.Java/01.JavaSE/01.Java概述&环境搭建.html",redirect:"/pages/kas755c4/"},{name:"v-14111292",path:"/pages/09kei4a8/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-14111292").then(t)}},{path:"/pages/09kei4a8/index.html",redirect:"/pages/09kei4a8/"},{path:"/02.Java框架/01.SpringCloud/02.SpringCloud Zookeeper.html",redirect:"/pages/09kei4a8/"},{name:"v-20278ad4",path:"/pages/24j4ehty/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-20278ad4").then(t)}},{path:"/pages/24j4ehty/index.html",redirect:"/pages/24j4ehty/"},{path:"/02.Java框架/01.SpringCloud/01.SpringCloud Eureka.html",redirect:"/pages/24j4ehty/"},{name:"v-73a2391c",path:"/pages/bp3ikv4g/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-73a2391c").then(t)}},{path:"/pages/bp3ikv4g/index.html",redirect:"/pages/bp3ikv4g/"},{path:"/03.数据库/02.Redis/01.Redis概述&安装.html",redirect:"/pages/bp3ikv4g/"},{name:"v-2e82d988",path:"/pages/yuu0dk4i/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-2e82d988").then(t)}},{path:"/pages/yuu0dk4i/index.html",redirect:"/pages/yuu0dk4i/"},{path:"/02.Java框架/01.SpringCloud/03.SpringCloud Consul.html",redirect:"/pages/yuu0dk4i/"},{name:"v-7d77e79a",path:"/pages/0oaka83c/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-7d77e79a").then(t)}},{path:"/pages/0oaka83c/index.html",redirect:"/pages/0oaka83c/"},{path:"/03.数据库/02.Redis/02.Redis常用命令&数据类型.html",redirect:"/pages/0oaka83c/"},{name:"v-fbe99ed8",path:"/pages/wuy0993s/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-fbe99ed8").then(t)}},{path:"/pages/wuy0993s/index.html",redirect:"/pages/wuy0993s/"},{path:"/03.数据库/02.Redis/05.Redis新数据类型.html",redirect:"/pages/wuy0993s/"},{name:"v-62132423",path:"/pages/a7v81744/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-62132423").then(t)}},{path:"/pages/a7v81744/index.html",redirect:"/pages/a7v81744/"},{path:"/03.数据库/02.Redis/06.Redis Java客户端Jedis.html",redirect:"/pages/a7v81744/"},{name:"v-786c2dcf",path:"/pages/sm8jwpla/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-786c2dcf").then(t)}},{path:"/pages/sm8jwpla/index.html",redirect:"/pages/sm8jwpla/"},{path:"/04.中间件/01.消息中间件/01.MQ的相关概念.html",redirect:"/pages/sm8jwpla/"},{name:"v-604f08d4",path:"/pages/jsf92i5m/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-604f08d4").then(t)}},{path:"/pages/jsf92i5m/index.html",redirect:"/pages/jsf92i5m/"},{path:"/03.数据库/02.Redis/07.SpringBoot整合Redis.html",redirect:"/pages/jsf92i5m/"},{name:"v-951a3cee",path:"/pages/57aemd8k/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-951a3cee").then(t)}},{path:"/pages/57aemd8k/index.html",redirect:"/pages/57aemd8k/"},{path:"/03.数据库/02.Redis/03.Redis配置文件.html",redirect:"/pages/57aemd8k/"},{name:"v-3fbbc302",path:"/pages/vd45cpcf/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-3fbbc302").then(t)}},{path:"/pages/vd45cpcf/index.html",redirect:"/pages/vd45cpcf/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/01.RabbitMQ介绍.html",redirect:"/pages/vd45cpcf/"},{name:"v-39560dc6",path:"/pages/kr5yv2xa/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-39560dc6").then(t)}},{path:"/pages/kr5yv2xa/index.html",redirect:"/pages/kr5yv2xa/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/02.RabbitMQ安装&常用命令.html",redirect:"/pages/kr5yv2xa/"},{name:"v-01b3aea8",path:"/pages/hs9by9nl/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-01b3aea8").then(t)}},{path:"/pages/hs9by9nl/index.html",redirect:"/pages/hs9by9nl/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/03.RabbitMQ入门程序.html",redirect:"/pages/hs9by9nl/"},{name:"v-064b0f4d",path:"/pages/3a16c7g6/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-064b0f4d").then(t)}},{path:"/pages/3a16c7g6/index.html",redirect:"/pages/3a16c7g6/"},{path:"/03.数据库/02.Redis/04.Redis发布和订阅.html",redirect:"/pages/3a16c7g6/"},{name:"v-5ea527a0",path:"/pages/b2xtwkg7/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-5ea527a0").then(t)}},{path:"/pages/b2xtwkg7/index.html",redirect:"/pages/b2xtwkg7/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/04.RabbitMQ工作队列.html",redirect:"/pages/b2xtwkg7/"},{name:"v-09e33dd4",path:"/pages/hf5rpdk0/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-09e33dd4").then(t)}},{path:"/pages/hf5rpdk0/index.html",redirect:"/pages/hf5rpdk0/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/05.RabbitMQ发布确认.html",redirect:"/pages/hf5rpdk0/"},{name:"v-1efa53dd",path:"/pages/umb37yap/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-1efa53dd").then(t)}},{path:"/pages/umb37yap/index.html",redirect:"/pages/umb37yap/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/06.RabbitMQ交换机.html",redirect:"/pages/umb37yap/"},{name:"v-61a56867",path:"/pages/0dmo0ykv/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-61a56867").then(t)}},{path:"/pages/0dmo0ykv/index.html",redirect:"/pages/0dmo0ykv/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/08.SpringBoot整合RabbitMQ.html",redirect:"/pages/0dmo0ykv/"},{name:"v-676e814a",path:"/pages/l98puwie/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-676e814a").then(t)}},{path:"/pages/l98puwie/index.html",redirect:"/pages/l98puwie/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/07.RabbitMQ死信队列.html",redirect:"/pages/l98puwie/"},{name:"v-176b8424",path:"/pages/8s5gukww/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-176b8424").then(t)}},{path:"/pages/8s5gukww/index.html",redirect:"/pages/8s5gukww/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/09.RabbitMQ延时队列.html",redirect:"/pages/8s5gukww/"},{name:"v-313f6d8e",path:"/pages/mcht59cm/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-313f6d8e").then(t)}},{path:"/pages/mcht59cm/index.html",redirect:"/pages/mcht59cm/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/10.RabbitMQ发布确认高级.html",redirect:"/pages/mcht59cm/"},{name:"v-504527c9",path:"/pages/5ctcr5a6/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-504527c9").then(t)}},{path:"/pages/5ctcr5a6/index.html",redirect:"/pages/5ctcr5a6/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/11.RabbitMQ其他知识点.html",redirect:"/pages/5ctcr5a6/"},{name:"v-6bf9b24a",path:"/pages/1kma3r88/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-6bf9b24a").then(t)}},{path:"/pages/1kma3r88/index.html",redirect:"/pages/1kma3r88/"},{path:"/04.中间件/01.消息中间件/1001.RabbitMQ/12.RabbitMQ集群.html",redirect:"/pages/1kma3r88/"},{name:"v-61944210",path:"/pages/e938xib2/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-61944210").then(t)}},{path:"/pages/e938xib2/index.html",redirect:"/pages/e938xib2/"},{path:"/05.运维/01.Linux/01.Linux虚拟机安装和设置ContOS7.6.html",redirect:"/pages/e938xib2/"},{name:"v-72d51d8a",path:"/pages/45rn88gi/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-72d51d8a").then(t)}},{path:"/pages/45rn88gi/index.html",redirect:"/pages/45rn88gi/"},{path:"/05.运维/01.Linux/02.Linux虚拟机VMwareTools安装+使用详解.html",redirect:"/pages/45rn88gi/"},{name:"v-62914f02",path:"/pages/eb9ks77i/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-62914f02").then(t)}},{path:"/pages/eb9ks77i/index.html",redirect:"/pages/eb9ks77i/"},{path:"/06.工具/01.Git/01.Git基础命令.html",redirect:"/pages/eb9ks77i/"},{name:"v-1813f0ae",path:"/pages/34mo4hjp/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-1813f0ae").then(t)}},{path:"/pages/34mo4hjp/index.html",redirect:"/pages/34mo4hjp/"},{path:"/06.工具/01.Git/02.Git分支.html",redirect:"/pages/34mo4hjp/"},{name:"v-2d4c79d3",path:"/pages/1cpd2f32/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-2d4c79d3").then(t)}},{path:"/pages/1cpd2f32/index.html",redirect:"/pages/1cpd2f32/"},{path:"/06.工具/01.Git/03.Git远程仓库.html",redirect:"/pages/1cpd2f32/"},{name:"v-f3d5199e",path:"/pages/lp31htbk/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-f3d5199e").then(t)}},{path:"/pages/lp31htbk/index.html",redirect:"/pages/lp31htbk/"},{path:"/06.工具/01.Git/04.MacOS安装Git.html",redirect:"/pages/lp31htbk/"},{name:"v-452796f4",path:"/archives/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-452796f4").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-cfdc7134",path:"/categories/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-cfdc7134").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-8d31a9f4",path:"/tags/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-8d31a9f4").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-25f34b1c",path:"/",component:sl,beforeEnter:(n,e,t)=>{co("Layout","v-25f34b1c").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:sl}],ll={title:"乔木先生",description:"Java后端技术博客,专注Java后端学习与总结。Java,Spring,SpringBoot,SpringMVC,SpringCloud,Mybatis,Linux,css3,html5,Maven,git,github等技术文章。",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"Java后端技术博客,专注Java后端学习与总结。Java,Spring,SpringBoot,SpringMVC,SpringCloud,Mybatis,Linux,css3,html5,Maven,git,github等技术文章。"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"Java概述",frontmatter:{title:"Java概述",date:"2022-11-22T11:30:56.000Z",permalink:"/pages/kas755c4/",categories:["Java"],tags:["JavaSE"],author:"乔木先生"},regularPath:"/01.Java/01.JavaSE/01.Java%E6%A6%82%E8%BF%B0&%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"01.Java/01.JavaSE/01.Java概述&环境搭建.md",key:"v-4ef1cd73",path:"/pages/kas755c4/",headers:[{level:2,title:"Java语言概述",slug:"java语言概述",normalizedTitle:"java语言概述",charIndex:2},{level:3,title:"Java简史",slug:"java简史",normalizedTitle:"java简史",charIndex:284},{level:3,title:"Java技术体系平台",slug:"java技术体系平台",normalizedTitle:"java技术体系平台",charIndex:905},{level:3,title:"Java在各领域的应用",slug:"java在各领域的应用",normalizedTitle:"java在各领域的应用",charIndex:1295},{level:3,title:"Java语言的诞生",slug:"java语言的诞生",normalizedTitle:"java语言的诞生",charIndex:1723},{level:3,title:"主要特性",slug:"主要特性",normalizedTitle:"主要特性",charIndex:2144},{level:3,title:"Java语言的特点",slug:"java语言的特点",normalizedTitle:"java语言的特点",charIndex:2944},{level:3,title:"跨平台性",slug:"跨平台性",normalizedTitle:"跨平台性",charIndex:3083},{level:3,title:"垃圾回收",slug:"垃圾回收",normalizedTitle:"垃圾回收",charIndex:1774},{level:2,title:"JDK、JRE、JVM",slug:"jdk、jre、jvm",normalizedTitle:"jdk、jre、jvm",charIndex:3512},{level:3,title:"Java虚拟机 (Java Virtal Machine)",slug:"java虚拟机-java-virtal-machine",normalizedTitle:"java虚拟机 (java virtal machine)",charIndex:3866},{level:4,title:"Java虚拟机的内存划分",slug:"java虚拟机的内存划分",normalizedTitle:"java虚拟机的内存划分",charIndex:4040},{level:2,title:"环境搭建",slug:"环境搭建",normalizedTitle:"环境搭建",charIndex:4274},{level:3,title:"下载、安装",slug:"下载、安装",normalizedTitle:"下载、安装",charIndex:4283},{level:3,title:"配置环境变量",slug:"配置环境变量",normalizedTitle:"配置环境变量",charIndex:4414},{level:4,title:"配置一",slug:"配置一",normalizedTitle:"配置一",charIndex:4814},{level:4,title:"配置二",slug:"配置二",normalizedTitle:"配置二",charIndex:4902},{level:4,title:"检测",slug:"检测",normalizedTitle:"检测",charIndex:4966}],excerpt:'<h2 id="java语言概述"><a class="header-anchor" href="#java语言概述">#</a> Java语言概述</h2>\n<p>Java是<strong>SUN(Stanford University Network，斯坦福大学网络公司) 1995</strong>年推出的一门高级编程语言。</p>\n<p>是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中。</p>\n<p>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。</p>\n',headersStr:"Java语言概述 Java简史 Java技术体系平台 Java在各领域的应用 Java语言的诞生 主要特性 Java语言的特点 跨平台性 垃圾回收 JDK、JRE、JVM Java虚拟机 (Java Virtal Machine) Java虚拟机的内存划分 环境搭建 下载、安装 配置环境变量 配置一 配置二 检测",content:"# Java语言概述\n\nJava是SUN(Stanford University Network，斯坦福大学网络公司) 1995年推出的一门高级编程语言。\n\n是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中。\n\n随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。\n\n后台开发：Java、PHP、Python、Go、Node.js\n\n\n# Java简史\n\n * 1991年 Green项目，开发语言最初命名为Oak (橡树)\n * 1994年，开发组意识到Oak 非常适合于互联网\n * 1996年，发布JDK1.0，约8.3万个网页应用Java技术来制作\n * 1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最\n * 1998年，发布JDK 1.2，同年发布企业平台J2EE\n * 1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生\n * 2004年，发布里程碑式版本：JDK1.5，为突出此版本的重要性，更名为JDK 5.0\n * 2005年，J2SE -> JavaSE，J2EE -> JavaEE，J2ME -> JavaME\n * 2009年，Oracle公司收购SUN，交易价格74亿美元\n * 2011年，发布JDK 7.0\n * 2014年，发布JDK8.0，是继JDK 5.0以来变化最大的版本\n * 2017年，发布JDK 9.0，最大限度实现模块化\n * 2018年3月，发布JDK 10.0，版本号也称为18.3\n * 2018年9月，发布JDK 11.0，版本号也称为18.9\n * 2019年3月，发布JDK 12.0，Java 12是短期支持版本，可在下一个版本发布之前获得Oracle的商业支持。\n * 2019年9月，发布JDK 13.0 ，此版本中添加了“文本块”。\n\n\n# Java技术体系平台\n\nJava SE(Java Standard Edition)标准版：\n\n> 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE\n\nJava EE(Java Enterprise Edition)企业版：\n\n> 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE\n\nJava ME(Java Micro Edition)小型版：\n\n> 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME\n\nJava Card：\n\n> 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台\n\n\n# Java在各领域的应用\n\n从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面：\n\n * 企业级应用： 主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。\n * Android平台应用： Android应用程序使用Java语言编写。Android开发水平的高低很大程度上取决于Java语言核心能力是否扎实。\n * 大数据平台开发： 各类框架有Hadoop，spark，storm，flink等，就这类技术生态圈来讲，还有各种中间件如flume，kafka，sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java，scala，Python，R等各种语言API供编程。\n * 移动领域应用： 主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。\n\n\n# Java语言的诞生\n\njava之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。\n\n\n\nJava确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。\n\n但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言面向对象技术的核心。Java 舍弃了C语言中容易引起错误的指针 （以引用取代）、运算符重载（operatoroverloading）、多重继承（以接口取代）等特性， 增加了垃圾回收器功能 用于回收不再被引用的对象所占据的内存空间。\n\nJDK1.5又引入了泛型编程（Generic Programming）、类型安全的枚举、不定长参数和自动装/拆箱。\n\n\n# 主要特性\n\n * Java语言是易学的。 Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。\n * Java语言是强制面向对象的。 Java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。\n * Java语言是分布式的。 Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。\n * Java语言是健壮的。 Java的强类型机制、异常处理、垃圾的自动收集等是- Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。\n * Java语言是安全的。 Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查。\n * Java语言是体系结构中立的。 Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。\n * Java语言是解释型的。 如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统的解释器中运行。\n * Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。\n * Java语言是原生支持多线程的。 在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。\n\n\n# Java语言的特点\n\n特点一：面向对象\n\n * 两个基本概念： 类、对象\n * 三大特性： 封装、继承、多态\n\n特点二：健壮性\n\n * 吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。\n\n特点三：跨平台性\n\n * 跨平台性： 通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”\n * 原理： 只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。\n\n\n# 跨平台性\n\n因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。\n\n\n\n\n# 垃圾回收\n\n不再使用的内存空间应回收—— 垃圾回收。在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空 间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。\n\n垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。Java程序还是会出现内存泄漏和内存溢出的问题。\n\n\n# JDK、JRE、JVM\n\nJDK(Java Development Kit Java开发工具包)： JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等\n\nJRE(Java Runtime Environment Java运行环境)：\n\n包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\n\n\n\n> JDK = JRE + 开发工具集（例如Javac编译工具等）\n> \n> JRE = JVM + Java SE标准类库\n\n\n\n\n# Java虚拟机 (Java Virtal Machine)\n\nJVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n\n对于不同的平台，有不同的虚拟机。只有某平台提供了对应的java虚拟机，java程序才可在此平台运行。Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。\n\n\n\n# Java虚拟机的内存划分\n\n为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。\n\n区域名称    作用\n寄存器     给CPU使用，和开发无关。\n本地方法栈   JVM在使用操作系统功能的时候使用，和开发无关。\n方法区     存储可以运行的class文件。\n堆内存     存储对象或者数组，new来创建的，都存储在堆内存。\n方法栈     方法运行时使用的内存，比如main方法运行，进入方法栈中执行。\n\n\n# 环境搭建\n\n\n# 下载、安装\n\n安装路径不要有中文或者空格等特殊符号。如果操作系统是64位的，软件尽量选择支持64位的（除非软件本身不区分）。当提示安装 JRE 时，正常在JDK安装时已经装过了，但是为了后续使用Eclipse等开发工具不报错，建议也根据提示安装JRE。\n\n\n# 配置环境变量\n\n在dos命令行中敲入javac，出现错误提示，是因为当前执行的程序在当前目录下如果不存在，windows系统会在系统中已有的一个名为path的环境变量指定的目录中查找。如果仍未找到，会出现以上的错误提示。所以进入到 jdk安装路径\\bin目录下，执行javac，会看到javac参数提示信息。\n\n每次执行 java 的工具都要进入到bin目录下，是非常麻烦的。根据windows系统在查找可执行程序的原理，可以将java工具所在路径定义到 path 环境变量中，让系统帮我们去找运行执行的程序。\n\n\n\n配置方法：\n\n 1. 我的电脑--属性--高级系统设置--环境变量\n 2. 编辑 path 环境变量，在变量值开始处加上java工具所在目录，后面用“ ; ”和其他值分隔开即可。\n 3. 打开DOS命令行，任意目录下敲入javac。如果出现javac 的参数信息，配置成功。\n\n# 配置一\n\n * 变量名：JAVA_HOME\n * 变量值：C:\\Program Files (x86)\\Java\\jdk1.8.0_91\n * 要根据自己的实际路径配置\n\n# 配置二\n\n * 变量名：Path\n * 变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n# 检测\n\n 1. 运行cmd\n 2. 分别输入：java、javac、java -version，如果出现对应信息，表示配置成功。",normalizedContent:"# java语言概述\n\njava是sun(stanford university network，斯坦福大学网络公司) 1995年推出的一门高级编程语言。\n\n是一种面向internet的编程语言。java一开始富有吸引力是因为java程序可以在web浏览器中运行。这些java程序被称为java小程序（applet）。applet使用现代的图形用户界面与web用户进行交互。 applet内嵌在html代码中。\n\n随着java技术在web方面的不断成熟，已经成为web应用程序的首选开发语言。\n\n后台开发：java、php、python、go、node.js\n\n\n# java简史\n\n * 1991年 green项目，开发语言最初命名为oak (橡树)\n * 1994年，开发组意识到oak 非常适合于互联网\n * 1996年，发布jdk1.0，约8.3万个网页应用java技术来制作\n * 1997年，发布jdk 1.1，javaone会议召开，创当时全球同类会议规模之最\n * 1998年，发布jdk 1.2，同年发布企业平台j2ee\n * 1999年，java分成j2se、j2ee和j2me，jsp/servlet技术诞生\n * 2004年，发布里程碑式版本：jdk1.5，为突出此版本的重要性，更名为jdk 5.0\n * 2005年，j2se -> javase，j2ee -> javaee，j2me -> javame\n * 2009年，oracle公司收购sun，交易价格74亿美元\n * 2011年，发布jdk 7.0\n * 2014年，发布jdk8.0，是继jdk 5.0以来变化最大的版本\n * 2017年，发布jdk 9.0，最大限度实现模块化\n * 2018年3月，发布jdk 10.0，版本号也称为18.3\n * 2018年9月，发布jdk 11.0，版本号也称为18.9\n * 2019年3月，发布jdk 12.0，java 12是短期支持版本，可在下一个版本发布之前获得oracle的商业支持。\n * 2019年9月，发布jdk 13.0 ，此版本中添加了“文本块”。\n\n\n# java技术体系平台\n\njava se(java standard edition)标准版：\n\n> 支持面向桌面级应用（如windows下的应用程序）的java平台，提供了完整的java核心api，此版本以前称为j2se\n\njava ee(java enterprise edition)企业版：\n\n> 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:servlet、jsp等，主要针对于web应用程序开发。版本以前称为j2ee\n\njava me(java micro edition)小型版：\n\n> 支持java程序运行在移动终端（手机、pda）上的平台，对java api有所精简，并加入了针对移动终端的支持，此版本以前称为j2me\n\njava card：\n\n> 支持一些java小程序（applets）运行在小内存设备（如智能卡）上的平台\n\n\n# java在各领域的应用\n\n从java的应用领域来分，java语言的应用方向主要表现在以下几个方面：\n\n * 企业级应用： 主要指复杂的大企业的软件系统、各种类型的网站。java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。\n * android平台应用： android应用程序使用java语言编写。android开发水平的高低很大程度上取决于java语言核心能力是否扎实。\n * 大数据平台开发： 各类框架有hadoop，spark，storm，flink等，就这类技术生态圈来讲，还有各种中间件如flume，kafka，sqoop等等 ，这些框架以及工具大多数是用java编写而成，但提供诸如java，scala，python，r等各种语言api供编程。\n * 移动领域应用： 主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、pda、机顶盒、汽车通信设备等。\n\n\n# java语言的诞生\n\njava之父james gosling团队在开发”green”项目时，发现c缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。\n\n\n\njava确实是从c语言和c++语言继承了许多成份，甚至可以将java看成是类c语言发展和衍生的产物。比如java语言的变量声明，操作符形式，参数传递，流程控制等方面和c语言、c++语言完全相同。\n\n但同时，java是一个纯粹的面向对象的程序设计语言，它继承了c++语言面向对象技术的核心。java 舍弃了c语言中容易引起错误的指针 （以引用取代）、运算符重载（operatoroverloading）、多重继承（以接口取代）等特性， 增加了垃圾回收器功能 用于回收不再被引用的对象所占据的内存空间。\n\njdk1.5又引入了泛型编程（generic programming）、类型安全的枚举、不定长参数和自动装/拆箱。\n\n\n# 主要特性\n\n * java语言是易学的。 java语言的语法与c语言和c++语言很接近，使得大多数程序员很容易学习和使用java。\n * java语言是强制面向对象的。 java语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。\n * java语言是分布式的。 java语言支持internet应用的开发，在基本的java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括url、urlconnection、socket、serversocket等。java的rmi（远程方法激活）机制也是开发分布式应用的重要手段。\n * java语言是健壮的。 java的强类型机制、异常处理、垃圾的自动收集等是- java程序健壮性的重要保证。对指针的丢弃是java的明智选择。\n * java语言是安全的。 java通常被用在网络环境中，为此，java提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类classloader），如分配不同的名字空间以防替代本地的同名类、字节代码检查。\n * java语言是体系结构中立的。 java程序（后缀为java的文件）在java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个java平台的任何系统中运行。\n * java语言是解释型的。 如前所述，java程序在java平台上被编译为字节码格式，然后可以在实现这个java平台的任何系统的解释器中运行。\n * java是性能略高的。与那些解释型的高级脚本语言相比，java的性能还是较优的。\n * java语言是原生支持多线程的。 在java语言中，线程是一种特殊的对象，它必须由thread类或其子（孙）类来创建。\n\n\n# java语言的特点\n\n特点一：面向对象\n\n * 两个基本概念： 类、对象\n * 三大特性： 封装、继承、多态\n\n特点二：健壮性\n\n * 吸收了c/c++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。\n\n特点三：跨平台性\n\n * 跨平台性： 通过java语言编写的应用程序在不同的系统平台上都可以运行。“write once , run anywhere”\n * 原理： 只要在需要运行 java 应用程序的操作系统上，先安装一个java虚拟机 (jvm java virtual machine)即可。由jvm来负责java程序在该系统中的运行。\n\n\n# 跨平台性\n\n因为有了jvm，同一个java 程序在三个不同的操作系统中都可以执行。这样就实现了java 程序的跨平台性。\n\n\n\n\n# 垃圾回收\n\n不再使用的内存空间应回收—— 垃圾回收。在c/c++等语言中，由程序员负责回收无用内存。java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空 间的分配情况。并在jvm空闲时，检查并释放那些可被释放的存储空间。\n\n垃圾回收在java程序运行过程中自动进行，程序员无法精确控制和干预。java程序还是会出现内存泄漏和内存溢出的问题。\n\n\n# jdk、jre、jvm\n\njdk(java development kit java开发工具包)： jdk是提供给java开发人员使用的，其中包含了java的开发工具，也包括了jre。所以安装了jdk，就不用在单独安装jre了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等\n\njre(java runtime environment java运行环境)：\n\n包括java虚拟机(jvm java virtual machine)和java程序所需的核心类库等，如果想要运行一个开发好的java程序，计算机中只需要安装jre即可。\n\n\n\n> jdk = jre + 开发工具集（例如javac编译工具等）\n> \n> jre = jvm + java se标准类库\n\n\n\n\n# java虚拟机 (java virtal machine)\n\njvm是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。\n\n对于不同的平台，有不同的虚拟机。只有某平台提供了对应的java虚拟机，java程序才可在此平台运行。java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。\n\n\n\n# java虚拟机的内存划分\n\n为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。\n\n区域名称    作用\n寄存器     给cpu使用，和开发无关。\n本地方法栈   jvm在使用操作系统功能的时候使用，和开发无关。\n方法区     存储可以运行的class文件。\n堆内存     存储对象或者数组，new来创建的，都存储在堆内存。\n方法栈     方法运行时使用的内存，比如main方法运行，进入方法栈中执行。\n\n\n# 环境搭建\n\n\n# 下载、安装\n\n安装路径不要有中文或者空格等特殊符号。如果操作系统是64位的，软件尽量选择支持64位的（除非软件本身不区分）。当提示安装 jre 时，正常在jdk安装时已经装过了，但是为了后续使用eclipse等开发工具不报错，建议也根据提示安装jre。\n\n\n# 配置环境变量\n\n在dos命令行中敲入javac，出现错误提示，是因为当前执行的程序在当前目录下如果不存在，windows系统会在系统中已有的一个名为path的环境变量指定的目录中查找。如果仍未找到，会出现以上的错误提示。所以进入到 jdk安装路径\\bin目录下，执行javac，会看到javac参数提示信息。\n\n每次执行 java 的工具都要进入到bin目录下，是非常麻烦的。根据windows系统在查找可执行程序的原理，可以将java工具所在路径定义到 path 环境变量中，让系统帮我们去找运行执行的程序。\n\n\n\n配置方法：\n\n 1. 我的电脑--属性--高级系统设置--环境变量\n 2. 编辑 path 环境变量，在变量值开始处加上java工具所在目录，后面用“ ; ”和其他值分隔开即可。\n 3. 打开dos命令行，任意目录下敲入javac。如果出现javac 的参数信息，配置成功。\n\n# 配置一\n\n * 变量名：java_home\n * 变量值：c:\\program files (x86)\\java\\jdk1.8.0_91\n * 要根据自己的实际路径配置\n\n# 配置二\n\n * 变量名：path\n * 变量值：%java_home%\\bin;%java_home%\\jre\\bin;\n\n# 检测\n\n 1. 运行cmd\n 2. 分别输入：java、javac、java -version，如果出现对应信息，表示配置成功。",charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"SpringCloud Zookeeper",frontmatter:{title:"SpringCloud Zookeeper",permalink:"/pages/09kei4a8/",date:"2022-12-14T11:33:04.000Z",categories:["Spring生态"],tags:["SpringCloud"],author:{name:"乔木先生"}},regularPath:"/02.Java%E6%A1%86%E6%9E%B6/01.SpringCloud/02.SpringCloud%20Zookeeper.html",relativePath:"02.Java框架/01.SpringCloud/02.SpringCloud Zookeeper.md",key:"v-14111292",path:"/pages/09kei4a8/",headers:[{level:2,title:"快速安装",slug:"快速安装",normalizedTitle:"快速安装",charIndex:71},{level:2,title:"服务提供者",slug:"服务提供者",normalizedTitle:"服务提供者",charIndex:624},{level:2,title:"服务消费者",slug:"服务消费者",normalizedTitle:"服务消费者",charIndex:2214}],headersStr:"快速安装 服务提供者 服务消费者",content:'Zookeeper是一个分布式协调工具，可以实现注册中心功能。使用Zookeeper服务器取代Eureka服务器，作为服务注册中心。\n\n\n# 快速安装\n\n安装Docker\n\ncurl -sSL https://get.daocloud.io/docker | sh\nsystemctl enable --now docker\n\n\n拉取zookeeper的镜像，创建并启动容器\n\ndocker pull zookeeper:3.4.9\ndocker run -d -e TZ="Asia/Shanghai" -p 2181:2181 -v /home/data/zookeeper:/data --name zookeeper --restart always zookeeper:3.4.9\n\n\n关闭Linux服务器防火墙\n\nsystemctl stop firewalld\n\n\n查看防火墙状态\n\nsystemctl status firewalld\n\n\n进入Zookeeper容器\n\n# 第一种方式：直接进入到zkCli中\ndocker run -it --rm --link zookeeper:zookeeper zookeeper zkCli.sh -server zookeeper\n\n# 第二种方式：先进入容器，再进入到zkCli中\ndocker exec -it zookeeper bash\n./bin/zkCli.sh\n\n\n\n# 服务提供者\n\n新建一个maven工程，添加相关依赖，版本号是3.4.9\n\n\x3c!-- SpringBoot整合zookeeper客户端 --\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    \x3c!-- 会包含3.5.3-bata的jar包，如下图，所以需要排除掉，并设置自己版本的依赖 --\x3e\n    <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n    \x3c!--先排除自带的zookeeper3.5.3--\x3e\n    <exclusions>\n        <exclusion>\n            <groupId>org.apache.zookeeper</groupId>\n            <artifactId>zookeeper</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\x3c!--添加zookeeper3.4.9版本--\x3e\n<dependency>\n    <groupId>org.apache.zookeeper</groupId>\n    <artifactId>zookeeper</artifactId>\n    <version>3.4.9</version>\n</dependency>\n\n\n\n\n配置yml文件：\n\n#8004表示注册到zookeeper服务器的支付服务提供者端口号\nserver:\n  port: 8004\n#服务别名----注册zookeeper到注册中心名称\nspring:\n  application:\n    name: cloud-provider-payment\n  cloud:\n    zookeeper:\n      # zookeeper的ip+端口\n      connect-string: 192.168.182.130:2181\n\n\n主启动类：\n\n@SpringBootApplication\n@EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\npublic class PaymentMain8004 {\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentMain8004.class, args);\n    }\n}\n\n\nController，随便写一个接口，以检查是否注册进Zookeeper服务：\n\n@RestController\npublic class PaymentController {\n    @Value("${server.port}")\n    private String serverPort;\n\n    @RequestMapping(value = "/payment/zk")\n    public String paymentzk() {\n        return "springcloud with zookeeper: " + serverPort + "\\t" + UUID.randomUUID();\n    }\n}\n\n\n启动项目后，进入Zookeeper客户端，可以看到：\n\n\n\n调用接口：成功\n\n\n\n服务节点是临时节点还是持久节点？\n\n> 在服务运行的时候，把服务停掉，可以明确的看到Zookeeper会将停掉的节点给清除掉，所以服务节点是临时节点。重启后，得到的流水号也是不一样的。\n\n\n# 服务消费者\n\n创建一个Maven工程，pom文件和上面的服务提供者一样，\n\n配置yml文件：\n\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-consumer-order\n  cloud:\n  #注册到zookeeper地址\n    zookeeper:\n      connect-string: 192.168.182.130:2181\n\n\n主启动类加上@EnableDiscoveryClient 注解。\n\n将RestTemplate加入到容器。\n\n@Bean\n@LoadBalanced\npublic RestTemplate getRestTemplate() {\n    return new RestTemplate();\n}\n\n\n使用RestTemplate调用服务提供者的接口：\n\n@RestController\npublic class OrderZKController {\n    public static final String INVOKE_URL = "http://cloud-provider-payment";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(value = "/consumer/payment/zk")\n    public String paymentInfo() {\n        return restTemplate.getForObject(INVOKE_URL + "/payment/zk", String.class);\n    }\n}\n\n\n启动项目，服务消费者也注册进了Zookeeper中，并且调用服务消费者的接口成功：\n\n\n\n',normalizedContent:'zookeeper是一个分布式协调工具，可以实现注册中心功能。使用zookeeper服务器取代eureka服务器，作为服务注册中心。\n\n\n# 快速安装\n\n安装docker\n\ncurl -ssl https://get.daocloud.io/docker | sh\nsystemctl enable --now docker\n\n\n拉取zookeeper的镜像，创建并启动容器\n\ndocker pull zookeeper:3.4.9\ndocker run -d -e tz="asia/shanghai" -p 2181:2181 -v /home/data/zookeeper:/data --name zookeeper --restart always zookeeper:3.4.9\n\n\n关闭linux服务器防火墙\n\nsystemctl stop firewalld\n\n\n查看防火墙状态\n\nsystemctl status firewalld\n\n\n进入zookeeper容器\n\n# 第一种方式：直接进入到zkcli中\ndocker run -it --rm --link zookeeper:zookeeper zookeeper zkcli.sh -server zookeeper\n\n# 第二种方式：先进入容器，再进入到zkcli中\ndocker exec -it zookeeper bash\n./bin/zkcli.sh\n\n\n\n# 服务提供者\n\n新建一个maven工程，添加相关依赖，版本号是3.4.9\n\n\x3c!-- springboot整合zookeeper客户端 --\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    \x3c!-- 会包含3.5.3-bata的jar包，如下图，所以需要排除掉，并设置自己版本的依赖 --\x3e\n    <artifactid>spring-cloud-starter-zookeeper-discovery</artifactid>\n    \x3c!--先排除自带的zookeeper3.5.3--\x3e\n    <exclusions>\n        <exclusion>\n            <groupid>org.apache.zookeeper</groupid>\n            <artifactid>zookeeper</artifactid>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n\x3c!--添加zookeeper3.4.9版本--\x3e\n<dependency>\n    <groupid>org.apache.zookeeper</groupid>\n    <artifactid>zookeeper</artifactid>\n    <version>3.4.9</version>\n</dependency>\n\n\n\n\n配置yml文件：\n\n#8004表示注册到zookeeper服务器的支付服务提供者端口号\nserver:\n  port: 8004\n#服务别名----注册zookeeper到注册中心名称\nspring:\n  application:\n    name: cloud-provider-payment\n  cloud:\n    zookeeper:\n      # zookeeper的ip+端口\n      connect-string: 192.168.182.130:2181\n\n\n主启动类：\n\n@springbootapplication\n@enablediscoveryclient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\npublic class paymentmain8004 {\n    public static void main(string[] args) {\n        springapplication.run(paymentmain8004.class, args);\n    }\n}\n\n\ncontroller，随便写一个接口，以检查是否注册进zookeeper服务：\n\n@restcontroller\npublic class paymentcontroller {\n    @value("${server.port}")\n    private string serverport;\n\n    @requestmapping(value = "/payment/zk")\n    public string paymentzk() {\n        return "springcloud with zookeeper: " + serverport + "\\t" + uuid.randomuuid();\n    }\n}\n\n\n启动项目后，进入zookeeper客户端，可以看到：\n\n\n\n调用接口：成功\n\n\n\n服务节点是临时节点还是持久节点？\n\n> 在服务运行的时候，把服务停掉，可以明确的看到zookeeper会将停掉的节点给清除掉，所以服务节点是临时节点。重启后，得到的流水号也是不一样的。\n\n\n# 服务消费者\n\n创建一个maven工程，pom文件和上面的服务提供者一样，\n\n配置yml文件：\n\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-consumer-order\n  cloud:\n  #注册到zookeeper地址\n    zookeeper:\n      connect-string: 192.168.182.130:2181\n\n\n主启动类加上@enablediscoveryclient 注解。\n\n将resttemplate加入到容器。\n\n@bean\n@loadbalanced\npublic resttemplate getresttemplate() {\n    return new resttemplate();\n}\n\n\n使用resttemplate调用服务提供者的接口：\n\n@restcontroller\npublic class orderzkcontroller {\n    public static final string invoke_url = "http://cloud-provider-payment";\n\n    @resource\n    private resttemplate resttemplate;\n\n    @getmapping(value = "/consumer/payment/zk")\n    public string paymentinfo() {\n        return resttemplate.getforobject(invoke_url + "/payment/zk", string.class);\n    }\n}\n\n\n启动项目，服务消费者也注册进了zookeeper中，并且调用服务消费者的接口成功：\n\n\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"SpringCloud Eureka",frontmatter:{title:"SpringCloud Eureka",date:"2022-12-13T20:40:38.000Z",permalink:"/pages/24j4ehty/",categories:["Spring生态"],tags:["SpringCloud"],author:{name:"乔木先生"}},regularPath:"/02.Java%E6%A1%86%E6%9E%B6/01.SpringCloud/01.SpringCloud%20Eureka.html",relativePath:"02.Java框架/01.SpringCloud/01.SpringCloud Eureka.md",key:"v-20278ad4",path:"/pages/24j4ehty/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:3,title:"服务治理",slug:"服务治理",normalizedTitle:"服务治理",charIndex:9},{level:3,title:"Eureka概述",slug:"eureka概述",normalizedTitle:"eureka概述",charIndex:163},{level:2,title:"基本原理",slug:"基本原理",normalizedTitle:"基本原理",charIndex:298},{level:3,title:"服务注册与发现",slug:"服务注册与发现",normalizedTitle:"服务注册与发现",charIndex:492},{level:3,title:"Eureka Server提供服务注册服务",slug:"eureka-server提供服务注册服务",normalizedTitle:"eureka server提供服务注册服务",charIndex:908},{level:3,title:"EurekaClient通过注册中心进行访问",slug:"eurekaclient通过注册中心进行访问",normalizedTitle:"eurekaclient通过注册中心进行访问",charIndex:1027},{level:2,title:"Eureka单机",slug:"eureka单机",normalizedTitle:"eureka单机",charIndex:1358},{level:3,title:"EurekaServer搭建",slug:"eurekaserver搭建",normalizedTitle:"eurekaserver搭建",charIndex:1371},{level:3,title:"EurekaCilent搭建",slug:"eurekacilent搭建",normalizedTitle:"eurekacilent搭建",charIndex:2417},{level:2,title:"Eureka集群",slug:"eureka集群",normalizedTitle:"eureka集群",charIndex:3300},{level:3,title:"EurekaServer集群",slug:"eurekaserver集群",normalizedTitle:"eurekaserver集群",charIndex:3546},{level:3,title:"EurekaCilent注册进Server集群",slug:"eurekacilent注册进server集群",normalizedTitle:"eurekacilent注册进server集群",charIndex:4927},{level:3,title:"EurekaCilent集群",slug:"eurekacilent集群",normalizedTitle:"eurekacilent集群",charIndex:5732},{level:3,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:139},{level:2,title:"信息完善",slug:"信息完善",normalizedTitle:"信息完善",charIndex:7333},{level:3,title:"修改服务名",slug:"修改服务名",normalizedTitle:"修改服务名",charIndex:7342},{level:3,title:"IP信息显示",slug:"ip信息显示",normalizedTitle:"ip信息显示",charIndex:8160},{level:2,title:"服务发现Discovery",slug:"服务发现discovery",normalizedTitle:"服务发现discovery",charIndex:8459},{level:2,title:"自我保护",slug:"自我保护",normalizedTitle:"自我保护",charIndex:1292},{level:3,title:"禁止自我保护",slug:"禁止自我保护",normalizedTitle:"禁止自我保护",charIndex:10392},{level:4,title:"服务端配置",slug:"服务端配置",normalizedTitle:"服务端配置",charIndex:10402},{level:4,title:"客户端配置",slug:"客户端配置",normalizedTitle:"客户端配置",charIndex:10837}],headersStr:"简介 服务治理 Eureka概述 基本原理 服务注册与发现 Eureka Server提供服务注册服务 EurekaClient通过注册中心进行访问 Eureka单机 EurekaServer搭建 EurekaCilent搭建 Eureka集群 EurekaServer集群 EurekaCilent注册进Server集群 EurekaCilent集群 负载均衡 信息完善 修改服务名 IP信息显示 服务发现Discovery 自我保护 禁止自我保护 服务端配置 客户端配置",content:'# 简介\n\n\n# 服务治理\n\nSpring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理，在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。\n\n\n# Eureka概述\n\nEureka是基于REST（Representational State Transfer）服务，主要以AWS云服务为支撑，提供服务发现并实现负载均衡和故障转移。Eureka是一款由Netflix公司开发的服务注册组件，已经停止更新了。\n\n\n\n\n# 基本原理\n\nEureka采用C-S的设计架构，包含Eureka Server 和Eureka Client两个组件\n\n服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。\n\n\n# 服务注册与发现\n\nEureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到Eureka Server 并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。\n\n在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息(比如服务地址通讯地址等)以别名方式注册到注册中心上。另一方(消费者|服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架。\n\n> 核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))\n\n\n\n> Eureka包含两个组件：Eureka Server和Eureka Client\n\n\n# Eureka Server提供服务注册服务\n\n各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n\n\n# EurekaClient通过注册中心进行访问\n\n是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）。\n\n但是会存在当网络分区发生故障，导致该时间内没有心跳连接，但该服务本身还是健康运行的情况。Eureka通过“自我保护模式”来解决这个问题。在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。\n\n\n# Eureka单机\n\n\n# EurekaServer搭建\n\n创建一个maven模块，添加依赖\n\n\x3c!-- eureka-server --\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n\n\x3c!-- cloud2018以前的版本 --\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-eureka</artifactId>\n</dependency>\n\n\n配置application.yml文件\n\n# 端口号\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: localhost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n                          #     指向 localhost           指向  7001\n\n\n编写主方法\n\n@SpringBootApplication\n@EnableEurekaServer // 表示这个项目是服务注册中心\npublic class EurekaMain {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaMain.class, args);\n    }\n}\n\n\n启动该项目，显示该页面表示服务注册中心启动成功\n\n\n\n\n# EurekaCilent搭建\n\n添加依赖\n\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n\n\x3c!-- cloud2018以前的版本 --\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-eureka</artifactId>\n</dependency>\n\n\n在启动类上加入该注解\n\n// 表示这个项目入驻Eureka\n@EnableEurekaClient \n\n\n在application.yml文件中配置Eureka\n\n# 端口号\nserver:\n  port: 8001\n\n# 服务名\nspring:\n  application:\n    # 这里的名字就是注册进Eureka的服务名\n    name: cloud-payment-service \n\neureka:\n  client:\n    # 表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    # 是否从EurekaServer抓取已有的注册信息，默认为true。\n    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      defaultZone: http://localhost:7001/eureka\n                #   指向服务注册中心的url\n\n\n启动项目，需要先启动eureka的服务端，进入服务端的服务注册中心页面，看到Client端的服务名表示注册成功\n\n\n\n\n# Eureka集群\n\nEureka是SpringCloud应用中的注册中心，用来提供服务注册与发现功能。在实际生产活动中，如果单机部署的Eureka服务发生宕机，虽然已注册到Eureka的微服务可以被其客户端记录并保留，但无法再提供故障节点的剔除与新服务节点的发现功能。\n\nEureka集群则可以创建多个Eureka应用，互相之间同步客户端注册信息，又可以独立提供服务发现与注册服务。\n\n其实Eureka本身就是为集群部署而设计的，所以部署Eureka集群需要修改的配置项并不多。\n\n\n\n\n# EurekaServer集群\n\n> 互相注册，相互守望\n\n在学习阶段集群是部署在同一台电脑上的，eureka服务端的实例名称会是一样的，需要修改一下系统的映射配置。在C:\\Windows\\System32\\drivers\\etc文件夹下找到hosts文件。\n\n\n\n将自己的集群信息进行配置进去\n\n\n\n修改原来的application.yml文件，将其变更为集群的环境\n\n# 端口号\nserver:\n  port: 7001\n\neureka:\n  instance:\n    # eureka服务端的实例名称\n    hostname: eureka7001.com \n  client:\n    # false表示不向注册中心注册自己。\n    register-with-eureka: false\n    # false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://eureka7002.com:7002/eureka/\n                      # 指向7002的服务中心\n\n\n新建一个模块，pom.xml和主启动类不变。application.yml配置为7002的服务中心\n\n# 端口号\nserver:\n  port: 7002\n\neureka:\n  instance:\n    # eureka服务端的实例名称\n    hostname: eureka7002.com \n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultZone: http://eureka7001.com:7002/eureka/\n                          # 指向7001服务中心\n\n\n> 到目前为止就创建了两个eureka服务端，在service-url中，7001和7002相互指向。\n\n启动两个服务，访问\n\n\n\n\n\n当7001和7002服务互相指向的时候，说明集群搭建成功\n\n> 相互注册，如果还有一台eureka服务端(7003)，则在配置yml文件的时候需要将7001指向7002和7003\n\neureka:\n  client:\n    register-with-eureka: true\n    fetchRegistry: true\n    service-url:\n      # 集群\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n\n\n# EurekaCilent注册进Server集群\n\n将服务注册中心的url配置为集群的url即可\n\n# defaultZone: http://localhost:7001/eureka  # 单机版\ndefaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n下面是完整的yml文件\n\n# 端口号\nserver:\n  port: 8001\n\n# 服务名\nspring:\n  application:\n    # 这里的名字就是注册进Eureka的服务名\n    name: cloud-payment-service \n\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。\n    #单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n#      defaultZone: http://localhost:7001/eureka  # 单机版\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n                #   指向服务注册中心的url\n\n\n将四个微服务启动，要先启动Server集群，后启动Client服务\n\n\n\n调用接口测试，一般即启动成功\n\n\n\n此时，服务中心有两个，服务提供者确只有一个，下面搭建服务提供者的集群\n\n\n# EurekaCilent集群\n\n创建一个端口号为8002的服务提供模块：\n\nserver:\n  port: 8002\n\nspring:\n  application:\n    name: cloud-payment-service\n\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchRegistry: true\n    service-url:\n      #defaultZone: http://localhost:7001/eureka\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n按顺序打开所有服务，此时已经注册了三个服务\n\n\n\n\n# 负载均衡\n\n> 现在的系统逻辑是：order服务使用RestTemplate调用payment服务，但现在payment有两台机器，之前的写法是ip+端口号写死的，现在则需要负载均衡到两台机器上。\n\n    @GetMapping("/consumer/payment/get/{id}")\n    public CommonResult<Payment> getPayment(@PathVariable("id") Long id) {\n        return restTemplate.getForObject("http://localhost:8001/payment/get/" + id, CommonResult.class);\n    }\n\n\n现在服务提供者有两台机器，可以让RestTemplate去选择调用哪一个，可以将调用变更为：\n\nprivate static final String PAYMENT_URL = "http://CLOUD-PAYMENT-SERVICE";\n\n@GetMapping("/consumer/payment/get/{id}")\npublic CommonResult<Payment> getPayment(@PathVariable("id") Long id) {\n    return restTemplate.getForObject(PAYMENT_URL + "/payment/get/" + id, CommonResult.class);\n}\n\n\nurl和服务名是相互对应的\n\n\n\n因为一个服务名下有多个服务，修改好之后，重启，此时RestTemplate并不知道到底要调用哪一个，就会报错：\n\n\n\n**给RestTemplate赋予负载均衡的能力，**在声明RestTemplate的配置类中，加入@LoadBalanced注解\n\n@Configuration\npublic class ApplicationContextConfig {\n    @Bean\n    @LoadBalanced   // 赋予RestTemplate负载均衡的能力\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n}\n\n\n再次重启后就可以通过服务名称直接调用服务，多次调用该接口，会发现是交替(轮询)的切换两个服务提供者，此时Consumer可以直接调用服务而不再关心地址和端口号，并且该服务还具备了负载均衡的功能\n\n\n\n\n# 信息完善\n\n\n# 修改服务名\n\n在Eureka中，机器的名字默认显示的是主机名:服务名:端口号 ，对于服务的机器辨识会比较模糊，如果是使用“1号机”、“5号机”等类似的名称可能更直观，如果有此方面的需求，可以进行修改服务名称。\n\n\n\n需要引入以下两个依赖：\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n\n\n下面是修改后的yml文件：\n\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n\neureka:\n  client:\n    #表示是否将自己注册进EurekaServer默认为true。\n    register-with-eureka: true\n    #是否从EurekaServer抓取已有的注册信息，默认为true。\n    fetchRegistry: true\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n      # 设置eureka服务注册中心中的主机名称\n      instance-id: payment8001\n\n\n修改过后的样子：\n\n\n\n\n# IP信息显示\n\n在yml文件中修改配置：\n\neureka:\n  client:\n    register-with-eureka: true\n    fetchRegistry: true\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n      instance-id: payment8001\n      #访问路径可以显示IP地址\n      prefer-ip-address: true\n\n\n\n\n\n# 服务发现Discovery\n\n对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息\n\n开启服务发现@EnableDiscoveryClient：\n\n@SpringBootApplication\n@EnableEurekaClient\n@EnableDiscoveryClient    // 开启服务发现\npublic class PaymentMain8001 {\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentMain8001.class, args);\n    }\n}\n\n\n修改Eureku中的客户端Controller：\n\n@Resource\nprivate DiscoveryClient discoveryClient;\n\n@GetMapping("/payment/discovery")\npublic Object discovery() {\n    // 获得服务清单列表\n    List<String> services = discoveryClient.getServices();\n    for (String service : services) {\n        log.info("service：{}", service);\n    }\n    // 一个微服务名称下面的所有实例\n    List<ServiceInstance> instances = discoveryClient.getInstances("CLOUD-PAYMENT-SERVICE");\n    for (ServiceInstance instance : instances) {\n        log.info("{}\\t{}\\t{}\\t{}", instance.getInstanceId(), instance.getHost(), \n            instance.getPort(), instance.getUri());\n    }\n    return this.discoveryClient;\n}\n\n\n通过服务发现类DiscoveryClient的getServices()方法，可以获取到服务的清单列表\n\n\n\n通过getInstances("CLOUD-PAYMENT-SERVICE");方法可以得到该服务名下的所有实例的信息，该方法的传参就是服务名\n\n两个方法的调用和输出，看到如下信息：\n\n\n\n而web端打印的信息则是服务的列表，order表示的是当前服务的顺序\n\n\n\n\n# 自我保护\n\n> 某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。属于CAP里面的AP分支。\n\n保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n\n如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式：\n\n\n\n为什么会产生Eureka自我保护机制？\n\n> 为了防止EurekaClient可以正常运行，但是与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除。\n\n什么是自我保护模式？\n\n> 默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。\n\n\n\n在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。\n\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。\n\n\n# 禁止自我保护\n\n# 服务端配置\n\n在application.yml文件中加入配置\n\neureka:\n  instance:\n    hostname: eureka7001.com\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n      defaultZone: http://eureka7002.com:7002/eureka/\n# ####################禁止自我保护####################\n  server:\n    # 关闭自我保护机制，保证不可用服务被及时清除\n    enable-self-preservation: false\n    # 2000毫秒没有反应就清除\n    eviction-interval-timer-in-ms: 2000\n\n\n配置好后，就能在eureka的页面看到如下信息：\n\n\n\n# 客户端配置\n\n在application.yml配置文件中进行配置：\n\neureka:\n  client:\n    register-with-eureka: true\n    fetchRegistry: true\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n    instance-id: payment8001\n    prefer-ip-address: true\n    # ####################设置心跳时间####################\n    # Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n    lease-renewal-interval-in-seconds: 1\n    # Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n    lease-expiration-duration-in-seconds: 2\n\n\n配置成功后重启发现8001服务已经被注册进了eureka\n\n\n\n假设现在8001出现问题(关闭8001服务)，此时可以看到8001服务立刻被清除，不再进行自我保护机制\n\n',normalizedContent:'# 简介\n\n\n# 服务治理\n\nspring cloud 封装了 netflix 公司开发的 eureka 模块来实现服务治理，在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。\n\n\n# eureka概述\n\neureka是基于rest（representational state transfer）服务，主要以aws云服务为支撑，提供服务发现并实现负载均衡和故障转移。eureka是一款由netflix公司开发的服务注册组件，已经停止更新了。\n\n\n\n\n# 基本原理\n\neureka采用c-s的设计架构，包含eureka server 和eureka client两个组件\n\n服务启动后向eureka注册，eureka server会将注册信息向其他eureka server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。\n\n\n# 服务注册与发现\n\neureka server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 eureka的客户端连接到eureka server 并维持心跳连接。这样系统的维护人员就可以通过 eureka server 来监控系统中各个微服务是否正常运行。\n\n在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息(比如服务地址通讯地址等)以别名方式注册到注册中心上。另一方(消费者|服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地rpc调用rpc远程调用框架。\n\n> 核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))\n\n\n\n> eureka包含两个组件：eureka server和eureka client\n\n\n# eureka server提供服务注册服务\n\n各个微服务节点通过配置启动后，会在eurekaserver中进行注册，这样eurekaserver中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。\n\n\n# eurekaclient通过注册中心进行访问\n\n是一个java客户端，用于简化eureka server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向eureka server发送心跳(默认周期为30秒)。如果eureka server在多个心跳周期内没有接收到某个节点的心跳，eurekaserver将会从服务注册表中把这个服务节点移除（默认90秒）。\n\n但是会存在当网络分区发生故障，导致该时间内没有心跳连接，但该服务本身还是健康运行的情况。eureka通过“自我保护模式”来解决这个问题。在自我保护模式中，eureka server会保护服务注册表中的信息，不再注销任何服务实例。\n\n\n# eureka单机\n\n\n# eurekaserver搭建\n\n创建一个maven模块，添加依赖\n\n\x3c!-- eureka-server --\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-netflix-eureka-server</artifactid>\n</dependency>\n\n\x3c!-- cloud2018以前的版本 --\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-eureka</artifactid>\n</dependency>\n\n\n配置application.yml文件\n\n# 端口号\nserver:\n  port: 7001\n\neureka:\n  instance:\n    hostname: localhost #eureka服务端的实例名称\n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultzone: http://${eureka.instance.hostname}:${server.port}/eureka/\n                          #     指向 localhost           指向  7001\n\n\n编写主方法\n\n@springbootapplication\n@enableeurekaserver // 表示这个项目是服务注册中心\npublic class eurekamain {\n    public static void main(string[] args) {\n        springapplication.run(eurekamain.class, args);\n    }\n}\n\n\n启动该项目，显示该页面表示服务注册中心启动成功\n\n\n\n\n# eurekacilent搭建\n\n添加依赖\n\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n</dependency>\n\n\x3c!-- cloud2018以前的版本 --\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-eureka</artifactid>\n</dependency>\n\n\n在启动类上加入该注解\n\n// 表示这个项目入驻eureka\n@enableeurekaclient \n\n\n在application.yml文件中配置eureka\n\n# 端口号\nserver:\n  port: 8001\n\n# 服务名\nspring:\n  application:\n    # 这里的名字就是注册进eureka的服务名\n    name: cloud-payment-service \n\neureka:\n  client:\n    # 表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    # 是否从eurekaserver抓取已有的注册信息，默认为true。\n    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchregistry: true\n    service-url:\n      defaultzone: http://localhost:7001/eureka\n                #   指向服务注册中心的url\n\n\n启动项目，需要先启动eureka的服务端，进入服务端的服务注册中心页面，看到client端的服务名表示注册成功\n\n\n\n\n# eureka集群\n\neureka是springcloud应用中的注册中心，用来提供服务注册与发现功能。在实际生产活动中，如果单机部署的eureka服务发生宕机，虽然已注册到eureka的微服务可以被其客户端记录并保留，但无法再提供故障节点的剔除与新服务节点的发现功能。\n\neureka集群则可以创建多个eureka应用，互相之间同步客户端注册信息，又可以独立提供服务发现与注册服务。\n\n其实eureka本身就是为集群部署而设计的，所以部署eureka集群需要修改的配置项并不多。\n\n\n\n\n# eurekaserver集群\n\n> 互相注册，相互守望\n\n在学习阶段集群是部署在同一台电脑上的，eureka服务端的实例名称会是一样的，需要修改一下系统的映射配置。在c:\\windows\\system32\\drivers\\etc文件夹下找到hosts文件。\n\n\n\n将自己的集群信息进行配置进去\n\n\n\n修改原来的application.yml文件，将其变更为集群的环境\n\n# 端口号\nserver:\n  port: 7001\n\neureka:\n  instance:\n    # eureka服务端的实例名称\n    hostname: eureka7001.com \n  client:\n    # false表示不向注册中心注册自己。\n    register-with-eureka: false\n    # false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      # 设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultzone: http://eureka7002.com:7002/eureka/\n                      # 指向7002的服务中心\n\n\n新建一个模块，pom.xml和主启动类不变。application.yml配置为7002的服务中心\n\n# 端口号\nserver:\n  port: 7002\n\neureka:\n  instance:\n    # eureka服务端的实例名称\n    hostname: eureka7002.com \n  client:\n    #false表示不向注册中心注册自己。\n    register-with-eureka: false\n    #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务\n    fetch-registry: false\n    service-url:\n      #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址。\n      defaultzone: http://eureka7001.com:7002/eureka/\n                          # 指向7001服务中心\n\n\n> 到目前为止就创建了两个eureka服务端，在service-url中，7001和7002相互指向。\n\n启动两个服务，访问\n\n\n\n\n\n当7001和7002服务互相指向的时候，说明集群搭建成功\n\n> 相互注册，如果还有一台eureka服务端(7003)，则在配置yml文件的时候需要将7001指向7002和7003\n\neureka:\n  client:\n    register-with-eureka: true\n    fetchregistry: true\n    service-url:\n      # 集群\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n\n\n\n\n# eurekacilent注册进server集群\n\n将服务注册中心的url配置为集群的url即可\n\n# defaultzone: http://localhost:7001/eureka  # 单机版\ndefaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n下面是完整的yml文件\n\n# 端口号\nserver:\n  port: 8001\n\n# 服务名\nspring:\n  application:\n    # 这里的名字就是注册进eureka的服务名\n    name: cloud-payment-service \n\neureka:\n  client:\n    #表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从eurekaserver抓取已有的注册信息，默认为true。\n    #单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchregistry: true\n    service-url:\n#      defaultzone: http://localhost:7001/eureka  # 单机版\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n                #   指向服务注册中心的url\n\n\n将四个微服务启动，要先启动server集群，后启动client服务\n\n\n\n调用接口测试，一般即启动成功\n\n\n\n此时，服务中心有两个，服务提供者确只有一个，下面搭建服务提供者的集群\n\n\n# eurekacilent集群\n\n创建一个端口号为8002的服务提供模块：\n\nserver:\n  port: 8002\n\nspring:\n  application:\n    name: cloud-payment-service\n\neureka:\n  client:\n    #表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从eurekaserver抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡\n    fetchregistry: true\n    service-url:\n      #defaultzone: http://localhost:7001/eureka\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  # 集群版\n\n\n按顺序打开所有服务，此时已经注册了三个服务\n\n\n\n\n# 负载均衡\n\n> 现在的系统逻辑是：order服务使用resttemplate调用payment服务，但现在payment有两台机器，之前的写法是ip+端口号写死的，现在则需要负载均衡到两台机器上。\n\n    @getmapping("/consumer/payment/get/{id}")\n    public commonresult<payment> getpayment(@pathvariable("id") long id) {\n        return resttemplate.getforobject("http://localhost:8001/payment/get/" + id, commonresult.class);\n    }\n\n\n现在服务提供者有两台机器，可以让resttemplate去选择调用哪一个，可以将调用变更为：\n\nprivate static final string payment_url = "http://cloud-payment-service";\n\n@getmapping("/consumer/payment/get/{id}")\npublic commonresult<payment> getpayment(@pathvariable("id") long id) {\n    return resttemplate.getforobject(payment_url + "/payment/get/" + id, commonresult.class);\n}\n\n\nurl和服务名是相互对应的\n\n\n\n因为一个服务名下有多个服务，修改好之后，重启，此时resttemplate并不知道到底要调用哪一个，就会报错：\n\n\n\n**给resttemplate赋予负载均衡的能力，**在声明resttemplate的配置类中，加入@loadbalanced注解\n\n@configuration\npublic class applicationcontextconfig {\n    @bean\n    @loadbalanced   // 赋予resttemplate负载均衡的能力\n    public resttemplate getresttemplate() {\n        return new resttemplate();\n    }\n}\n\n\n再次重启后就可以通过服务名称直接调用服务，多次调用该接口，会发现是交替(轮询)的切换两个服务提供者，此时consumer可以直接调用服务而不再关心地址和端口号，并且该服务还具备了负载均衡的功能\n\n\n\n\n# 信息完善\n\n\n# 修改服务名\n\n在eureka中，机器的名字默认显示的是主机名:服务名:端口号 ，对于服务的机器辨识会比较模糊，如果是使用“1号机”、“5号机”等类似的名称可能更直观，如果有此方面的需求，可以进行修改服务名称。\n\n\n\n需要引入以下两个依赖：\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-actuator</artifactid>\n</dependency>\n\n\n下面是修改后的yml文件：\n\nserver:\n  port: 8001\n\nspring:\n  application:\n    name: cloud-payment-service\n\neureka:\n  client:\n    #表示是否将自己注册进eurekaserver默认为true。\n    register-with-eureka: true\n    #是否从eurekaserver抓取已有的注册信息，默认为true。\n    fetchregistry: true\n    service-url:\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n      # 设置eureka服务注册中心中的主机名称\n      instance-id: payment8001\n\n\n修改过后的样子：\n\n\n\n\n# ip信息显示\n\n在yml文件中修改配置：\n\neureka:\n  client:\n    register-with-eureka: true\n    fetchregistry: true\n    service-url:\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n      instance-id: payment8001\n      #访问路径可以显示ip地址\n      prefer-ip-address: true\n\n\n\n\n\n# 服务发现discovery\n\n对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息\n\n开启服务发现@enablediscoveryclient：\n\n@springbootapplication\n@enableeurekaclient\n@enablediscoveryclient    // 开启服务发现\npublic class paymentmain8001 {\n    public static void main(string[] args) {\n        springapplication.run(paymentmain8001.class, args);\n    }\n}\n\n\n修改eureku中的客户端controller：\n\n@resource\nprivate discoveryclient discoveryclient;\n\n@getmapping("/payment/discovery")\npublic object discovery() {\n    // 获得服务清单列表\n    list<string> services = discoveryclient.getservices();\n    for (string service : services) {\n        log.info("service：{}", service);\n    }\n    // 一个微服务名称下面的所有实例\n    list<serviceinstance> instances = discoveryclient.getinstances("cloud-payment-service");\n    for (serviceinstance instance : instances) {\n        log.info("{}\\t{}\\t{}\\t{}", instance.getinstanceid(), instance.gethost(), \n            instance.getport(), instance.geturi());\n    }\n    return this.discoveryclient;\n}\n\n\n通过服务发现类discoveryclient的getservices()方法，可以获取到服务的清单列表\n\n\n\n通过getinstances("cloud-payment-service");方法可以得到该服务名下的所有实例的信息，该方法的传参就是服务名\n\n两个方法的调用和输出，看到如下信息：\n\n\n\n而web端打印的信息则是服务的列表，order表示的是当前服务的顺序\n\n\n\n\n# 自我保护\n\n> 某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存。属于cap里面的ap分支。\n\n保护模式主要用于一组客户端和eureka server之间存在网络分区场景下的保护。一旦进入保护模式，eureka server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。\n\n如果在eureka server的首页看到以下这段提示，则说明eureka进入了保护模式：\n\n\n\n为什么会产生eureka自我保护机制？\n\n> 为了防止eurekaclient可以正常运行，但是与eurekaserver网络不通情况下，eurekaserver不会立刻将eurekaclient服务剔除。\n\n什么是自我保护模式？\n\n> 默认情况下，如果eurekaserver在一定时间内没有接收到某个微服务实例的心跳，eurekaserver将会注销该实例（默认90秒）。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与eurekaserver之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。eureka通过“自我保护模式”来解决这个问题——当eurekaserver节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。\n\n\n\n在自我保护模式中，eureka server会保护服务注册表中的信息，不再注销任何服务实例。它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。\n\n综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让eureka集群更加的健壮、稳定。\n\n\n# 禁止自我保护\n\n# 服务端配置\n\n在application.yml文件中加入配置\n\neureka:\n  instance:\n    hostname: eureka7001.com\n  client:\n    register-with-eureka: false\n    fetch-registry: false\n    service-url:\n      defaultzone: http://eureka7002.com:7002/eureka/\n# ####################禁止自我保护####################\n  server:\n    # 关闭自我保护机制，保证不可用服务被及时清除\n    enable-self-preservation: false\n    # 2000毫秒没有反应就清除\n    eviction-interval-timer-in-ms: 2000\n\n\n配置好后，就能在eureka的页面看到如下信息：\n\n\n\n# 客户端配置\n\n在application.yml配置文件中进行配置：\n\neureka:\n  client:\n    register-with-eureka: true\n    fetchregistry: true\n    service-url:\n      defaultzone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n  instance:\n    instance-id: payment8001\n    prefer-ip-address: true\n    # ####################设置心跳时间####################\n    # eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒)\n    lease-renewal-interval-in-seconds: 1\n    # eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务\n    lease-expiration-duration-in-seconds: 2\n\n\n配置成功后重启发现8001服务已经被注册进了eureka\n\n\n\n假设现在8001出现问题(关闭8001服务)，此时可以看到8001服务立刻被清除，不再进行自我保护机制\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"Redis概述&安装",frontmatter:{title:"Redis概述&安装",date:"2022-11-25T14:27:01.000Z",permalink:"/pages/bp3ikv4g",categories:["数据库"],tags:["Redis"],author:{name:"乔木先生"}},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Redis/01.Redis%E6%A6%82%E8%BF%B0&%E5%AE%89%E8%A3%85.html",relativePath:"03.数据库/02.Redis/01.Redis概述&安装.md",key:"v-73a2391c",path:"/pages/bp3ikv4g/",headers:[{level:2,title:"什么是Redis",slug:"什么是redis",normalizedTitle:"什么是redis",charIndex:2},{level:2,title:"Redis的应用场景",slug:"redis的应用场景",normalizedTitle:"redis的应用场景",charIndex:495},{level:2,title:"Redis安装",slug:"redis安装",normalizedTitle:"redis安装",charIndex:648},{level:2,title:"Redis常用命令",slug:"redis常用命令",normalizedTitle:"redis常用命令",charIndex:1309},{level:3,title:"前台启动（不推荐）",slug:"前台启动-不推荐",normalizedTitle:"前台启动（不推荐）",charIndex:1323},{level:3,title:"后台启动（推荐）",slug:"后台启动-推荐",normalizedTitle:"后台启动（推荐）",charIndex:1352},{level:3,title:"客户端",slug:"客户端",normalizedTitle:"客户端",charIndex:1296},{level:3,title:"关闭Redis",slug:"关闭redis",normalizedTitle:"关闭redis",charIndex:1636}],excerpt:'<h2 id="什么是redis"><a class="header-anchor" href="#什么是redis">#</a> 什么是Redis</h2>\n<p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，Redis通过提供多种键值数据类型来适应不同场景下的存储需求。</p>\n',headersStr:"什么是Redis Redis的应用场景 Redis安装 Redis常用命令 前台启动（不推荐） 后台启动（推荐） 客户端 关闭Redis",content:"# 什么是Redis\n\nRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库，Redis通过提供多种键值数据类型来适应不同场景下的存储需求。\n\n目前为止Redis支持的键值数据类型如下：\n\n * 字符串类型 string\n * 哈希类型 hash\n * 列表类型 list\n * 集合类型 set\n * 有序集合类型 sortedset\n\n这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的，并支持各种不同方式的排序。\n\nRedis数据是缓存在内存中，会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。并且在此基础上实现了master-slave(主从)同步。\n\nRedis是单线程+多路IO复用技术\n\n> 多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。\n\n\n# Redis的应用场景\n\n * 配合关系型数据库做高速缓存（数据查询、短连接、新闻内容、商品内容等等）\n * 聊天室的在线好友列表\n * 任务队列。（秒杀、抢购、12306等等）\n * 应用排行榜\n * 网站访问统计\n * 数据过期处理（可以精确到毫秒）\n * 分布式集群架构中的session分离\n\n\n# Redis安装\n\n * 官网：https://redis.io\n * 中文网：http://www.redis.net.cn\n\n这里安装6.2.1 for Linux 版本\n\n安装GCC\n\nyum install centos-release-scl scl-utils-build\nyum install -y devtoolset-8-toolchain\nscl enable devtoolset-8 bash\n\n\n测试** gcc版本**\n\ngcc --version\n\n\n下载redis-6.2.1.tar.gz放/opt目录\n\n解压，并进入文件夹\n\ntar -zxvf redis-6.2.1.tar.gz\ncd redis-6.2.1\n\n\n在redis-6.2.1目录下执行命令：\n\nmake\nmake install\n\n\n如果没有准备好C语言编译环境，make会报错：Jemalloc/jemalloc.h：没有那个文件 ，这时执行make distclean 命令后再执行make 命令。\n\n进入安装目录：\n\ncd /usr/local/bin\n\n\n * redis-benchmark：性能测试工具\n * redis-check-aof：修复有问题的AOF文件\n * redis-check-dump：修复有问题的dump.rdb文件\n * redis-sentinel：Redis集群使用\n * redis-server：Redis服务器启动命令\n * redis-cli：客户端，操作入口\n\n\n# Redis常用命令\n\n\n# 前台启动（不推荐）\n\nredis-server\n\n\n\n# 后台启动（推荐）\n\n备份redis.conf文件，拷贝一份到其他目录\n\nmkdir /home/data\nmkdir /home/data/redis\ncp /opt/redis-6.2.1/redis.conf /home/data/redis\n\n\n修改redis.conf(128行)文件将里面的daemonize no改成yes，让服务在后台启动。\n\n\n\n启动Redis：\n\nredis-server /home/data/redis/redis.conf\n\n\n\n# 客户端\n\nredis-cli\n\n\n指定端口：\n\nredis-cli -p 6379\n\n\n\n# 关闭Redis\n\n单实例关闭：\n\nredis-cli shutdown\n\n\n指定端口关闭：\n\nredis-cli -p 6379 shutdown\n\n\n进入Redis后关闭：\n\nshutdown\n\n\n",normalizedContent:"# 什么是redis\n\nredis是用c语言开发的一个开源的高性能键值对（key-value）数据库，redis通过提供多种键值数据类型来适应不同场景下的存储需求。\n\n目前为止redis支持的键值数据类型如下：\n\n * 字符串类型 string\n * 哈希类型 hash\n * 列表类型 list\n * 集合类型 set\n * 有序集合类型 sortedset\n\n这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的，并支持各种不同方式的排序。\n\nredis数据是缓存在内存中，会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。并且在此基础上实现了master-slave(主从)同步。\n\nredis是单线程+多路io复用技术\n\n> 多路复用是指使用一个线程来检查多个文件描述符（socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。\n\n\n# redis的应用场景\n\n * 配合关系型数据库做高速缓存（数据查询、短连接、新闻内容、商品内容等等）\n * 聊天室的在线好友列表\n * 任务队列。（秒杀、抢购、12306等等）\n * 应用排行榜\n * 网站访问统计\n * 数据过期处理（可以精确到毫秒）\n * 分布式集群架构中的session分离\n\n\n# redis安装\n\n * 官网：https://redis.io\n * 中文网：http://www.redis.net.cn\n\n这里安装6.2.1 for linux 版本\n\n安装gcc\n\nyum install centos-release-scl scl-utils-build\nyum install -y devtoolset-8-toolchain\nscl enable devtoolset-8 bash\n\n\n测试** gcc版本**\n\ngcc --version\n\n\n下载redis-6.2.1.tar.gz放/opt目录\n\n解压，并进入文件夹\n\ntar -zxvf redis-6.2.1.tar.gz\ncd redis-6.2.1\n\n\n在redis-6.2.1目录下执行命令：\n\nmake\nmake install\n\n\n如果没有准备好c语言编译环境，make会报错：jemalloc/jemalloc.h：没有那个文件 ，这时执行make distclean 命令后再执行make 命令。\n\n进入安装目录：\n\ncd /usr/local/bin\n\n\n * redis-benchmark：性能测试工具\n * redis-check-aof：修复有问题的aof文件\n * redis-check-dump：修复有问题的dump.rdb文件\n * redis-sentinel：redis集群使用\n * redis-server：redis服务器启动命令\n * redis-cli：客户端，操作入口\n\n\n# redis常用命令\n\n\n# 前台启动（不推荐）\n\nredis-server\n\n\n\n# 后台启动（推荐）\n\n备份redis.conf文件，拷贝一份到其他目录\n\nmkdir /home/data\nmkdir /home/data/redis\ncp /opt/redis-6.2.1/redis.conf /home/data/redis\n\n\n修改redis.conf(128行)文件将里面的daemonize no改成yes，让服务在后台启动。\n\n\n\n启动redis：\n\nredis-server /home/data/redis/redis.conf\n\n\n\n# 客户端\n\nredis-cli\n\n\n指定端口：\n\nredis-cli -p 6379\n\n\n\n# 关闭redis\n\n单实例关闭：\n\nredis-cli shutdown\n\n\n指定端口关闭：\n\nredis-cli -p 6379 shutdown\n\n\n进入redis后关闭：\n\nshutdown\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"SpringCloud Consul",frontmatter:{title:"SpringCloud Consul",date:"2022-12-15T19:42:02.000Z",permalink:"/pages/yuu0dk4i/",categories:["Spring生态"],tags:["SpringCloud"],author:{name:"乔木先生"}},regularPath:"/02.Java%E6%A1%86%E6%9E%B6/01.SpringCloud/03.SpringCloud%20Consul.html",relativePath:"02.Java框架/01.SpringCloud/03.SpringCloud Consul.md",key:"v-2e82d988",path:"/pages/yuu0dk4i/",headers:[{level:2,title:"Consul概述",slug:"consul概述",normalizedTitle:"consul概述",charIndex:2},{level:2,title:"下载&安装",slug:"下载-安装",normalizedTitle:"下载&amp;安装",charIndex:null},{level:2,title:"服务提供者",slug:"服务提供者",normalizedTitle:"服务提供者",charIndex:675},{level:2,title:"服务消费者",slug:"服务消费者",normalizedTitle:"服务消费者",charIndex:1770},{level:2,title:"三个注册中心异同点",slug:"三个注册中心异同点",normalizedTitle:"三个注册中心异同点",charIndex:2705},{level:2,title:"CAP",slug:"cap",normalizedTitle:"cap",charIndex:2735},{level:3,title:"经典CAP图",slug:"经典cap图",normalizedTitle:"经典cap图",charIndex:3040},{level:3,title:"AP(Eureka)",slug:"ap-eureka",normalizedTitle:"ap(eureka)",charIndex:3287},{level:3,title:"CP(Zookeeper/Consul)",slug:"cp-zookeeper-consul",normalizedTitle:"cp(zookeeper/consul)",charIndex:3375}],excerpt:'<h2 id="consul概述"><a class="header-anchor" href="#consul概述">#</a> Consul概述</h2>\n<p>Consul 是一套开源的分布式服务发现和配置管理系统，由 HashiCorp 公司用 Go 语言开发。</p>\n<p>提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。</p>\n<p>它具有很多优点。包括：基于raft协议，比较简洁； 支持健康检查，同时支持 HTTP 和 DNS 协议，支持跨数据中心的 WAN 集群，提供图形界面，跨平台，支持 Linux、Mac、Windows。</p>\n<p>官网：<a href="https://developer.hashicorp.com/consul/docs/intro" target="_blank" rel="noopener noreferrer">https://developer.hashicorp.com/consul/docs/intro<OutboundLink/></a></p>\n',headersStr:"Consul概述 下载&安装 服务提供者 服务消费者 三个注册中心异同点 CAP 经典CAP图 AP(Eureka) CP(Zookeeper/Consul)",content:'# Consul概述\n\nConsul 是一套开源的分布式服务发现和配置管理系统，由 HashiCorp 公司用 Go 语言开发。\n\n提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。\n\n它具有很多优点。包括：基于raft协议，比较简洁； 支持健康检查，同时支持 HTTP 和 DNS 协议，支持跨数据中心的 WAN 集群，提供图形界面，跨平台，支持 Linux、Mac、Windows。\n\n官网：https://developer.hashicorp.com/consul/docs/intro\n\nSpringCloud Consul 具有如下特性：\n\n\n\n * 服务发现：提供HTTP和DNS两种发现方式。\n * 健康监测：支持多种方式，HTTP、TCP、Docker、Shell脚本定制化监控\n * KV存储：Key、Value的存储方式\n * 多数据中心：Consul支持多数据中心\n * 可视化Web界面\n\n\n# 下载&安装\n\n下载地址：https://www.consul.io/downloads.html\n\n中文文档：https://www.springcloud.cc/spring-cloud-consul.html\n\n下载后查看版本号：\n\n\n\n使用开发模式启动：\n\nconsul agent -dev\n\n\n\n\n通过http://localhost:8500访问Consul的首页：\n\n\n\n\n# 服务提供者\n\n新建一个maven工程，添加相关依赖\n\n\x3c!--SpringCloud consul-server --\x3e\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n</dependency>\n\n\n配置yml文件：\n\n# consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n\n# consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n\n主启动类：\n\n@SpringBootApplication\n@EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\npublic class PaymentMain8006 {\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentMain8006.class, args);\n    }\n}\n\n\nController，随便写一个接口，以检查是否注册进consul服务：\n\n@RestController\npublic class PaymentController {\n    @Value("${server.port}")\n    private String serverPort;\n\n    @RequestMapping(value = "/payment/consul")\n    public String paymentConsul() {\n        return "springcloud with consul: " + serverPort + "\\t   " + UUID.randomUUID();\n    }\n}\n\n\n启动项目，可以在Consul的管理页面看到该服务：\n\n\n\n调用接口，也是成功的：\n\n\n\n\n# 服务消费者\n\n创建一个Maven工程，pom文件和上面的服务提供者一样，\n\n配置yml文件：\n\n# consul服务端口号\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-consumer-order\n\n# consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n\n主启动类加上@EnableDiscoveryClient 注解。\n\n将RestTemplate加入到容器。\n\n@Bean\n@LoadBalanced\npublic RestTemplate getRestTemplate() {\n    return new RestTemplate();\n}\n\n\n使用RestTemplate调用服务提供者的接口：\n\n@RestController\npublic class OrderConsulController {\n    public static final String INVOKE_URL = "http://consul-provider-payment";\n\n    @Resource\n    private RestTemplate restTemplate;\n\n    @GetMapping(value = "/consumer/payment/consul")\n    public String paymentInfo() {\n        String result = restTemplate.getForObject(INVOKE_URL + "/payment/consul", String.class);\n        return result;\n    }\n}\n\n\n启动项目，服务消费者也注册进了Consul中，并且调用服务消费者的接口成功：\n\n\n\n\n\n\n# 三个注册中心异同点\n\n组件名         语言     CAP   服务健康检查   对外暴露接口     SPRINGCLOUD集成\nEureka      Java   AP    可配支持     HTTP       已集成\nConsul      Go     CP    支持       HTTP/DNS   已集成\nZookeeper   Java   CP    支持       客户端        已集成\n\n\n# CAP\n\n * C：Consistency（强一致性）\n * A：Availability（可用性）\n * P：Partition tolerance（分区容错性）\n\nCAP理论关注粒度是数据，而不是整体系统设计的策略\n\n\n# 经典CAP图\n\n最多只能同时较好的满足两个。\n\nCAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：\n\n * CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。\n * CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。\n * AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n\n\n\n# AP(Eureka)\n\n当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。\n\n> 结论：违背了一致性C的要求，只满足可用性和分区容错，即AP\n\n\n\n\n# CP(Zookeeper/Consul)\n\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性\n\n> 结论：违背了可用性A的要求，只满足一致性和分区容错，即CP\n\n',normalizedContent:'# consul概述\n\nconsul 是一套开源的分布式服务发现和配置管理系统，由 hashicorp 公司用 go 语言开发。\n\n提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之consul提供了一种完整的服务网格解决方案。\n\n它具有很多优点。包括：基于raft协议，比较简洁； 支持健康检查，同时支持 http 和 dns 协议，支持跨数据中心的 wan 集群，提供图形界面，跨平台，支持 linux、mac、windows。\n\n官网：https://developer.hashicorp.com/consul/docs/intro\n\nspringcloud consul 具有如下特性：\n\n\n\n * 服务发现：提供http和dns两种发现方式。\n * 健康监测：支持多种方式，http、tcp、docker、shell脚本定制化监控\n * kv存储：key、value的存储方式\n * 多数据中心：consul支持多数据中心\n * 可视化web界面\n\n\n# 下载&安装\n\n下载地址：https://www.consul.io/downloads.html\n\n中文文档：https://www.springcloud.cc/spring-cloud-consul.html\n\n下载后查看版本号：\n\n\n\n使用开发模式启动：\n\nconsul agent -dev\n\n\n\n\n通过http://localhost:8500访问consul的首页：\n\n\n\n\n# 服务提供者\n\n新建一个maven工程，添加相关依赖\n\n\x3c!--springcloud consul-server --\x3e\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-consul-discovery</artifactid>\n</dependency>\n\n\n配置yml文件：\n\n# consul服务端口号\nserver:\n  port: 8006\n\nspring:\n  application:\n    name: consul-provider-payment\n\n# consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n\n主启动类：\n\n@springbootapplication\n@enablediscoveryclient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务\npublic class paymentmain8006 {\n    public static void main(string[] args) {\n        springapplication.run(paymentmain8006.class, args);\n    }\n}\n\n\ncontroller，随便写一个接口，以检查是否注册进consul服务：\n\n@restcontroller\npublic class paymentcontroller {\n    @value("${server.port}")\n    private string serverport;\n\n    @requestmapping(value = "/payment/consul")\n    public string paymentconsul() {\n        return "springcloud with consul: " + serverport + "\\t   " + uuid.randomuuid();\n    }\n}\n\n\n启动项目，可以在consul的管理页面看到该服务：\n\n\n\n调用接口，也是成功的：\n\n\n\n\n# 服务消费者\n\n创建一个maven工程，pom文件和上面的服务提供者一样，\n\n配置yml文件：\n\n# consul服务端口号\nserver:\n  port: 80\n\nspring:\n  application:\n    name: cloud-consumer-order\n\n# consul注册中心地址\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        #hostname: 127.0.0.1\n        service-name: ${spring.application.name}\n\n\n主启动类加上@enablediscoveryclient 注解。\n\n将resttemplate加入到容器。\n\n@bean\n@loadbalanced\npublic resttemplate getresttemplate() {\n    return new resttemplate();\n}\n\n\n使用resttemplate调用服务提供者的接口：\n\n@restcontroller\npublic class orderconsulcontroller {\n    public static final string invoke_url = "http://consul-provider-payment";\n\n    @resource\n    private resttemplate resttemplate;\n\n    @getmapping(value = "/consumer/payment/consul")\n    public string paymentinfo() {\n        string result = resttemplate.getforobject(invoke_url + "/payment/consul", string.class);\n        return result;\n    }\n}\n\n\n启动项目，服务消费者也注册进了consul中，并且调用服务消费者的接口成功：\n\n\n\n\n\n\n# 三个注册中心异同点\n\n组件名         语言     cap   服务健康检查   对外暴露接口     springcloud集成\neureka      java   ap    可配支持     http       已集成\nconsul      go     cp    支持       http/dns   已集成\nzookeeper   java   cp    支持       客户端        已集成\n\n\n# cap\n\n * c：consistency（强一致性）\n * a：availability（可用性）\n * p：partition tolerance（分区容错性）\n\ncap理论关注粒度是数据，而不是整体系统设计的策略\n\n\n# 经典cap图\n\n最多只能同时较好的满足两个。\n\ncap理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，因此，根据 cap 原理将 nosql 数据库分成了满足 ca 原则、满足 cp 原则和满足 ap 原则三 大类：\n\n * ca - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。\n * cp - 满足一致性，分区容忍必的系统，通常性能不是特别高。\n * ap - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。\n\n\n\n\n# ap(eureka)\n\n当网络分区出现后，为了保证可用性，系统b可以返回旧值，保证系统的可用性。\n\n> 结论：违背了一致性c的要求，只满足可用性和分区容错，即ap\n\n\n\n\n# cp(zookeeper/consul)\n\n当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性\n\n> 结论：违背了可用性a的要求，只满足一致性和分区容错，即cp\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"Redis常用命令&数据类型",frontmatter:{title:"Redis常用命令&数据类型",date:"2022-11-26T11:44:41.000Z",permalink:"/pages/0oaka83c",categories:["数据库"],tags:["Redis"],author:{name:"乔木先生"}},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Redis/02.Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"03.数据库/02.Redis/02.Redis常用命令&数据类型.md",key:"v-7d77e79a",path:"/pages/0oaka83c/",headers:[{level:2,title:"Redis库",slug:"redis库",normalizedTitle:"redis库",charIndex:2},{level:2,title:"Redis键",slug:"redis键",normalizedTitle:"redis键",charIndex:152},{level:2,title:"Redis常用五大数据类型",slug:"redis常用五大数据类型",normalizedTitle:"redis常用五大数据类型",charIndex:424},{level:3,title:"字符串类型 string",slug:"字符串类型-string",normalizedTitle:"字符串类型 string",charIndex:641},{level:4,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:802},{level:4,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:486},{level:3,title:"列表类型 list",slug:"列表类型-list",normalizedTitle:"列表类型 list",charIndex:1936},{level:4,title:"常用命令",slug:"常用命令-2",normalizedTitle:"常用命令",charIndex:802},{level:4,title:"数据结构",slug:"数据结构-2",normalizedTitle:"数据结构",charIndex:486},{level:3,title:"集合类型 set",slug:"集合类型-set",normalizedTitle:"集合类型 set",charIndex:2939},{level:4,title:"常用命令",slug:"常用命令-3",normalizedTitle:"常用命令",charIndex:802},{level:4,title:"数据结构",slug:"数据结构-3",normalizedTitle:"数据结构",charIndex:486},{level:3,title:"哈希类型 hash",slug:"哈希类型-hash",normalizedTitle:"哈希类型 hash",charIndex:3838},{level:4,title:"常用命令",slug:"常用命令-4",normalizedTitle:"常用命令",charIndex:802},{level:4,title:"数据结构",slug:"数据结构-4",normalizedTitle:"数据结构",charIndex:486},{level:3,title:"有序集合类型 sortedset",slug:"有序集合类型-sortedset",normalizedTitle:"有序集合类型 sortedset",charIndex:4626},{level:4,title:"常用命令",slug:"常用命令-5",normalizedTitle:"常用命令",charIndex:802},{level:4,title:"数据结构",slug:"数据结构-5",normalizedTitle:"数据结构",charIndex:486},{level:5,title:"跳跃表（跳表）",slug:"跳跃表-跳表",normalizedTitle:"跳跃表（跳表）",charIndex:5773}],headersStr:"Redis库 Redis键 Redis常用五大数据类型 字符串类型 string 常用命令 数据结构 列表类型 list 常用命令 数据结构 集合类型 set 常用命令 数据结构 哈希类型 hash 常用命令 数据结构 有序集合类型 sortedset 常用命令 数据结构 跳跃表（跳表）",content:"# Redis库\n\n默认16个数据库，类似数组下标从0开始，初始默认使用0号库。\n\n统一密码管理，所有库同样密码。\n\n * select <dbid> ：切换数据库\n * dbsize ：查看当前数据库的key的数量\n * flushdb ：清空当前库\n * flushall ：通杀全部库\n\n\n\n\n# Redis键\n\n * keys * ：查看当前库所有key\n\n * keys *1 ：匹配key\n\n * exists key ：判断某个key是否存在\n\n * type key ：查看key的类型\n\n * del key ：删除指定的key数据\n\n * unlink key ：根据value选择非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作\n\n * expire key 10 ：为key设置过期时间(单位 秒)\n\n * ttl key ：查看还有多少秒过期（-1表示永不过期，-2表示已过期）\n\n\n# Redis常用五大数据类型\n\nRedis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构\n\nvalue的数据结构：\n\n * string：字符串类型 。\n * hash：哈希类型，map格式 。\n * list：列表类型，LinkedList格式，支持重复元素 。\n * set：集合类型，不允许重复元素 。\n * sortedset：有序集合类型，不允许重复元素，且元素有顺序。\n\n\n# 字符串类型 string\n\nstring是Redis最基本的类型，一个key对应一个value。\n\nstring类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。\n\nstring类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。\n\n# 常用命令\n\n * set <key> <value> ：添加键值对\n\n\n\n>  * NX：当数据库中key不存在时，添加\n>  * XX：当数据库中key存在时，添加，与NX参数互斥\n>  * EX：key的超时秒数\n>  * PX：key的超时毫秒数，与EX互斥\n\n * setnx <key> <value>：只有在key不存在时，添加键值对\n\n * get <key> ：查询对应键值\n\n * strlen <key>：获得值的长度\n\n * del <key>：删除键值对\n\n * getrange <key> <起始位置> <结束位置> ：获得值的范围，类似java中的substring，前包后包\n\n * setrange <key> <起始位置> <value> ：用覆写所储存的字符串值，从<起始位置>开始(索引从0开始)。\n\n * incr <key>：将key中储存的数字值增1，只能对数字值操作，如果为空，新增值为1\n\n * decr <key>：将key中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1\n\n * incrby/decrby <key> <步长>：将 key 中储存的数字值增减，自定义步长\n\n * append <key> <value>：将给定的<value>追加到原值的末尾\n\n * mset <key1> <value1> <key2> <value2> ....：同时设置一个或多个 key-value对（要么全成功，要么全失败）\n\n * mget <key1> <key2> <key3> .....：同时获取一个或多个value（要么全成功，要么全失败）\n\n * msetnx <key1> <value1> <key2> <value2> .....：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在（要么全成功，要么全失败）\n\n * setex <key> <过期时间> <value>：设置键值的同时，设置过期时间，单位秒。\n\n * getset <key> <value>：以新换旧，设置了新值同时获得旧值。\n\n# 数据结构\n\nstring的数据结构为简单动态字符串(Simple Dynamic String，缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。\n\n\n\n如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。字符串最大长度为512M。\n\n\n# 列表类型 list\n\n单键多值\n\nRedis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n\n它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。\n\n\n\n# 常用命令\n\n * lpush <key> <value1> <value2> <value3> ... ：将一个或多个元素加入列表左边\n\n * rpush <key> <value1> <value2> <value3> ... ：将一个或多个元素加入列表右边\n\n * lpop <key> ：从左边吐出一个值。值在键在，值光键亡。\n\n * rpop <key> ：从右边吐出一个值。值在键在，值光键亡。\n\n\n\n * rpoplpush <key1> <key2> ：从列表右边吐出一个值，插到列表左边。\n * lrange <key> <start> <stop> ：按照索引下标获得元素(从左到右)\n * lrange mylist 0 -1 ： 0左边第一个，-1右边第一个，（0-1表示获取所有）\n * lindex <key> <index> ：按照索引下标获得元素(从左到右)\n * llen <key> ：获得列表长度\n\n\n\n * linsert <key> before <value> <newvalue> ：在的后面插入插入值\n * lrem <key> <n> <value> ：从左边删除n个value(从左到右)\n * lset<key> <index> <value> ：将列表key下标为index的值替换成value\n\n# 数据结构\n\nList的数据结构为快速链表quickList。\n\n首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。\n\n它将所有的元素紧挨着一起存储，分配的是一块连续的内存。\n\n当数据量比较多的时候才会改成quicklist。\n\n因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。\n\n\n\nRedis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。\n\n\n# 集合类型 set\n\nRedis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set可以自动排重，当需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。\n\nRedis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是O(1)。\n\n一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。\n\n# 常用命令\n\n * sadd <key> <value1> <value2> ..... ：将一个或多个元素加入到集合key中，已经存在的元素将被忽略\n\n * smembers <key> ：取出该集合的所有值\n\n * sismember <key> <value> ：判断集合是否为含有该值，有1，没有0\n\n * scard <key> ：返回该集合的元素个数\n\n * spop <key>：随机从该集合中吐出一个值。\n\n * srandmember <key> <n> ：随机从该集合中取出n个值，不会从集合中删除\n\n * srem <key> <value1> <value2> .... ：删除集合中的某个元素\n\n * smove <source><destination> ：value把集合中一个值从一个集合移动到另一个集合\n\n * sinter <key1><key2> ：返回两个集合的交集元素。\n\n * sunion <key1><key2> ：返回两个集合的并集元素。\n\n * sdiff <key1><key2> ：返回两个集合的差集元素(key1中的，不包含key2中的)\n\n# 数据结构\n\nSet数据结构是dict字典，字典是用哈希表实现的。\n\nJava中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。\n\n\n# 哈希类型 hash\n\nRedis hash 是一个键值对集合。\n\nRedis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map<String, Object>\n\n用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储\n\n主要有以下2种存储方式：\n\n\n\n通过key(用户ID) + field(属性标签)就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题：\n\n\n\n# 常用命令\n\n * hset <key> <field> <value> ：给集合中的键赋值\n * hget <key> <field> ：从集合取出 value\n * hmset <key> <field1> <value1> <field2> <value2>... ：批量设置hash的值\n * hexists <key> <field> ：查看哈希表key中，给定域field是否存在。\n * hkeys <key> ：列出该hash集合的所有field\n * hvals <key> ：列出该hash集合的所有value\n * hincrby <key> <field> <increment> ：为哈希表 key 中的域 field 的值加上增量 1 -1\n * hsetnx <key> <field> <value> ：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在\n\n# 数据结构\n\nHash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。\n\n\n# 有序集合类型 sortedset\n\nRedis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。\n\n不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但评分可以重复。\n\n因为元素是有序的，所以可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。\n\n访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。\n\n# 常用命令\n\n * zadd <key> <score1> <value1> <score2> <value2>… ：将一个或多个元素及score值加入到有序集key中\n * zrange <key> <start> <stop> [withscores] ：返回有序集key中下标在之间的元素，带withscores，可以让分数一起和值返回到结果集\n * zrangebyscore key min max [withscores] [limit offset count] ：返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列\n * zrevrangebyscore key max min [withscores] [limit offset count] ： 同上，改为从大到小排列。\n * zincrby <key> <increment> <value> ：为元素的score加上增量\n * zrem <key> <value> ：删除该集合下指定值的元素\n * zcount <key> <min> <max> ：统计该集合，分数区间内的元素个数\n * zrank <key> <value> ：返回该值在集合中的排名，从0开始\n\n# 数据结构\n\nSortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map<String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。\n\nzset底层使用了两个数据结构：\n\n 1. hash：hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。\n 2. 跳跃表：跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。\n\n# 跳跃表（跳表）\n\n有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。\n\nRedis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。\n\n有序链表：\n\n\n\n要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到，共需要6次比较。\n\n跳跃表：\n\n\n\n 1. 从第2层开始，1节点比51节点小，向后比较。\n 2. 21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层。\n 3. 在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下\n 4. 在第0层，51节点为要查找的节点，节点被找到，共查找4次。\n\n从此可以看出跳跃表比有序链表效率要高。",normalizedContent:"# redis库\n\n默认16个数据库，类似数组下标从0开始，初始默认使用0号库。\n\n统一密码管理，所有库同样密码。\n\n * select <dbid> ：切换数据库\n * dbsize ：查看当前数据库的key的数量\n * flushdb ：清空当前库\n * flushall ：通杀全部库\n\n\n\n\n# redis键\n\n * keys * ：查看当前库所有key\n\n * keys *1 ：匹配key\n\n * exists key ：判断某个key是否存在\n\n * type key ：查看key的类型\n\n * del key ：删除指定的key数据\n\n * unlink key ：根据value选择非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作\n\n * expire key 10 ：为key设置过期时间(单位 秒)\n\n * ttl key ：查看还有多少秒过期（-1表示永不过期，-2表示已过期）\n\n\n# redis常用五大数据类型\n\nredis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构\n\nvalue的数据结构：\n\n * string：字符串类型 。\n * hash：哈希类型，map格式 。\n * list：列表类型，linkedlist格式，支持重复元素 。\n * set：集合类型，不允许重复元素 。\n * sortedset：有序集合类型，不允许重复元素，且元素有顺序。\n\n\n# 字符串类型 string\n\nstring是redis最基本的类型，一个key对应一个value。\n\nstring类型是二进制安全的。意味着redis的string可以包含任何数据。比如jpg图片或者序列化的对象。\n\nstring类型是redis最基本的数据类型，一个redis中字符串value最多可以是512m。\n\n# 常用命令\n\n * set <key> <value> ：添加键值对\n\n\n\n>  * nx：当数据库中key不存在时，添加\n>  * xx：当数据库中key存在时，添加，与nx参数互斥\n>  * ex：key的超时秒数\n>  * px：key的超时毫秒数，与ex互斥\n\n * setnx <key> <value>：只有在key不存在时，添加键值对\n\n * get <key> ：查询对应键值\n\n * strlen <key>：获得值的长度\n\n * del <key>：删除键值对\n\n * getrange <key> <起始位置> <结束位置> ：获得值的范围，类似java中的substring，前包后包\n\n * setrange <key> <起始位置> <value> ：用覆写所储存的字符串值，从<起始位置>开始(索引从0开始)。\n\n * incr <key>：将key中储存的数字值增1，只能对数字值操作，如果为空，新增值为1\n\n * decr <key>：将key中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1\n\n * incrby/decrby <key> <步长>：将 key 中储存的数字值增减，自定义步长\n\n * append <key> <value>：将给定的<value>追加到原值的末尾\n\n * mset <key1> <value1> <key2> <value2> ....：同时设置一个或多个 key-value对（要么全成功，要么全失败）\n\n * mget <key1> <key2> <key3> .....：同时获取一个或多个value（要么全成功，要么全失败）\n\n * msetnx <key1> <value1> <key2> <value2> .....：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在（要么全成功，要么全失败）\n\n * setex <key> <过期时间> <value>：设置键值的同时，设置过期时间，单位秒。\n\n * getset <key> <value>：以新换旧，设置了新值同时获得旧值。\n\n# 数据结构\n\nstring的数据结构为简单动态字符串(simple dynamic string，缩写sds)。是可以修改的字符串，内部结构实现上类似于java的arraylist，采用预分配冗余空间的方式来减少内存的频繁分配。\n\n\n\n如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1m时，扩容都是加倍现有的空间，如果超过1m，扩容时一次只会多扩1m的空间。字符串最大长度为512m。\n\n\n# 列表类型 list\n\n单键多值\n\nredis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n\n它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。\n\n\n\n# 常用命令\n\n * lpush <key> <value1> <value2> <value3> ... ：将一个或多个元素加入列表左边\n\n * rpush <key> <value1> <value2> <value3> ... ：将一个或多个元素加入列表右边\n\n * lpop <key> ：从左边吐出一个值。值在键在，值光键亡。\n\n * rpop <key> ：从右边吐出一个值。值在键在，值光键亡。\n\n\n\n * rpoplpush <key1> <key2> ：从列表右边吐出一个值，插到列表左边。\n * lrange <key> <start> <stop> ：按照索引下标获得元素(从左到右)\n * lrange mylist 0 -1 ： 0左边第一个，-1右边第一个，（0-1表示获取所有）\n * lindex <key> <index> ：按照索引下标获得元素(从左到右)\n * llen <key> ：获得列表长度\n\n\n\n * linsert <key> before <value> <newvalue> ：在的后面插入插入值\n * lrem <key> <n> <value> ：从左边删除n个value(从左到右)\n * lset<key> <index> <value> ：将列表key下标为index的值替换成value\n\n# 数据结构\n\nlist的数据结构为快速链表quicklist。\n\n首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。\n\n它将所有的元素紧挨着一起存储，分配的是一块连续的内存。\n\n当数据量比较多的时候才会改成quicklist。\n\n因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。\n\n\n\nredis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。\n\n\n# 集合类型 set\n\nredis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set可以自动排重，当需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。\n\nredis的set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是o(1)。\n\n一个算法，随着数据的增加，执行时间的长短，如果是o(1)，数据增加，查找数据的时间不变。\n\n# 常用命令\n\n * sadd <key> <value1> <value2> ..... ：将一个或多个元素加入到集合key中，已经存在的元素将被忽略\n\n * smembers <key> ：取出该集合的所有值\n\n * sismember <key> <value> ：判断集合是否为含有该值，有1，没有0\n\n * scard <key> ：返回该集合的元素个数\n\n * spop <key>：随机从该集合中吐出一个值。\n\n * srandmember <key> <n> ：随机从该集合中取出n个值，不会从集合中删除\n\n * srem <key> <value1> <value2> .... ：删除集合中的某个元素\n\n * smove <source><destination> ：value把集合中一个值从一个集合移动到另一个集合\n\n * sinter <key1><key2> ：返回两个集合的交集元素。\n\n * sunion <key1><key2> ：返回两个集合的并集元素。\n\n * sdiff <key1><key2> ：返回两个集合的差集元素(key1中的，不包含key2中的)\n\n# 数据结构\n\nset数据结构是dict字典，字典是用哈希表实现的。\n\njava中hashset的内部实现使用的是hashmap，只不过所有的value都指向同一个对象。redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。\n\n\n# 哈希类型 hash\n\nredis hash 是一个键值对集合。\n\nredis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似java里面的map<string, object>\n\n用户id为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储\n\n主要有以下2种存储方式：\n\n\n\n通过key(用户id) + field(属性标签)就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题：\n\n\n\n# 常用命令\n\n * hset <key> <field> <value> ：给集合中的键赋值\n * hget <key> <field> ：从集合取出 value\n * hmset <key> <field1> <value1> <field2> <value2>... ：批量设置hash的值\n * hexists <key> <field> ：查看哈希表key中，给定域field是否存在。\n * hkeys <key> ：列出该hash集合的所有field\n * hvals <key> ：列出该hash集合的所有value\n * hincrby <key> <field> <increment> ：为哈希表 key 中的域 field 的值加上增量 1 -1\n * hsetnx <key> <field> <value> ：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在\n\n# 数据结构\n\nhash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。\n\n\n# 有序集合类型 sortedset\n\nredis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。\n\n不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但评分可以重复。\n\n因为元素是有序的，所以可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。\n\n访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。\n\n# 常用命令\n\n * zadd <key> <score1> <value1> <score2> <value2>… ：将一个或多个元素及score值加入到有序集key中\n * zrange <key> <start> <stop> [withscores] ：返回有序集key中下标在之间的元素，带withscores，可以让分数一起和值返回到结果集\n * zrangebyscore key min max [withscores] [limit offset count] ：返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列\n * zrevrangebyscore key max min [withscores] [limit offset count] ： 同上，改为从大到小排列。\n * zincrby <key> <increment> <value> ：为元素的score加上增量\n * zrem <key> <value> ：删除该集合下指定值的元素\n * zcount <key> <min> <max> ：统计该集合，分数区间内的元素个数\n * zrank <key> <value> ：返回该值在集合中的排名，从0开始\n\n# 数据结构\n\nsortedset(zset)是redis提供的一个非常特别的数据结构，一方面它等价于java的数据结构map<string, double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于treeset，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。\n\nzset底层使用了两个数据结构：\n\n 1. hash：hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。\n 2. 跳跃表：跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。\n\n# 跳跃表（跳表）\n\n有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。\n\nredis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。\n\n有序链表：\n\n\n\n要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到，共需要6次比较。\n\n跳跃表：\n\n\n\n 1. 从第2层开始，1节点比51节点小，向后比较。\n 2. 21节点比51节点小，继续向后比较，后面就是null了，所以从21节点向下到第1层。\n 3. 在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下\n 4. 在第0层，51节点为要查找的节点，节点被找到，共查找4次。\n\n从此可以看出跳跃表比有序链表效率要高。",charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"Redis新数据类型",frontmatter:{title:"Redis新数据类型",date:"2022-12-12T14:59:51.000Z",permalink:"/pages/wuy0993s/",categories:["数据库"],tags:["Redis"],author:{name:"乔木先生"}},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Redis/05.Redis%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"03.数据库/02.Redis/05.Redis新数据类型.md",key:"v-fbe99ed8",path:"/pages/wuy0993s/",headers:[{level:2,title:"Bitmaps",slug:"bitmaps",normalizedTitle:"bitmaps",charIndex:2},{level:3,title:"命令",slug:"命令",normalizedTitle:"命令",charIndex:305},{level:4,title:"setbit",slug:"setbit",normalizedTitle:"setbit",charIndex:418},{level:4,title:"getbit",slug:"getbit",normalizedTitle:"getbit",charIndex:817},{level:4,title:"bitcount",slug:"bitcount",normalizedTitle:"bitcount",charIndex:948},{level:4,title:"bitop",slug:"bitop",normalizedTitle:"bitop",charIndex:1664},{level:3,title:"Bitmaps与set对比",slug:"bitmaps与set对比",normalizedTitle:"bitmaps与set对比",charIndex:2193},{level:2,title:"HyperLogLog",slug:"hyperloglog",normalizedTitle:"hyperloglog",charIndex:2830},{level:3,title:"命令",slug:"命令-2",normalizedTitle:"命令",charIndex:305},{level:4,title:"pfadd",slug:"pfadd",normalizedTitle:"pfadd",charIndex:3563},{level:4,title:"pfcount",slug:"pfcount",normalizedTitle:"pfcount",charIndex:3702},{level:4,title:"pfmerge",slug:"pfmerge",normalizedTitle:"pfmerge",charIndex:3807},{level:2,title:"Geospatial",slug:"geospatial",normalizedTitle:"geospatial",charIndex:3930},{level:3,title:"命令",slug:"命令-3",normalizedTitle:"命令",charIndex:305},{level:4,title:"geoadd",slug:"geoadd",normalizedTitle:"geoadd",charIndex:4069},{level:4,title:"geopos",slug:"geopos",normalizedTitle:"geopos",charIndex:4459},{level:4,title:"geodist",slug:"geodist",normalizedTitle:"geodist",charIndex:4526},{level:4,title:"georadius",slug:"georadius",normalizedTitle:"georadius",charIndex:4719}],headersStr:"Bitmaps 命令 setbit getbit bitcount bitop Bitmaps与set对比 HyperLogLog 命令 pfadd pfcount pfmerge Geospatial 命令 geoadd geopos geodist georadius",content:"# Bitmaps\n\n现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图\n\n\n\n合理地使用操作位能够有效地提高内存使用率和开发效率。\n\nRedis提供了Bitmaps这个“数据类型”可以实现对位的操作：\n\n\n 1. Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。\n 2. Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以'位'为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。\n\n\n\n\n# 命令\n\n# setbit\n\n * setbit <key> <offset> <value> ：设置Bitmaps中某个偏移量的值（0或1）\n   * offset：偏移量从0开始\n\n实例：每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。\n\n设置键的第offset个位的值（从0算起），假设现在有20个用户，userid=1、6、11、15、19 的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图：\n\n\n\n\n\n很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。\n\n> 在第一次初始化Bitmaps时，假如偏移量非常大，整个初始化过程执行会比较慢，可能会造成Redis的阻塞。\n\n# getbit\n\n * getbit <key> <offset> ：获取Bitmaps中某个偏移量的值，获取键的第offset位的值（从0开始算）\n\n实例：获取id=8的用户是否访问过， 返回0说明没有访问过：\n\n\n\n因为100根本不存在，所以也是返回0\n\n# bitcount\n\n统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。\n\nstart 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。\n\n * bitcount <key> [start end] ：统计字符串从start字节到end字节比特值为1的数量\n\n实例：计算访问的用户数量\n\n\n\nstart和end代表起始和结束字节数，下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11，15， 19。\n\n\n\n举例： K1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】\n\n * bitcount K1 1 2 ： 统计下标1、2字节组中bit=1的个数，即01000000 00000000\n   * bitcount K1 1 2 → 1\n * bitcount K1 1 3 ： 统计下标1、3字节组中bit=1的个数，即01000000 00000000 00100001\n   * bitcount K1 1 3 → 3\n * bitcount K1 0 -2 ：统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001 01000000 00000000\n   * bitcount K1 0 -2 → 3\n\n> redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置\n\n# bitop\n\n * bitop and(or/not/xor) <destkey> [key…] ：bitop是一个复合操作，它可以做多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中。\n\n实例：\n\n11-04访问网站的userid=1,2,5,9。\n\nsetbit user:1104 1 1\nsetbit user:1104 2 1\nsetbit user:1104 5 1\nsetbit user:1104 9 1\n\n\n\n\n11-03访问网站的userid=0,1,4,9。\n\nsetbit user:1103 0 1\nsetbit user:1103 1 1\nsetbit user:1103 4 1\nsetbit user:1103 9 1\n\n\n\n\n计算出两天都访问过网站的用户数量：\n\nbitop and user:and:1104_03 user:1103 user:1104\n\n\n\n\n\n\n计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种），可以使用or求并集：\n\nbitop or user:or:1104_03 user:1103 user:1104\n\n\n\n\n\n# Bitmaps与set对比\n\n假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表：\n\n数据类型      每个用户ID占用空间   需要存储的用户量    全部内存量\n集合类型      64位          50000000    64位*50000000 = 400MB\nBitmaps   1位           100000000   1位*100000000 = 12.5MB\n\n很明显，这种情况下使用Bitmaps能节省很多的内存空间，尤其是随着时间推移节省的内存还是非常可观的：\n\n数据类型      一天       一个月     一年\n集合类型      400MB    12GB    144GB\nBitmaps   12.5MB   375MB   4.5GB\n\n但Bitmaps并不是万金油，假如该网站每天的独立访问用户很少，例如只有10万（大量的僵尸用户），那么两者的对比如下表所示， 很显然，使用Bitmaps就不太合适了，因为基本上大部分位都是0。\n\n数据类型      每个USERID占用空间   需要存储的用户量    全部内存量\n集合类型      64位            100000      64位*100000 = 800KB\nBitmaps   1位             100000000   1位*100000000 = 12.5MB\n\n\n# HyperLogLog\n\n在工作当中，经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量），可以使用Redis的incr、incrby轻松实现。\n\n但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。\n\n解决基数问题有很多种方案：\n\n 1. 数据存储在MySQL表中，使用distinct count计算不重复个数\n 2. 使用Redis提供的hash、set、bitmaps等数据结构来处理\n\n以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。\n\n能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog。\n\nRedis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n\n在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\n但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n\n\n\n> 什么是基数?\n\n> 比如数据集 {1, 3, 5, 7, 5, 7, 8} 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。\n\n\n# 命令\n\n# pfadd\n\n * pfadd <key> <element> [element ...] ：添加指定元素到 HyperLogLog 中\n\n实例：将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。\n\n\n\n# pfcount\n\n * pfcount<key> [key ...] ：计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可。\n\n实例：\n\n\n\n# pfmerge\n\n * pfmerge <destkey> <sourcekey> [sourcekey ...] ：将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得\n\n实例：\n\n\n\n\n# Geospatial\n\nRedis 3.2中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。\n\n\n# 命令\n\n# geoadd\n\n * geoadd <key> <longitude> <latitude> <member> [longitude latitude member...] ： 添加地理位置（经度，纬度，名称）\n\n两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。\n\n有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。\n\n当坐标位置超出指定范围时，该命令将会返回一个错误。\n\n已经添加的数据，是无法再次往里面添加的。\n\n实例：\n\ngeoadd china:city 121.47 31.23 shanghai\ngeoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing\n\n\n\n\n# geopos\n\n * geopos <key> <member> [member...] ：获得指定地区的坐标值\n\n实例：\n\n\n\n# geodist\n\n * geodist <key> <member1> <member2> [m|km|ft|mi ] ：获取两个位置之间的直线距离\n\n单位：\n\n * m 表示单位为米[默认值]。\n * km 表示单位为千米。\n * mi 表示单位为英里。\n * ft 表示单位为英尺。\n\n如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位\n\n实例：\n\n\n\n# georadius\n\n * georadius <key> < longitude> <latitude> radius m|km|ft|mi ：以给定的经纬度为中心，找出某一半径内的元素\n   * 经度 纬度 距离 单位\n\n实例：\n\n",normalizedContent:"# bitmaps\n\n现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ascii码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图\n\n\n\n合理地使用操作位能够有效地提高内存使用率和开发效率。\n\nredis提供了bitmaps这个“数据类型”可以实现对位的操作：\n\n\n 1. bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。\n 2. bitmaps单独提供了一套命令， 所以在redis中使用bitmaps和使用字符串的方法不太相同。 可以把bitmaps想象成一个以'位'为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在bitmaps中叫做偏移量。\n\n\n\n\n# 命令\n\n# setbit\n\n * setbit <key> <offset> <value> ：设置bitmaps中某个偏移量的值（0或1）\n   * offset：偏移量从0开始\n\n实例：每个独立用户是否访问过网站存放在bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。\n\n设置键的第offset个位的值（从0算起），假设现在有20个用户，userid=1、6、11、15、19 的用户对网站进行了访问， 那么当前bitmaps初始化结果如图：\n\n\n\n\n\n很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。\n\n> 在第一次初始化bitmaps时，假如偏移量非常大，整个初始化过程执行会比较慢，可能会造成redis的阻塞。\n\n# getbit\n\n * getbit <key> <offset> ：获取bitmaps中某个偏移量的值，获取键的第offset位的值（从0开始算）\n\n实例：获取id=8的用户是否访问过， 返回0说明没有访问过：\n\n\n\n因为100根本不存在，所以也是返回0\n\n# bitcount\n\n统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。\n\nstart 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。\n\n * bitcount <key> [start end] ：统计字符串从start字节到end字节比特值为1的数量\n\n实例：计算访问的用户数量\n\n\n\nstart和end代表起始和结束字节数，下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11，15， 19。\n\n\n\n举例： k1 【01000001 01000000 00000000 00100001】，对应【0，1，2，3】\n\n * bitcount k1 1 2 ： 统计下标1、2字节组中bit=1的个数，即01000000 00000000\n   * bitcount k1 1 2 → 1\n * bitcount k1 1 3 ： 统计下标1、3字节组中bit=1的个数，即01000000 00000000 00100001\n   * bitcount k1 1 3 → 3\n * bitcount k1 0 -2 ：统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001 01000000 00000000\n   * bitcount k1 0 -2 → 3\n\n> redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置\n\n# bitop\n\n * bitop and(or/not/xor) <destkey> [key…] ：bitop是一个复合操作，它可以做多个bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中。\n\n实例：\n\n11-04访问网站的userid=1,2,5,9。\n\nsetbit user:1104 1 1\nsetbit user:1104 2 1\nsetbit user:1104 5 1\nsetbit user:1104 9 1\n\n\n\n\n11-03访问网站的userid=0,1,4,9。\n\nsetbit user:1103 0 1\nsetbit user:1103 1 1\nsetbit user:1103 4 1\nsetbit user:1103 9 1\n\n\n\n\n计算出两天都访问过网站的用户数量：\n\nbitop and user:and:1104_03 user:1103 user:1104\n\n\n\n\n\n\n计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种），可以使用or求并集：\n\nbitop or user:or:1104_03 user:1103 user:1104\n\n\n\n\n\n# bitmaps与set对比\n\n假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和bitmaps分别存储活跃用户可以得到表：\n\n数据类型      每个用户id占用空间   需要存储的用户量    全部内存量\n集合类型      64位          50000000    64位*50000000 = 400mb\nbitmaps   1位           100000000   1位*100000000 = 12.5mb\n\n很明显，这种情况下使用bitmaps能节省很多的内存空间，尤其是随着时间推移节省的内存还是非常可观的：\n\n数据类型      一天       一个月     一年\n集合类型      400mb    12gb    144gb\nbitmaps   12.5mb   375mb   4.5gb\n\n但bitmaps并不是万金油，假如该网站每天的独立访问用户很少，例如只有10万（大量的僵尸用户），那么两者的对比如下表所示， 很显然，使用bitmaps就不太合适了，因为基本上大部分位都是0。\n\n数据类型      每个userid占用空间   需要存储的用户量    全部内存量\n集合类型      64位            100000      64位*100000 = 800kb\nbitmaps   1位             100000000   1位*100000000 = 12.5mb\n\n\n# hyperloglog\n\n在工作当中，经常会遇到与统计相关的功能需求，比如统计网站pv（pageview页面访问量），可以使用redis的incr、incrby轻松实现。\n\n但像uv（uniquevisitor，独立访客）、独立ip数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。\n\n解决基数问题有很多种方案：\n\n 1. 数据存储在mysql表中，使用distinct count计算不重复个数\n 2. 使用redis提供的hash、set、bitmaps等数据结构来处理\n\n以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。\n\n能否能够降低一定的精度来平衡存储空间？redis推出了hyperloglog。\n\nredis hyperloglog 是用来做基数统计的算法，hyperloglog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。\n\n在 redis 里面，每个 hyperloglog 键只需要花费 12 kb 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。\n\n但是，因为 hyperloglog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 hyperloglog 不能像集合那样，返回输入的各个元素。\n\n\n\n> 什么是基数?\n\n> 比如数据集 {1, 3, 5, 7, 5, 7, 8} 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。\n\n\n# 命令\n\n# pfadd\n\n * pfadd <key> <element> [element ...] ：添加指定元素到 hyperloglog 中\n\n实例：将所有元素添加到指定hyperloglog数据结构中。如果执行命令后hll估计的近似基数发生变化，则返回1，否则返回0。\n\n\n\n# pfcount\n\n * pfcount<key> [key ...] ：计算hll的近似基数，可以计算多个hll，比如用hll存储每天的uv，计算一周的uv可以使用7天的uv合并计算即可。\n\n实例：\n\n\n\n# pfmerge\n\n * pfmerge <destkey> <sourcekey> [sourcekey ...] ：将一个或多个hll合并后的结果存储在另一个hll中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得\n\n实例：\n\n\n\n\n# geospatial\n\nredis 3.2中增加了对geo类型的支持。geo，geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度hash等常见操作。\n\n\n# 命令\n\n# geoadd\n\n * geoadd <key> <longitude> <latitude> <member> [longitude latitude member...] ： 添加地理位置（经度，纬度，名称）\n\n两极无法直接添加，一般会下载城市数据，直接通过 java 程序一次性导入。\n\n有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。\n\n当坐标位置超出指定范围时，该命令将会返回一个错误。\n\n已经添加的数据，是无法再次往里面添加的。\n\n实例：\n\ngeoadd china:city 121.47 31.23 shanghai\ngeoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing\n\n\n\n\n# geopos\n\n * geopos <key> <member> [member...] ：获得指定地区的坐标值\n\n实例：\n\n\n\n# geodist\n\n * geodist <key> <member1> <member2> [m|km|ft|mi ] ：获取两个位置之间的直线距离\n\n单位：\n\n * m 表示单位为米[默认值]。\n * km 表示单位为千米。\n * mi 表示单位为英里。\n * ft 表示单位为英尺。\n\n如果用户没有显式地指定单位参数， 那么 geodist 默认使用米作为单位\n\n实例：\n\n\n\n# georadius\n\n * georadius <key> < longitude> <latitude> radius m|km|ft|mi ：以给定的经纬度为中心，找出某一半径内的元素\n   * 经度 纬度 距离 单位\n\n实例：\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"Redis Java客户端Jedis",frontmatter:{title:"Redis Java客户端Jedis",date:"2022-12-20T16:00:30.000Z",permalink:"/pages/a7v81744",categories:["数据库"],tags:["Redis"],author:{name:"乔木先生"}},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Redis/06.Redis%20Java%E5%AE%A2%E6%88%B7%E7%AB%AFJedis.html",relativePath:"03.数据库/02.Redis/06.Redis Java客户端Jedis.md",key:"v-62132423",path:"/pages/a7v81744/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:318},{level:3,title:"创建Maven工程",slug:"创建maven工程",normalizedTitle:"创建maven工程",charIndex:327},{level:3,title:"添加依赖",slug:"添加依赖",normalizedTitle:"添加依赖",charIndex:343},{level:3,title:"测试程序",slug:"测试程序",normalizedTitle:"测试程序",charIndex:550},{level:2,title:"Jedis常用API",slug:"jedis常用api",normalizedTitle:"jedis常用api",charIndex:965},{level:3,title:"基本操作",slug:"基本操作",normalizedTitle:"基本操作",charIndex:980},{level:3,title:"key",slug:"key",normalizedTitle:"key",charIndex:1334},{level:3,title:"string",slug:"string",normalizedTitle:"string",charIndex:2758},{level:3,title:"list",slug:"list",normalizedTitle:"list",charIndex:5090},{level:3,title:"set",slug:"set",normalizedTitle:"set",charIndex:844},{level:3,title:"hash",slug:"hash",normalizedTitle:"hash",charIndex:9931},{level:3,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:11482},{level:2,title:"Jedis连接池",slug:"jedis连接池",normalizedTitle:"jedis连接池",charIndex:12322},{level:3,title:"连接池工具类",slug:"连接池工具类",normalizedTitle:"连接池工具类",charIndex:12701}],excerpt:'<p>Jedis所需要的jar包：</p>\n\x3c!--beforebegin--\x3e<div class="language-xml extra-class">\x3c!--afterbegin--\x3e<pre v-pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>\n</code></pre>\n\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"快速入门 创建Maven工程 添加依赖 测试程序 Jedis常用API 基本操作 key string list set hash 事务 Jedis连接池 连接池工具类",content:'Jedis所需要的jar包：\n\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>3.2.0</version>\n</dependency>\n\n\n连接Redis注意事项：\n\n 1. 禁用Linux的防火墙：Linux(CentOS7)里执行命令\n\nsystemctl stop/disable firewalld.service   \n\n\n 2. redis.conf中注释掉 bind 127.0.0.1\n 3. redis.conf中修改为 protected-mode no\n\n\n# 快速入门\n\n\n# 创建Maven工程\n\n\n\n\n# 添加依赖\n\n在pom.xml文件中添加依赖\n\n<dependencies>\n    <dependency>\n        <groupId>redis.clients</groupId>\n        <artifactId>jedis</artifactId>\n        <version>3.2.0</version>\n    </dependency>\n</dependencies>\n\n\n\n# 测试程序\n\npublic static void main(String[] args) {\n    // 1. 创建连接对象\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    // 2. 设置Redis的密码，如果无密码可以忽略\n    jedis.auth("123456");\n    // 3. 测试连接是否存在\n    String pong = jedis.ping();\n    System.out.println("连接成功：" + pong);\n\n    // 4. 存入一个数据\n    jedis.set("k1", "v1");\n    // 5. 取出一个数据\n    System.out.println(jedis.get("k1"));\n    \n    // 6. 关闭连接\n    jedis.close();\n}\n\n\n\n# Jedis常用API\n\n\n# 基本操作\n\npublic static void main(String[] args) {\n    // 设置连接参数\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    // 验证密码，如果没有设置密码这段代码省略\n    // 验证密码的同时会进行connect操作\n    jedis.auth("123456");\n    // 连接\n    jedis.connect();\n    // 测试是否还能连接，是的话返回pong，测试的同时会进行connect操作\n    String pong = jedis.ping();\n    System.out.println("连接成功：" + pong);\n    // 清空所有的key\n    jedis.flushAll();\n    // 释放资源\n    jedis.close();\n}\n\n\n\n# key\n\npublic static void main(String[] args) {\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    System.out.println("清空数据：" + jedis.flushDB());\n    System.out.println("判断某个键是否存在：" + jedis.exists("username"));\n    System.out.println("新增 <\'username\',\'aaa\'> 的键值对：" + jedis.set("username", "aaa"));\n    System.out.println("新增 <\'password\',\'123\'> 的键值对：" + jedis.set("password", "123"));\n\n    System.out.println("系统中所有的键如下：");\n    Set<String> keys = jedis.keys("*");\n    for (String key : keys) {\n        System.out.println(key);\n    }\n\n    System.out.println("删除键 password:" + jedis.del("password"));\n    System.out.println("判断键 password 是否存在：" + jedis.exists("password"));\n    System.out.println("查看键 username 所存储的值的类型：" + jedis.type("username"));\n    System.out.println("设置 username 的过期时间:"+jedis.expire("username",60));\n    System.out.println("查看 username 的过期时间:"+jedis.ttl("username"));\n    System.out.println("随机返回 key 空间的一个：" + jedis.randomKey());\n    System.out.println("重命名 key：" + jedis.rename("username", "name"));\n    System.out.println("取出改后的 name：" + jedis.get("name"));\n    System.out.println("按索引查询：" + jedis.select(0));\n    System.out.println("删除当前选择数据库中的所有 key：" + jedis.flushDB());\n    System.out.println("返回当前数据库中 key 的数目：" + jedis.dbSize());\n    System.out.println("删除所有数据库中的所有 key：" + jedis.flushAll());\n}\n\n\n\n# string\n\npublic static void main(String[] args) {\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    jedis.flushDB();\n    System.out.println("=========== 增加数据开始 ===========");\n    System.out.println(jedis.set("key1", "value1"));\n    System.out.println(jedis.set("key2", "value2"));\n    System.out.println(jedis.set("key3", "value3"));\n    System.out.println("删除键 key2:" + jedis.del("key2"));\n    System.out.println("获取键 key2:" + jedis.get("key2"));\n    System.out.println("修改 key1:" + jedis.set("key1", "newValue1"));\n    System.out.println("获取 key1 的值：" + jedis.get("key1"));\n    System.out.println("在 key3 后面加入值：" + jedis.append("key3", "key4"));\n    System.out.println("key3 的值：" + jedis.get("key3"));\n    System.out.println("增加多个键值对：" + jedis.mset("key01", "value01", "key02", "value02", "key03", "value03"));\n    System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n    System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03", "key04"));\n    System.out.println("删除多个键值对：" + jedis.del("key01", "key02"));\n    System.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n    System.out.println("=========== 增加数据结束 ===========");\n\n    jedis.flushDB();\n    System.out.println("=========== 新增键值对防止覆盖原先值开始 ==============");\n    System.out.println(jedis.setnx("key1", "value1"));\n    System.out.println(jedis.setnx("key2", "value2"));\n    System.out.println(jedis.setnx("key2", "value2-new"));\n    System.out.println(jedis.get("key1"));\n    System.out.println(jedis.get("key2"));\n    System.out.println("=========== 新增键值对防止覆盖原先值结束 ==============");\n\n    System.out.println("=========== 新增键值对并设置有效时间开始 =============");\n    System.out.println(jedis.setex("key3", 2, "value3"));\n    System.out.println(jedis.get("key3"));\n    try {\n        TimeUnit.SECONDS.sleep(3);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    System.out.println(jedis.get("key3"));\n    System.out.println("=========== 新增键值对并设置有效时间结束 =============");\n\n    System.out.println("=========== 获取原值，更新为新值开始 ==========");\n    System.out.println(jedis.getSet("key2", "key2GetSet"));\n    System.out.println(jedis.get("key2"));\n    System.out.println("获得 key2 的值的字串：" + jedis.getrange("key2", 2,4));\n    System.out.println("=========== 获取原值，更新为新值结束 ==========");\n}\n\n\n\n# list\n\npublic static void main(String[] args) {\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    jedis.flushDB();\n    System.out.println("===========添加一个 list===========");\n    jedis.lpush("collections", "ArrayList", "Vector", "Stack", "HashMap", "WeakHashMap", "LinkedHashMap");\n    jedis.lpush("collections", "HashSet");\n    jedis.lpush("collections", "TreeSet");\n    jedis.lpush("collections", "TreeMap");\n    //-1 代表倒数第一个元素，-2 代表倒数第二个元素，end 为 -1 表示查询全部\n    System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    System.out.println("collections 区间 0-3 的元素：" + jedis.lrange("collections", 0, 3));\n\n    System.out.println("===============================");\n    // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后 add 进去的值先被删，类似于出栈\n    System.out.println("删除指定元素个数：" + jedis.lrem("collections", 2, "HashMap"));\n    System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    System.out.println("删除下标 0-3 区间之外的元素：" + jedis.ltrim("collections", 0, 3));\n    System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    System.out.println("collections 列表出栈（左端）：" + jedis.lpop("collections"));\n    System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    System.out.println("collections 添加元素，从列表右端，与 lpush 相对应：" + jedis.rpush("collections", "EnumMap"));\n    System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    System.out.println("collections 列表出栈（右端）：" + jedis.rpop("collections"));\n    System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    System.out.println("修改 collections 指定下标 1 的内容：" + jedis.lset("collections", 1, "LinkedArrayList"));\n    System.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n\n    System.out.println("===============================");\n    System.out.println("collections 的长度：" + jedis.llen("collections"));\n    System.out.println("获取 collections 下标为 2 的元素：" + jedis.lindex("collections", 2));\n    System.out.println("===============================");\n\n    jedis.lpush("sortedList", "3", "6", "2", "0", "7", "4");\n    System.out.println("sortedList 排序前：" + jedis.lrange("sortedList", 0, -1));\n    System.out.println(jedis.sort("sortedList"));\n    System.out.println("sortedList 排序后：" + jedis.lrange("sortedList", 0, -1));\n}\n\n\n\n# set\n\npublic static void main(String[] args) {\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    jedis.flushDB();\n    System.out.println("============向集合中添加元素（不重复）============");\n    System.out.println(jedis.sadd("eleSet", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n    System.out.println(jedis.sadd("eleSet", "e6"));\n    System.out.println(jedis.sadd("eleSet", "e6"));\n    System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));\n    System.out.println("删除一个元素 e0：" + jedis.srem("eleSet", "e0"));\n    System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));\n    System.out.println("删除两个元素 e7 和 e6：" + jedis.srem("eleSet", "e7", "e6"));\n    System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));\n    System.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleSet"));\n    System.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleSet"));\n    System.out.println("eleSet 的所有元素为：" + jedis.smembers("eleSet"));\n    System.out.println("eleSet 中包含元素的个数：" + jedis.scard("eleSet"));\n    System.out.println("e3 是否在 eleSet 中：" + jedis.sismember("eleSet", "e3"));\n    System.out.println("e1 是否在 eleSet 中：" + jedis.sismember("eleSet", "e1"));\n    System.out.println("e5 是否在 eleSet 中：" + jedis.sismember("eleSet", "e5"));\n\n    System.out.println("=================================");\n    System.out.println(jedis.sadd("eleSet1", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n    System.out.println(jedis.sadd("eleSet2", "e1", "e2", "e4", "e3", "e0", "e8"));\n    // 移到集合元素\n    System.out.println("将 eleSet1 中删除 e1 并存入 eleSet3 中：" + jedis.smove("eleSet1", "eleSet3", "e1"));\n    System.out.println("将 eleSet1 中删除 e2 并存入 eleSet3 中：" + jedis.smove("eleSet1", "eleSet3", "e2"));\n    System.out.println("eleSet1 中的元素：" + jedis.smembers("eleSet1"));\n    System.out.println("eleSet3 中的元素：" + jedis.smembers("eleSet3"));\n\n    System.out.println("============集合运算=================");\n    System.out.println("eleSet1 中的元素：" + jedis.smembers("eleSet1"));\n    System.out.println("eleSet2 中的元素：" + jedis.smembers("eleSet2"));\n    System.out.println("eleSet1 和 eleSet2 的交集:" + jedis.sinter("eleSet1", "eleSet2"));\n    System.out.println("eleSet1 和 eleSet2 的并集:" + jedis.sunion("eleSet1", "eleSet2"));\n    // eleSet1 中有，eleSet2 中没有\n    System.out.println("eleSet1和eleSet2的差集:" + jedis.sdiff("eleSet1", "eleSet2"));\n    // 求交集并将交集保存到 dstkey 的集合\n    jedis.sinterstore("eleSet4", "eleSet1", "eleSet2");\n    System.out.println("eleSet4 中的元素：" + jedis.smembers("eleSet4"));\n}\n\n\n\n# hash\n\npublic static void main(String[] args) {\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n    jedis.flushDB();\n    Map<String, String> map = new HashMap<>();\n    map.put("key1", "value1");\n    map.put("key2", "value2");\n    map.put("key3", "value3");\n    map.put("key4", "value4");\n    //添加名称为hash（key）的hash元素\n    jedis.hmset("hash", map);\n    //向名称为hash的hash中添加key为key5，value为value5元素\n    jedis.hset("hash", "key5", "value5");\n    System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash")); //return Map<String,String>\n    System.out.println("散列hash的所有键为：" + jedis.hkeys("hash")); //return Set<String>\n    System.out.println("散列hash的所有值为：" + jedis.hvals("hash")); //return List<String>\n    System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrBy("hash", "key6", 6));\n    System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));\n    System.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrBy("hash", "key6", 3));\n    System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));\n    System.out.println("删除一个或者多个键值对：" + jedis.hdel("hash", "key2"));\n    System.out.println("散列hash的所有键值对为：" + jedis.hgetAll("hash"));\n    System.out.println("散列hash中键值对的个数：" + jedis.hlen("hash"));\n    System.out.println("判断hash中是否存在key2：" + jedis.hexists("hash", "key2"));\n    System.out.println("判断hash中是否存在key3：" + jedis.hexists("hash", "key3"));\n    System.out.println("获取hash中的值：" + jedis.hmget("hash", "key3"));\n    System.out.println("获取hash中的值：" + jedis.hmget("hash", "key3", "key4"));\n}\n\n\n\n# 事务\n\npublic static void main(String[] args) {\n    Jedis jedis = new Jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n    jedis.flushDB();\n\n    Map<String, String> map = new HashMap<>();\n    map.put("hello", "world");\n    map.put("name", "java");\n    String result = map.toString();\n\n    // 开启事务\n    Transaction multi = jedis.multi();\n    try {\n        // 向 redis 存入一条数据\n        multi.set("map1", result);\n        // 再存入一条数据\n        multi.set("map2", result);\n\n        // 这里引发了异常，用 0 作为被除数\n        int i = 1 / 0;\n        // 如果没有引发异常，执行进入队列的命令\n        multi.exec();\n    } catch (Exception e) {\n        e.printStackTrace();\n        // 如果出现异常，回滚\n        multi.discard();\n    } finally {\n        System.out.println(jedis.get("map1"));\n        System.out.println(jedis.get("map2"));\n        // 最终关闭客户端\n        jedis.close();\n    }\n}\n\n\n\n# Jedis连接池\n\n 1. 创建JedisPool连接池对象\n 2. 调用方法 getResource() 方法获取Jedis连接\n\n//0.创建一个配置对象\nJedisPoolConfig config = new JedisPoolConfig();\nconfig.setMaxTotal(50);\nconfig.setMaxIdle(10);\n\n//1.创建Jedis连接池对象\nJedisPool jedisPool = new JedisPool(config, "localhost", 6379);\n//2.获取连接\nJedis jedis = jedisPool.getResource();\n\n//3. 使用\njedis.set("hehe","heihei");\n\n//4. 关闭 归还到连接池中\njedis.close();\n\n\n\n# 连接池工具类\n\npublic class JedisPoolUtils {\n    \n\tprivate static JedisPool jedisPool;\n    \n\tstatic{\n\t\t//读取配置文件\n\n\t\tInputStream is = JedisPoolUtils.class.getClassLoader()\n            .getResourceAsStream("jedis.properties");\n\n\t\t//创建Properties对象\n\t\tProperties pro = new Properties();\n\t\t//关联文件\n\t\ttry {\n\t\t\tpro.load(is);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t//获取数据，设置到JedisPoolConfig中\n\t\tJedisPoolConfig config = new JedisPoolConfig();\n\t\tconfig.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal")));\n\t\tconfig.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle")));\n        \n\t\t//初始化JedisPool\n\t\tjedisPool = new JedisPool(\n            config,pro.getProperty("host"),\n            Integer.parseInt(pro.getProperty("port"))\n        );\n   }\n  \n\n\t/**\n\t * 获取连接方法\n\t */\n\tpublic static Jedis getJedis(){\n\t\treturn jedisPool.getResource();\n\t}\n}\n',normalizedContent:'jedis所需要的jar包：\n\n<dependency>\n    <groupid>redis.clients</groupid>\n    <artifactid>jedis</artifactid>\n    <version>3.2.0</version>\n</dependency>\n\n\n连接redis注意事项：\n\n 1. 禁用linux的防火墙：linux(centos7)里执行命令\n\nsystemctl stop/disable firewalld.service   \n\n\n 2. redis.conf中注释掉 bind 127.0.0.1\n 3. redis.conf中修改为 protected-mode no\n\n\n# 快速入门\n\n\n# 创建maven工程\n\n\n\n\n# 添加依赖\n\n在pom.xml文件中添加依赖\n\n<dependencies>\n    <dependency>\n        <groupid>redis.clients</groupid>\n        <artifactid>jedis</artifactid>\n        <version>3.2.0</version>\n    </dependency>\n</dependencies>\n\n\n\n# 测试程序\n\npublic static void main(string[] args) {\n    // 1. 创建连接对象\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    // 2. 设置redis的密码，如果无密码可以忽略\n    jedis.auth("123456");\n    // 3. 测试连接是否存在\n    string pong = jedis.ping();\n    system.out.println("连接成功：" + pong);\n\n    // 4. 存入一个数据\n    jedis.set("k1", "v1");\n    // 5. 取出一个数据\n    system.out.println(jedis.get("k1"));\n    \n    // 6. 关闭连接\n    jedis.close();\n}\n\n\n\n# jedis常用api\n\n\n# 基本操作\n\npublic static void main(string[] args) {\n    // 设置连接参数\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    // 验证密码，如果没有设置密码这段代码省略\n    // 验证密码的同时会进行connect操作\n    jedis.auth("123456");\n    // 连接\n    jedis.connect();\n    // 测试是否还能连接，是的话返回pong，测试的同时会进行connect操作\n    string pong = jedis.ping();\n    system.out.println("连接成功：" + pong);\n    // 清空所有的key\n    jedis.flushall();\n    // 释放资源\n    jedis.close();\n}\n\n\n\n# key\n\npublic static void main(string[] args) {\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    system.out.println("清空数据：" + jedis.flushdb());\n    system.out.println("判断某个键是否存在：" + jedis.exists("username"));\n    system.out.println("新增 <\'username\',\'aaa\'> 的键值对：" + jedis.set("username", "aaa"));\n    system.out.println("新增 <\'password\',\'123\'> 的键值对：" + jedis.set("password", "123"));\n\n    system.out.println("系统中所有的键如下：");\n    set<string> keys = jedis.keys("*");\n    for (string key : keys) {\n        system.out.println(key);\n    }\n\n    system.out.println("删除键 password:" + jedis.del("password"));\n    system.out.println("判断键 password 是否存在：" + jedis.exists("password"));\n    system.out.println("查看键 username 所存储的值的类型：" + jedis.type("username"));\n    system.out.println("设置 username 的过期时间:"+jedis.expire("username",60));\n    system.out.println("查看 username 的过期时间:"+jedis.ttl("username"));\n    system.out.println("随机返回 key 空间的一个：" + jedis.randomkey());\n    system.out.println("重命名 key：" + jedis.rename("username", "name"));\n    system.out.println("取出改后的 name：" + jedis.get("name"));\n    system.out.println("按索引查询：" + jedis.select(0));\n    system.out.println("删除当前选择数据库中的所有 key：" + jedis.flushdb());\n    system.out.println("返回当前数据库中 key 的数目：" + jedis.dbsize());\n    system.out.println("删除所有数据库中的所有 key：" + jedis.flushall());\n}\n\n\n\n# string\n\npublic static void main(string[] args) {\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    jedis.flushdb();\n    system.out.println("=========== 增加数据开始 ===========");\n    system.out.println(jedis.set("key1", "value1"));\n    system.out.println(jedis.set("key2", "value2"));\n    system.out.println(jedis.set("key3", "value3"));\n    system.out.println("删除键 key2:" + jedis.del("key2"));\n    system.out.println("获取键 key2:" + jedis.get("key2"));\n    system.out.println("修改 key1:" + jedis.set("key1", "newvalue1"));\n    system.out.println("获取 key1 的值：" + jedis.get("key1"));\n    system.out.println("在 key3 后面加入值：" + jedis.append("key3", "key4"));\n    system.out.println("key3 的值：" + jedis.get("key3"));\n    system.out.println("增加多个键值对：" + jedis.mset("key01", "value01", "key02", "value02", "key03", "value03"));\n    system.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n    system.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03", "key04"));\n    system.out.println("删除多个键值对：" + jedis.del("key01", "key02"));\n    system.out.println("获取多个键值对：" + jedis.mget("key01", "key02", "key03"));\n    system.out.println("=========== 增加数据结束 ===========");\n\n    jedis.flushdb();\n    system.out.println("=========== 新增键值对防止覆盖原先值开始 ==============");\n    system.out.println(jedis.setnx("key1", "value1"));\n    system.out.println(jedis.setnx("key2", "value2"));\n    system.out.println(jedis.setnx("key2", "value2-new"));\n    system.out.println(jedis.get("key1"));\n    system.out.println(jedis.get("key2"));\n    system.out.println("=========== 新增键值对防止覆盖原先值结束 ==============");\n\n    system.out.println("=========== 新增键值对并设置有效时间开始 =============");\n    system.out.println(jedis.setex("key3", 2, "value3"));\n    system.out.println(jedis.get("key3"));\n    try {\n        timeunit.seconds.sleep(3);\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    }\n    system.out.println(jedis.get("key3"));\n    system.out.println("=========== 新增键值对并设置有效时间结束 =============");\n\n    system.out.println("=========== 获取原值，更新为新值开始 ==========");\n    system.out.println(jedis.getset("key2", "key2getset"));\n    system.out.println(jedis.get("key2"));\n    system.out.println("获得 key2 的值的字串：" + jedis.getrange("key2", 2,4));\n    system.out.println("=========== 获取原值，更新为新值结束 ==========");\n}\n\n\n\n# list\n\npublic static void main(string[] args) {\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    jedis.flushdb();\n    system.out.println("===========添加一个 list===========");\n    jedis.lpush("collections", "arraylist", "vector", "stack", "hashmap", "weakhashmap", "linkedhashmap");\n    jedis.lpush("collections", "hashset");\n    jedis.lpush("collections", "treeset");\n    jedis.lpush("collections", "treemap");\n    //-1 代表倒数第一个元素，-2 代表倒数第二个元素，end 为 -1 表示查询全部\n    system.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    system.out.println("collections 区间 0-3 的元素：" + jedis.lrange("collections", 0, 3));\n\n    system.out.println("===============================");\n    // 删除列表指定的值 ，第二个参数为删除的个数（有重复时），后 add 进去的值先被删，类似于出栈\n    system.out.println("删除指定元素个数：" + jedis.lrem("collections", 2, "hashmap"));\n    system.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    system.out.println("删除下标 0-3 区间之外的元素：" + jedis.ltrim("collections", 0, 3));\n    system.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    system.out.println("collections 列表出栈（左端）：" + jedis.lpop("collections"));\n    system.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    system.out.println("collections 添加元素，从列表右端，与 lpush 相对应：" + jedis.rpush("collections", "enummap"));\n    system.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    system.out.println("collections 列表出栈（右端）：" + jedis.rpop("collections"));\n    system.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n    system.out.println("修改 collections 指定下标 1 的内容：" + jedis.lset("collections", 1, "linkedarraylist"));\n    system.out.println("collections 的内容：" + jedis.lrange("collections", 0, -1));\n\n    system.out.println("===============================");\n    system.out.println("collections 的长度：" + jedis.llen("collections"));\n    system.out.println("获取 collections 下标为 2 的元素：" + jedis.lindex("collections", 2));\n    system.out.println("===============================");\n\n    jedis.lpush("sortedlist", "3", "6", "2", "0", "7", "4");\n    system.out.println("sortedlist 排序前：" + jedis.lrange("sortedlist", 0, -1));\n    system.out.println(jedis.sort("sortedlist"));\n    system.out.println("sortedlist 排序后：" + jedis.lrange("sortedlist", 0, -1));\n}\n\n\n\n# set\n\npublic static void main(string[] args) {\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n\n    jedis.flushdb();\n    system.out.println("============向集合中添加元素（不重复）============");\n    system.out.println(jedis.sadd("eleset", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n    system.out.println(jedis.sadd("eleset", "e6"));\n    system.out.println(jedis.sadd("eleset", "e6"));\n    system.out.println("eleset 的所有元素为：" + jedis.smembers("eleset"));\n    system.out.println("删除一个元素 e0：" + jedis.srem("eleset", "e0"));\n    system.out.println("eleset 的所有元素为：" + jedis.smembers("eleset"));\n    system.out.println("删除两个元素 e7 和 e6：" + jedis.srem("eleset", "e7", "e6"));\n    system.out.println("eleset 的所有元素为：" + jedis.smembers("eleset"));\n    system.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleset"));\n    system.out.println("随机的移除集合中的一个元素：" + jedis.spop("eleset"));\n    system.out.println("eleset 的所有元素为：" + jedis.smembers("eleset"));\n    system.out.println("eleset 中包含元素的个数：" + jedis.scard("eleset"));\n    system.out.println("e3 是否在 eleset 中：" + jedis.sismember("eleset", "e3"));\n    system.out.println("e1 是否在 eleset 中：" + jedis.sismember("eleset", "e1"));\n    system.out.println("e5 是否在 eleset 中：" + jedis.sismember("eleset", "e5"));\n\n    system.out.println("=================================");\n    system.out.println(jedis.sadd("eleset1", "e1", "e2", "e4", "e3", "e0", "e8", "e7", "e5"));\n    system.out.println(jedis.sadd("eleset2", "e1", "e2", "e4", "e3", "e0", "e8"));\n    // 移到集合元素\n    system.out.println("将 eleset1 中删除 e1 并存入 eleset3 中：" + jedis.smove("eleset1", "eleset3", "e1"));\n    system.out.println("将 eleset1 中删除 e2 并存入 eleset3 中：" + jedis.smove("eleset1", "eleset3", "e2"));\n    system.out.println("eleset1 中的元素：" + jedis.smembers("eleset1"));\n    system.out.println("eleset3 中的元素：" + jedis.smembers("eleset3"));\n\n    system.out.println("============集合运算=================");\n    system.out.println("eleset1 中的元素：" + jedis.smembers("eleset1"));\n    system.out.println("eleset2 中的元素：" + jedis.smembers("eleset2"));\n    system.out.println("eleset1 和 eleset2 的交集:" + jedis.sinter("eleset1", "eleset2"));\n    system.out.println("eleset1 和 eleset2 的并集:" + jedis.sunion("eleset1", "eleset2"));\n    // eleset1 中有，eleset2 中没有\n    system.out.println("eleset1和eleset2的差集:" + jedis.sdiff("eleset1", "eleset2"));\n    // 求交集并将交集保存到 dstkey 的集合\n    jedis.sinterstore("eleset4", "eleset1", "eleset2");\n    system.out.println("eleset4 中的元素：" + jedis.smembers("eleset4"));\n}\n\n\n\n# hash\n\npublic static void main(string[] args) {\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n    jedis.flushdb();\n    map<string, string> map = new hashmap<>();\n    map.put("key1", "value1");\n    map.put("key2", "value2");\n    map.put("key3", "value3");\n    map.put("key4", "value4");\n    //添加名称为hash（key）的hash元素\n    jedis.hmset("hash", map);\n    //向名称为hash的hash中添加key为key5，value为value5元素\n    jedis.hset("hash", "key5", "value5");\n    system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash")); //return map<string,string>\n    system.out.println("散列hash的所有键为：" + jedis.hkeys("hash")); //return set<string>\n    system.out.println("散列hash的所有值为：" + jedis.hvals("hash")); //return list<string>\n    system.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrby("hash", "key6", 6));\n    system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash"));\n    system.out.println("将key6保存的值加上一个整数，如果key6不存在则添加key6：" + jedis.hincrby("hash", "key6", 3));\n    system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash"));\n    system.out.println("删除一个或者多个键值对：" + jedis.hdel("hash", "key2"));\n    system.out.println("散列hash的所有键值对为：" + jedis.hgetall("hash"));\n    system.out.println("散列hash中键值对的个数：" + jedis.hlen("hash"));\n    system.out.println("判断hash中是否存在key2：" + jedis.hexists("hash", "key2"));\n    system.out.println("判断hash中是否存在key3：" + jedis.hexists("hash", "key3"));\n    system.out.println("获取hash中的值：" + jedis.hmget("hash", "key3"));\n    system.out.println("获取hash中的值：" + jedis.hmget("hash", "key3", "key4"));\n}\n\n\n\n# 事务\n\npublic static void main(string[] args) {\n    jedis jedis = new jedis("192.168.182.133", 6379);\n    jedis.auth("123456");\n    jedis.flushdb();\n\n    map<string, string> map = new hashmap<>();\n    map.put("hello", "world");\n    map.put("name", "java");\n    string result = map.tostring();\n\n    // 开启事务\n    transaction multi = jedis.multi();\n    try {\n        // 向 redis 存入一条数据\n        multi.set("map1", result);\n        // 再存入一条数据\n        multi.set("map2", result);\n\n        // 这里引发了异常，用 0 作为被除数\n        int i = 1 / 0;\n        // 如果没有引发异常，执行进入队列的命令\n        multi.exec();\n    } catch (exception e) {\n        e.printstacktrace();\n        // 如果出现异常，回滚\n        multi.discard();\n    } finally {\n        system.out.println(jedis.get("map1"));\n        system.out.println(jedis.get("map2"));\n        // 最终关闭客户端\n        jedis.close();\n    }\n}\n\n\n\n# jedis连接池\n\n 1. 创建jedispool连接池对象\n 2. 调用方法 getresource() 方法获取jedis连接\n\n//0.创建一个配置对象\njedispoolconfig config = new jedispoolconfig();\nconfig.setmaxtotal(50);\nconfig.setmaxidle(10);\n\n//1.创建jedis连接池对象\njedispool jedispool = new jedispool(config, "localhost", 6379);\n//2.获取连接\njedis jedis = jedispool.getresource();\n\n//3. 使用\njedis.set("hehe","heihei");\n\n//4. 关闭 归还到连接池中\njedis.close();\n\n\n\n# 连接池工具类\n\npublic class jedispoolutils {\n    \n\tprivate static jedispool jedispool;\n    \n\tstatic{\n\t\t//读取配置文件\n\n\t\tinputstream is = jedispoolutils.class.getclassloader()\n            .getresourceasstream("jedis.properties");\n\n\t\t//创建properties对象\n\t\tproperties pro = new properties();\n\t\t//关联文件\n\t\ttry {\n\t\t\tpro.load(is);\n\t\t} catch (ioexception e) {\n\t\t\te.printstacktrace();\n\t\t}\n\n\t\t//获取数据，设置到jedispoolconfig中\n\t\tjedispoolconfig config = new jedispoolconfig();\n\t\tconfig.setmaxtotal(integer.parseint(pro.getproperty("maxtotal")));\n\t\tconfig.setmaxidle(integer.parseint(pro.getproperty("maxidle")));\n        \n\t\t//初始化jedispool\n\t\tjedispool = new jedispool(\n            config,pro.getproperty("host"),\n            integer.parseint(pro.getproperty("port"))\n        );\n   }\n  \n\n\t/**\n\t * 获取连接方法\n\t */\n\tpublic static jedis getjedis(){\n\t\treturn jedispool.getresource();\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2022/12/01, 18:47:59",lastUpdatedTimestamp:1669891679e3},{title:"MQ的相关概念",frontmatter:{title:"MQ的相关概念",date:"2022-11-27T12:20:10.000Z",permalink:"/pages/sm8jwpla",categories:["中间件"],tags:[null],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/01.MQ%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html",relativePath:"04.中间件/01.消息中间件/01.MQ的相关概念.md",key:"v-786c2dcf",path:"/pages/sm8jwpla/",headers:[{level:2,title:"同步通讯",slug:"同步通讯",normalizedTitle:"同步通讯",charIndex:22},{level:2,title:"异步通讯",slug:"异步通讯",normalizedTitle:"异步通讯",charIndex:44},{level:2,title:"什么是MQ",slug:"什么是mq",normalizedTitle:"什么是mq",charIndex:915},{level:2,title:"为什么要用MQ",slug:"为什么要用mq",normalizedTitle:"为什么要用mq",charIndex:1095},{level:2,title:"MQ的分类",slug:"mq的分类",normalizedTitle:"mq的分类",charIndex:1871},{level:3,title:"ActiveMQ",slug:"activemq",normalizedTitle:"activemq",charIndex:2518},{level:3,title:"Kafka",slug:"kafka",normalizedTitle:"kafka",charIndex:2638},{level:3,title:"RocketMQ",slug:"rocketmq",normalizedTitle:"rocketmq",charIndex:3192},{level:3,title:"RabbitMQ",slug:"rabbitmq",normalizedTitle:"rabbitmq",charIndex:3530},{level:2,title:"MQ的选择",slug:"mq的选择",normalizedTitle:"mq的选择",charIndex:3834},{level:3,title:"Kafka",slug:"kafka-2",normalizedTitle:"kafka",charIndex:2638},{level:3,title:"RocketMQ",slug:"rocketmq-2",normalizedTitle:"rocketmq",charIndex:3192},{level:3,title:"RabbitMQ",slug:"rabbitmq-2",normalizedTitle:"rabbitmq",charIndex:3530}],excerpt:"<p>微服务间通讯有同步和异步两种方式：</p>\n<ul>\n<li>同步通讯：就像打电话，需要实时响应。</li>\n<li>异步通讯：就像发邮件，不需要马上回复。</li>\n</ul>\n",headersStr:"同步通讯 异步通讯 什么是MQ 为什么要用MQ MQ的分类 ActiveMQ Kafka RocketMQ RabbitMQ MQ的选择 Kafka RocketMQ RabbitMQ",content:"微服务间通讯有同步和异步两种方式：\n\n * 同步通讯：就像打电话，需要实时响应。\n * 异步通讯：就像发邮件，不需要马上回复。\n\n\n# 同步通讯\n\n同步调用的优点：\n\n时效性较强，可以立即得到结果\n\nFeign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：\n\n 1. 耦合度高： 每次加入新需求，都需要修改原来的代码\n 2. 性能下降： 调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用时间之和。\n 3. 资源浪费：调用链中的每个服务在响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源。\n 4. 级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，可能会导致整个微服务群故障\n\n\n# 异步通讯\n\n异步调用则可以避免上述问题：\n\n以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。\n\n在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。\n\n订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。\n\n为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。\n\n\n\nBroker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。\n\n异步的优点：\n\n * 吞吐量提升：无需等待订阅者处理完成，响应更快速\n * 故障隔离：服务没有直接调用，不存在级联失败问题\n * 调用间没有阻塞，不会造成无效的资源占用\n * 耦合度极低，每个服务都可以灵活插拔，可替换\n * 流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件\n\n缺点：\n\n * 架构复杂了，业务没有明显的流程线，不好管理\n * 需要依赖于Broker的可靠、安全、性能\n\n\n# 什么是MQ\n\nMQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常 见的上下游「逻辑解耦 + 物理解耦」的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。\n\n\n# 为什么要用MQ\n\n 1. 流量消峰\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n\n 2. 应用解耦\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n\n\n\n 3. 异步处理\n\n有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。\n\n\n\n\n# MQ的分类\n\n        RABBITMQ               ACTIVEMQ                        ROCKETMQ   KAFKA\n公司/社区   Rabbit                 Apache                          阿里         Apache\n开发语言    Erlang                 Java                            Java       Scala&Java\n协议支持    AMQP，XMPP，SMTP，STOMP   OpenWire，STOMP，REST，XMPP，AMQP   自定义协议      自定义协议\n可用性     高                      一般                              高          高\n单机吞吐量   一般                     差                               高          非常高\n消息延迟    微秒级                    毫秒级                             毫秒级        毫秒以内\n消息可靠性   高                      一般                              高          一般\n\n\n# ActiveMQ\n\n * 优点： 单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据。\n * 缺点： 官方社区现在对 ActiveMQ 5.x 维护越来越少，高吞吐量场景较少使用。\n\n\n# Kafka\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber，Twitter，Netflix 等大公司所采纳。\n\n * 优点：性能卓越，单机写入 TPS 约在百万条/秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方Kafka Web 管理界面 Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能 较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用。\n * 缺点： Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。\n\n\n# RocketMQ\n\nRocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。\n\n * 优点： 单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到 0 丢失，MQ 功能较为完善，还是分布式的，扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降，源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。\n * 缺点： 支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；社区活跃度一般,没有在 MQ 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码。\n\n\n# RabbitMQ\n\n2007 年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n\n官网：https://www.rabbitmq.com\n\n * 优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。\n * 缺点： 商业版需要收费，学习成本较高。\n\n\n# MQ的选择\n\n * 追求可用性：Kafka、 RocketMQ 、RabbitMQ\n * 追求可靠性：RabbitMQ、RocketMQ\n * 追求吞吐能力：RocketMQ、Kafka\n * 追求消息低延迟：RabbitMQ、Kafka\n\n\n# Kafka\n\nKafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。\n\n\n# RocketMQ\n\n天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。\n\n\n# RabbitMQ\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。",normalizedContent:"微服务间通讯有同步和异步两种方式：\n\n * 同步通讯：就像打电话，需要实时响应。\n * 异步通讯：就像发邮件，不需要马上回复。\n\n\n# 同步通讯\n\n同步调用的优点：\n\n时效性较强，可以立即得到结果\n\nfeign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：\n\n 1. 耦合度高： 每次加入新需求，都需要修改原来的代码\n 2. 性能下降： 调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用时间之和。\n 3. 资源浪费：调用链中的每个服务在响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源。\n 4. 级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，可能会导致整个微服务群故障\n\n\n# 异步通讯\n\n异步调用则可以避免上述问题：\n\n以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。\n\n在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。\n\n订单服务和物流服务是事件订阅者（consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。\n\n为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（broker）。发布者发布事件到broker，不关心谁来订阅事件。订阅者从broker订阅事件，不关心谁发来的消息。\n\n\n\nbroker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。\n\n异步的优点：\n\n * 吞吐量提升：无需等待订阅者处理完成，响应更快速\n * 故障隔离：服务没有直接调用，不存在级联失败问题\n * 调用间没有阻塞，不会造成无效的资源占用\n * 耦合度极低，每个服务都可以灵活插拔，可替换\n * 流量削峰：不管发布事件的流量波动多大，都由broker接收，订阅者可以按照自己的速度去处理事件\n\n缺点：\n\n * 架构复杂了，业务没有明显的流程线，不好管理\n * 需要依赖于broker的可靠、安全、性能\n\n\n# 什么是mq\n\nmq(message queue)，从字面意思上看，本质是个队列，fifo 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，mq 是一种非常常 见的上下游「逻辑解耦 + 物理解耦」的消息通信服务。使用了 mq 之后，消息发送上游只需要依赖 mq，不用依赖其他服务。\n\n\n# 为什么要用mq\n\n 1. 流量消峰\n\n举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分 散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n\n 2. 应用解耦\n\n以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n\n\n\n 3. 异步处理\n\n有些服务间调用是异步的，例如 a 调用 b，b 需要花费很长时间执行，但是 a 需要知道 b 什么时候可以执行完，以前一般有两种方式，a 过一段时间去调用 b 的查询 api 查询。或者 a 提供一个 callback api，b 执行完之后调用 api 通知 a 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，a 调用 b 服务后，只需要监听 b 处理完成的消息，当 b 处理完成后，会发送一条消息给 mq，mq 会将此消息转发给 a 服务。这样 a 服务既不用循环调用 b 的查询 api，也不用提供 callback api。同样b 服务也不用做这些操作。a 服务还能及时的得到异步处理成功的消息。\n\n\n\n\n# mq的分类\n\n        rabbitmq               activemq                        rocketmq   kafka\n公司/社区   rabbit                 apache                          阿里         apache\n开发语言    erlang                 java                            java       scala&java\n协议支持    amqp，xmpp，smtp，stomp   openwire，stomp，rest，xmpp，amqp   自定义协议      自定义协议\n可用性     高                      一般                              高          高\n单机吞吐量   一般                     差                               高          非常高\n消息延迟    微秒级                    毫秒级                             毫秒级        毫秒以内\n消息可靠性   高                      一般                              高          一般\n\n\n# activemq\n\n * 优点： 单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较 低的概率丢失数据。\n * 缺点： 官方社区现在对 activemq 5.x 维护越来越少，高吞吐量场景较少使用。\n\n\n# kafka\n\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 kafka，这款为大数据而生的消息中间件，以其百万级 tps 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 linkedin，uber，twitter，netflix 等大公司所采纳。\n\n * 优点：性能卓越，单机写入 tps 约在百万条/秒，最大的优点，就是吞吐量高。时效性 ms 级可用性非常高，kafka 是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方kafka web 管理界面 kafka-manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能 较为简单，主要支持简单的 mq 功能，在大数据领域的实时计算以及日志采集被大规模使用。\n * 缺点： kafka 单机超过 64 个队列/分区，load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。\n\n\n# rocketmq\n\nrocketmq 出自阿里巴巴的开源产品，用 java 语言实现，在设计时参考了 kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。\n\n * 优点： 单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到 0 丢失，mq 功能较为完善，还是分布式的，扩展性好，支持 10 亿级别的消息堆积，不会因为堆积导致性能下降，源码是 java 我们可以自己阅读源码，定制自己公司的 mq。\n * 缺点： 支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟；社区活跃度一般,没有在 mq 核心中去实现 jms 等接口，有些系统要迁移需要修改大量代码。\n\n\n# rabbitmq\n\n2007 年发布，是一个在amqp(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n\n官网：https://www.rabbitmq.com\n\n * 优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，mq 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：python、ruby、.net、java、jms、c、php、actionscript、xmpp、stomp 等，支持 ajax 文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。\n * 缺点： 商业版需要收费，学习成本较高。\n\n\n# mq的选择\n\n * 追求可用性：kafka、 rocketmq 、rabbitmq\n * 追求可靠性：rabbitmq、rocketmq\n * 追求吞吐能力：rocketmq、kafka\n * 追求消息低延迟：rabbitmq、kafka\n\n\n# kafka\n\nkafka 主要特点是基于 pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。\n\n\n# rocketmq\n\n天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。roketmq 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 rocketmq。\n\n\n# rabbitmq\n\n结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分 方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 rabbitmq。",charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"SpringBoot整合Redis",frontmatter:{title:"SpringBoot整合Redis",date:"2022-12-21T16:00:30.000Z",permalink:"/pages/jsf92i5m",categories:["数据库"],tags:["Redis"],author:{name:"乔木先生"}},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Redis/07.SpringBoot%E6%95%B4%E5%90%88Redis.html",relativePath:"03.数据库/02.Redis/07.SpringBoot整合Redis.md",key:"v-604f08d4",path:"/pages/jsf92i5m/",headers:[{level:2,title:"搭建环境",slug:"搭建环境",normalizedTitle:"搭建环境",charIndex:296},{level:2,title:"Redis配置类",slug:"redis配置类",normalizedTitle:"redis配置类",charIndex:921}],headersStr:"搭建环境 Redis配置类",content:'在 Spring Boot 中一般使用 RedisTemplate 提供的方法来操作 Redis。\n\n * JedisPoolConfig：配置连接池\n * RedisConnectionFactory：是一个接口，配置连接信息，使用它的实现类，在 SpringDataRedis 方案中提供了以下四种工厂模型：\n   * JredisConnectionFactory\n   * JedisConnectionFactory\n   * LettuceConnectionFactory\n   * SrpConnectionFactory\n * RedisTemplate：基本操作\n\n\n# 搭建环境\n\n在pom.xml文件中引入redis相关依赖：\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n\n> 在 Spring Boot 2.x 之后，原来使用的 jedis 被替换成 lettuce\n\n在application.yml中添加配置信息：\n\nspring:\n  redis:\n    # Redis服务器地址\n    host: 127.0.0.1\n    # Redis服务器连接端口\n    port: 6379\n    # Redis数据库索引（默认为0）\n    database: 0\n    # 连接超时时间（毫秒）\n    timeout: 1800000\n    lettuce:\n      pool:\n        # 连接池最大连接数（使用负值表示没有限制）\n        max-active: 20\n        # 最大阻塞等待时间(负数表示没限制)\n        max-wait: -1\n        # 连接池中的最大空闲连接\n        max-idle: 5\n        # 连接池中的最小空闲连接\n        min-idle: 0\n\n\n\n# Redis配置类\n\n分析 RedisAutoConfiguration 自动配置类源码：\n\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(RedisOperations.class)\n@EnableConfigurationProperties(RedisProperties.class)\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n\n\t@Bean\n\t@ConditionalOnMissingBean(name = "redisTemplate")\n\t@ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n\tpublic RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n\t\tRedisTemplate<Object, Object> template = new RedisTemplate<>();\n\t\ttemplate.setConnectionFactory(redisConnectionFactory);\n\t\treturn template;\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\t@ConditionalOnSingleCandidate(RedisConnectionFactory.class)\n\tpublic StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {\n\t\treturn new StringRedisTemplate(redisConnectionFactory);\n\t}\n\n}\n\n\n通过源码可以看出，Spring Boot 自动帮我们在容器中生成了一个 RedisTemplate 和一个 StringRedisTemplate。\n\n因为有 @ConditionalOnMissingBean 注解，如果 Spring 容器中有 RedisTemplate 对象，这个自动配置的 RedisTemplate 不会实例化。因此可以自己配置 RedisTemplate。\n\n@EnableCaching\n@Configuration\npublic class RedisConfig extends CachingConfigurerSupport {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer<?> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        \n        // ObjectMapper 指定在转成json的时候的一些转换规则\n        ObjectMapper om = new ObjectMapper();\n        // om.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n        // 把自定义objectMapper设置到jackson2JsonRedisSerializer中（可以不设置，使用默认规则）\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        template.setConnectionFactory(factory);\n\n        // RedisTemplate默认的序列化方式使用的是JDK的序列化\n        // 设置key采用String的序列化方式\n        template.setKeySerializer(redisSerializer);\n        // 设置value序列化方式采用jackson\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        // value hashmap序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        return template;\n    }\n\n    /**\n     * 缓存管理器\n     */\n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer<?> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);\n        // 解决查询缓存转换异常的问题\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        \n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n                // 配置序列化（解决乱码的问题），过期时间600秒\n                .entryTtl(Duration.ofSeconds(600))\n                // 设置 key为string序列化\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))\n                // 设置value为json序列化\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))\n                // 不缓存空值\n                .disableCachingNullValues();\n        return RedisCacheManager.builder(factory)\n                .cacheDefaults(config)\n                .build();\n    }\n}\n\n',normalizedContent:'在 spring boot 中一般使用 redistemplate 提供的方法来操作 redis。\n\n * jedispoolconfig：配置连接池\n * redisconnectionfactory：是一个接口，配置连接信息，使用它的实现类，在 springdataredis 方案中提供了以下四种工厂模型：\n   * jredisconnectionfactory\n   * jedisconnectionfactory\n   * lettuceconnectionfactory\n   * srpconnectionfactory\n * redistemplate：基本操作\n\n\n# 搭建环境\n\n在pom.xml文件中引入redis相关依赖：\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-data-redis</artifactid>\n</dependency>\n\n\n> 在 spring boot 2.x 之后，原来使用的 jedis 被替换成 lettuce\n\n在application.yml中添加配置信息：\n\nspring:\n  redis:\n    # redis服务器地址\n    host: 127.0.0.1\n    # redis服务器连接端口\n    port: 6379\n    # redis数据库索引（默认为0）\n    database: 0\n    # 连接超时时间（毫秒）\n    timeout: 1800000\n    lettuce:\n      pool:\n        # 连接池最大连接数（使用负值表示没有限制）\n        max-active: 20\n        # 最大阻塞等待时间(负数表示没限制)\n        max-wait: -1\n        # 连接池中的最大空闲连接\n        max-idle: 5\n        # 连接池中的最小空闲连接\n        min-idle: 0\n\n\n\n# redis配置类\n\n分析 redisautoconfiguration 自动配置类源码：\n\n@configuration(proxybeanmethods = false)\n@conditionalonclass(redisoperations.class)\n@enableconfigurationproperties(redisproperties.class)\n@import({ lettuceconnectionconfiguration.class, jedisconnectionconfiguration.class })\npublic class redisautoconfiguration {\n\n\t@bean\n\t@conditionalonmissingbean(name = "redistemplate")\n\t@conditionalonsinglecandidate(redisconnectionfactory.class)\n\tpublic redistemplate<object, object> redistemplate(redisconnectionfactory redisconnectionfactory) {\n\t\tredistemplate<object, object> template = new redistemplate<>();\n\t\ttemplate.setconnectionfactory(redisconnectionfactory);\n\t\treturn template;\n\t}\n\n\t@bean\n\t@conditionalonmissingbean\n\t@conditionalonsinglecandidate(redisconnectionfactory.class)\n\tpublic stringredistemplate stringredistemplate(redisconnectionfactory redisconnectionfactory) {\n\t\treturn new stringredistemplate(redisconnectionfactory);\n\t}\n\n}\n\n\n通过源码可以看出，spring boot 自动帮我们在容器中生成了一个 redistemplate 和一个 stringredistemplate。\n\n因为有 @conditionalonmissingbean 注解，如果 spring 容器中有 redistemplate 对象，这个自动配置的 redistemplate 不会实例化。因此可以自己配置 redistemplate。\n\n@enablecaching\n@configuration\npublic class redisconfig extends cachingconfigurersupport {\n\n    @bean\n    public redistemplate<string, object> redistemplate(redisconnectionfactory factory) {\n        redistemplate<string, object> template = new redistemplate<>();\n        redisserializer<string> redisserializer = new stringredisserializer();\n        jackson2jsonredisserializer<?> jackson2jsonredisserializer = new jackson2jsonredisserializer<>(object.class);\n        \n        // objectmapper 指定在转成json的时候的一些转换规则\n        objectmapper om = new objectmapper();\n        // om.setdateformat(new simpledateformat("yyyy-mm-dd hh:mm:ss"));\n        om.setvisibility(propertyaccessor.all, jsonautodetect.visibility.any);\n        om.activatedefaulttyping(laissezfairesubtypevalidator.instance, objectmapper.defaulttyping.non_final, jsontypeinfo.as.property);\n\n        // 把自定义objectmapper设置到jackson2jsonredisserializer中（可以不设置，使用默认规则）\n        jackson2jsonredisserializer.setobjectmapper(om);\n        template.setconnectionfactory(factory);\n\n        // redistemplate默认的序列化方式使用的是jdk的序列化\n        // 设置key采用string的序列化方式\n        template.setkeyserializer(redisserializer);\n        // 设置value序列化方式采用jackson\n        template.setvalueserializer(jackson2jsonredisserializer);\n        // value hashmap序列化\n        template.sethashvalueserializer(jackson2jsonredisserializer);\n        return template;\n    }\n\n    /**\n     * 缓存管理器\n     */\n    @bean\n    public cachemanager cachemanager(redisconnectionfactory factory) {\n        redisserializer<string> redisserializer = new stringredisserializer();\n        jackson2jsonredisserializer<?> jackson2jsonredisserializer = new jackson2jsonredisserializer<>(object.class);\n        // 解决查询缓存转换异常的问题\n        objectmapper om = new objectmapper();\n        om.setvisibility(propertyaccessor.all, jsonautodetect.visibility.any);\n        om.activatedefaulttyping(laissezfairesubtypevalidator.instance, objectmapper.defaulttyping.non_final, jsontypeinfo.as.property);\n        jackson2jsonredisserializer.setobjectmapper(om);\n        \n        rediscacheconfiguration config = rediscacheconfiguration.defaultcacheconfig()\n                // 配置序列化（解决乱码的问题），过期时间600秒\n                .entryttl(duration.ofseconds(600))\n                // 设置 key为string序列化\n                .serializekeyswith(redisserializationcontext.serializationpair.fromserializer(redisserializer))\n                // 设置value为json序列化\n                .serializevalueswith(redisserializationcontext.serializationpair.fromserializer(jackson2jsonredisserializer))\n                // 不缓存空值\n                .disablecachingnullvalues();\n        return rediscachemanager.builder(factory)\n                .cachedefaults(config)\n                .build();\n    }\n}\n\n',charsets:{cjk:!0},lastUpdated:"2022/12/01, 18:47:59",lastUpdatedTimestamp:1669891679e3},{title:"Redis配置文件",frontmatter:{title:"Redis配置文件",date:"2022-12-10T21:23:00.000Z",permalink:"/pages/57aemd8k",categories:["数据库"],tags:["Redis"],author:{name:"乔木先生"}},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Redis/03.Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html",relativePath:"03.数据库/02.Redis/03.Redis配置文件.md",key:"v-951a3cee",path:"/pages/57aemd8k/",headers:[{level:2,title:"Units 单位",slug:"units-单位",normalizedTitle:"units 单位",charIndex:2},{level:2,title:"INCLUDES 包含",slug:"includes-包含",normalizedTitle:"includes 包含",charIndex:585},{level:2,title:"NETWORK 网络相关配置",slug:"network-网络相关配置",normalizedTitle:"network 网络相关配置",charIndex:1468},{level:3,title:"bind",slug:"bind",normalizedTitle:"bind",charIndex:1487},{level:3,title:"protected-mode",slug:"protected-mode",normalizedTitle:"protected-mode",charIndex:1591},{level:3,title:"port",slug:"port",normalizedTitle:"port",charIndex:2322},{level:3,title:"tcp-backlog",slug:"tcp-backlog",normalizedTitle:"tcp-backlog",charIndex:4271},{level:3,title:"timeout",slug:"timeout",normalizedTitle:"timeout",charIndex:4919},{level:3,title:"tcp-keepalive",slug:"tcp-keepalive",normalizedTitle:"tcp-keepalive",charIndex:5052},{level:2,title:"GENERAL 通用",slug:"general-通用",normalizedTitle:"general 通用",charIndex:5744},{level:3,title:"daemonize",slug:"daemonize",normalizedTitle:"daemonize",charIndex:5759},{level:3,title:"pidfile",slug:"pidfile",normalizedTitle:"pidfile",charIndex:6047},{level:3,title:"loglevel",slug:"loglevel",normalizedTitle:"loglevel",charIndex:6685},{level:3,title:"logfile",slug:"logfile",normalizedTitle:"logfile",charIndex:7155},{level:3,title:"databases",slug:"databases",normalizedTitle:"databases",charIndex:7396},{level:2,title:"SECURITY 安全",slug:"security-安全",normalizedTitle:"security 安全",charIndex:7672},{level:3,title:"设置密码",slug:"设置密码",normalizedTitle:"设置密码",charIndex:7688},{level:2,title:"LIMITS 限制",slug:"limits-限制",normalizedTitle:"limits 限制",charIndex:8475},{level:3,title:"maxclients",slug:"maxclients",normalizedTitle:"maxclients",charIndex:8489},{level:3,title:"maxmemory",slug:"maxmemory",normalizedTitle:"maxmemory",charIndex:9409},{level:3,title:"maxmemory-policy",slug:"maxmemory-policy",normalizedTitle:"maxmemory-policy",charIndex:9472},{level:3,title:"maxmemory-samples",slug:"maxmemory-samples",normalizedTitle:"maxmemory-samples",charIndex:12628}],headersStr:"Units 单位 INCLUDES 包含 NETWORK 网络相关配置 bind protected-mode port tcp-backlog timeout tcp-keepalive GENERAL 通用 daemonize pidfile loglevel logfile databases SECURITY 安全 设置密码 LIMITS 限制 maxclients maxmemory maxmemory-policy maxmemory-samples",content:'# Units 单位\n\n配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感。\n\n# Redis configuration file example.\n#\n# Note that in order to read the configuration file, Redis must be\n# started with the file path as first argument:\n#\n# ./redis-server /path/to/redis.conf\n\n# Note on units: when memory size is needed, it is possible to specify\n# it in the usual form of 1k 5GB 4M and so forth:\n#\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n#\n# units are case insensitive so 1GB 1Gb 1gB are all the same.\n\n\n\n# INCLUDES 包含\n\n类似jsp中的include，多实例的情况可以把公用的配置文件提取出来\n\n################################## INCLUDES ###################################\n\n# Include one or more other config files here.  This is useful if you\n# have a standard template that goes to all Redis servers but also need\n# to customize a few per-server settings.  Include files can include\n# other files, so use this wisely.\n#\n# Note that option "include" won\'t be rewritten by command "CONFIG REWRITE"\n# from admin or Redis Sentinel. Since Redis always uses the last processed\n# line as value of a configuration directive, you\'d better put includes\n# at the beginning of this file to avoid overwriting config change at runtime.\n#\n# If instead you are interested in using includes to override configuration\n# options, it is better to use include as the last line.\n#\n# include /path/to/local.conf\n# include /path/to/other.conf\n\n\n\n# NETWORK 网络相关配置\n\n\n# bind\n\n * 默认情况 bind=127.0.0.1 只能接受本机的访问请求\n * 不写的情况下，无限制接受任何ip地址的访问\n\n生产环境要写应用服务器的地址，服务器是需要远程访问的。\n\n> 如果开启了 protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，Redis只允许接受本机的响应\n\n################################## NETWORK #####################################\n\n# By default, if no "bind" configuration directive is specified, Redis listens\n# for connections from all available network interfaces on the host machine.\n# It is possible to listen to just one or multiple selected interfaces using\n# the "bind" configuration directive, followed by one or more IP addresses.\n# Each address can be prefixed by "-", which means that redis will not fail to\n# start if the address is not available. Being not available only refers to\n# addresses that does not correspond to any network interfece. Addresses that\n# are already in use will always fail, and unsupported protocols will always BE\n# silently skipped.\n#\n# Examples:\n#\n# bind 192.168.1.100 10.0.0.1     # listens on two specific IPv4 addresses\n# bind 127.0.0.1 ::1              # listens on loopback IPv4 and IPv6\n# bind * -::*                     # like the default, all available interfaces\n#\n# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the\n# internet, binding to all the interfaces is dangerous and will expose the\n# instance to everybody on the internet. So by default we uncomment the\n# following bind directive, that will force Redis to listen only on the\n# IPv4 and IPv6 (if available) loopback interface addresses (this means Redis\n# will only be able to accept client connections from the same host that it is\n# running on).\n#\n# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES\n# JUST COMMENT OUT THE FOLLOWING LINE.\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nbind 127.0.0.1 -::1\n\n\n\n\n\n# protected-mode\n\n本机访问保护模式，设置no\n\n# Protected mode is a layer of security protection, in order to avoid that\n# Redis instances left open on the internet are accessed and exploited.\n#\n# When protected mode is on and if:\n#\n# 1) The server is not binding explicitly to a set of addresses using the\n#    "bind" directive.\n# 2) No password is configured.\n#\t\n# The server only accepts connections from clients connecting from the\n# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain\n# sockets.\n#\n# By default protected mode is enabled. You should disable it only if\n# you are sure you want clients from other hosts to connect to Redis\n# even if no authentication is configured, nor a specific set of interfaces\n# are explicitly listed using the "bind" directive.\nprotected-mode no\n\n\n\n# port\n\n端口号，默认为6379\n\n# Accept connections on the specified port, default is 6379 (IANA #815344).\n# If port 0 is specified Redis will not listen on a TCP socket.\nport 6379\n\n\n\n# tcp-backlog\n\n设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。\n\n在高并发环境下需要一个高backlog值来避免慢客户端连接问题。\n\n> Linux内核会将这个值减小到 /proc/sys/net/core/somaxconn 的值（128），所以需要确认增大 /proc/sys/net/core/somaxconn 和 /proc/sys/net/ipv4/tcp_max_syn_backlog （128）两个值来达到想要的效果。\n\n# TCP listen() backlog.\n#\n# In high requests-per-second environments you need a high backlog in order\n# to avoid slow clients connection issues. Note that the Linux kernel\n# will silently truncate it to the value of /proc/sys/net/core/somaxconn so\n# make sure to raise both the value of somaxconn and tcp_max_syn_backlog\n# in order to get the desired effect.\ntcp-backlog 511\n\n\n\n# timeout\n\n一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。\n\n# Close the connection after a client is idle for N seconds (0 to disable)\ntimeout 0\n\n\n\n# tcp-keepalive\n\n对访问客户端的一种心跳检测，每个n秒检测一次，单位为秒。\n\n如果设置为0，则不会进行Keepalive检测。\n\n建议设置成60。\n\n# TCP keepalive.\n#\n# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence\n# of communication. This is useful for two reasons:\n#\n# 1) Detect dead peers.\n# 2) Force network equipment in the middle to consider the connection to be\n#    alive.\n#\n# On Linux, the specified value (in seconds) is the period used to send ACKs.\n# Note that to close the connection the double of the time is needed.\n# On other kernels the period depends on the kernel configuration.\n#\n# A reasonable value for this option is 300 seconds, which is the new\n# Redis default starting with Redis 3.2.1.\ntcp-keepalive 300\n\n\n\n# GENERAL 通用\n\n\n# daemonize\n\n是否为后台进程，设置为 yes\n\n守护进程，后台启动\n\n# By default Redis does not run as a daemon. Use \'yes\' if you need it.\n# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.\n# When Redis is supervised by upstart or systemd, this parameter has no impact.\ndaemonize yes\n\n\n\n# pidfile\n\n存放pid文件的位置，每个实例会产生一个不同的pid文件\n\n# If a pid file is specified, Redis writes it where specified at startup\n# and removes it at exit.\n#\n# When the server runs non daemonized, no pid file is created if none is\n# specified in the configuration. When the server is daemonized, the pid file\n# is used even if not specified, defaulting to "/var/run/redis.pid".\n#\n# Creating a pid file is best effort: if Redis is not able to create it\n# nothing bad happens, the server will start and run normally.\n#\n# Note that on modern Linux systems "/run/redis.pid" is more conforming\n# and should be used instead.\npidfile /var/run/redis_6379.pid\n\n\n\n# loglevel\n\n指定日志记录级别，Redis总共支持四个级别： debug 、 verbose 、 notice 、 warning ，默认为 notice\n\n四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning\n\n# Specify the server verbosity level.\n# This can be one of:\n# debug (a lot of information, useful for development/testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged)\nloglevel notice\n\n\n\n# logfile\n\n日志文件名称\n\n# Specify the log file name. Also the empty string can be used to force\n# Redis to log on the standard output. Note that if you use standard\n# output for logging but daemonize, logs will be sent to /dev/null\nlogfile ""\n\n\n\n# databases\n\n设定库的数量 默认16，默认数据库为0，可以使用 SELECT <dbid> 命令在连接上指定数据库id\n\n# Set the number of databases. The default database is DB 0, you can select\n# a different one on a per-connection basis using SELECT <dbid> where\n# dbid is a number between 0 and \'databases\'-1\ndatabases 16\n\n\n\n# SECURITY 安全\n\n\n# 设置密码\n\n访问密码的查看、设置和取消\n\n在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。\n\n永久设置，需要再配置文件中进行设置。\n\n# IMPORTANT NOTE: starting with Redis 6 "requirepass" is just a compatibility\n# layer on top of the new ACL system. The option effect will be just setting\n# the password for the default user. Clients will still authenticate using\n# AUTH <password> as usually, or more explicitly with AUTH default <password>\n# if they follow the new protocol: both will work.\n#\n# The requirepass is not compatable with aclfile option and the ACL LOAD\n# command, these will cause requirepass to be ignored.\n#\n# requirepass foobared\n\n\n临时设置密码：\n\n127.0.0.1:6379> config get requirepass\n1) "requirepass"\n2) ""\n127.0.0.1:6379> config set requirepass "123456"\nOK\n127.0.0.1:6379> config get requirepass\n1) "requirepass"\n2) "123456"\n\n\n\n# LIMITS 限制\n\n\n# maxclients\n\n设置redis同时可以与多少个客户端进行连接，默认情况下为10000个客户端。\n\n如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。\n\n# Set the max number of connected clients at the same time. By default\n# this limit is set to 10000 clients, however if the Redis server is not\n# able to configure the process file limit to allow for the specified limit\n# the max number of allowed clients is set to the current file limit\n# minus 32 (as Redis reserves a few file descriptors for internal uses).\n#\n# Once the limit is reached Redis will close all the new connections sending\n# an error \'max number of clients reached\'.\n#\n# IMPORTANT: When Redis Cluster is used, the max number of connections is also\n# shared with the cluster bus: every node in the cluster will use two\n# connections, one incoming and another outgoing. It is important to size the\n# limit accordingly in case of very large clusters.\n#\n# maxclients 10000\n\n\n\n# maxmemory\n\n设置redis可以使用的内存量，一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定。\n\n建议设置，否则可能内存占满，造成服务器宕机。\n\n如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。\n\n但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果redis是主redis（说明redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在设置的是“不移除”的情况下，才不用考虑这个因素。\n\n# Set a memory usage limit to the specified amount of bytes.\n# When the memory limit is reached Redis will try to remove keys\n# according to the eviction policy selected (see maxmemory-policy).\n#\n# If Redis can\'t remove keys according to the policy, or if the policy is\n# set to \'noeviction\', Redis will start to reply with errors to commands\n# that would use more memory, like SET, LPUSH, and so on, and will continue\n# to reply to read-only commands like GET.\n#\n# This option is usually useful when using Redis as an LRU or LFU cache, or to\n# set a hard memory limit for an instance (using the \'noeviction\' policy).\n#\n# WARNING: If you have replicas attached to an instance with maxmemory on,\n# the size of the output buffers needed to feed the replicas are subtracted\n# from the used memory count, so that network problems / resyncs will\n# not trigger a loop where keys are evicted, and in turn the output\n# buffer of replicas is full with DELs of keys evicted triggering the deletion\n# of more keys, and so forth until the database is completely emptied.\n#\n# In short... if you have replicas attached it is suggested that you set a lower\n# limit for maxmemory so that there is some free RAM on the system for replica\n# output buffers (but this is not needed if the policy is \'noeviction\').\n#\n# maxmemory <bytes>\n\n\n\n# maxmemory-policy\n\n * volatile-lru ：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）\n * allkeys-lru ：在所有集合key中，使用LRU算法移除key\n * volatile-random ：在过期集合中移除随机的key，只对设置了过期时间的键\n * allkeys-random ：在所有集合key中，移除随机的key\n * volatile-ttl ：移除那些TTL值最小的key，即那些最近要过期的key\n * noeviction ：不进行移除，针对写操作，只是返回错误信息\n\n# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory\n# is reached. You can select one from the following behaviors:\n#\n# volatile-lru -> Evict using approximated LRU, only keys with an expire set.\n# allkeys-lru -> Evict any key using approximated LRU.\n# volatile-lfu -> Evict using approximated LFU, only keys with an expire set.\n# allkeys-lfu -> Evict any key using approximated LFU.\n# volatile-random -> Remove a random key having an expire set.\n# allkeys-random -> Remove a random key, any key.\n# volatile-ttl -> Remove the key with the nearest expire time (minor TTL)\n# noeviction -> Don\'t evict anything, just return an error on write operations.\n#\n# LRU means Least Recently Used\n# LFU means Least Frequently Used\n#\n# Both LRU, LFU and volatile-ttl are implemented using approximated\n# randomized algorithms.\n#\n# Note: with any of the above policies, when there are no suitable keys for\n# eviction, Redis will return an error on write operations that require\n# more memory. These are usually commands that create new keys, add data or\n# modify existing keys. A few examples are: SET, INCR, HSET, LPUSH, SUNIONSTORE,\n# SORT (due to the STORE argument), and EXEC (if the transaction includes any\n# command that requires memory).\n#\n# The default is:\n#\n# maxmemory-policy noeviction\n\n\n\n# maxmemory-samples\n\n设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。\n\n一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。\n\n# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated\n# algorithms (in order to save memory), so you can tune it for speed or\n# accuracy. By default Redis will check five keys and pick the one that was\n# used least recently, you can change the sample size using the following\n# configuration directive.\n#\n# The default of 5 produces good enough results. 10 Approximates very closely\n# true LRU but costs more CPU. 3 is faster but not very accurate.\n#\n# maxmemory-samples 5\n',normalizedContent:'# units 单位\n\n配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感。\n\n# redis configuration file example.\n#\n# note that in order to read the configuration file, redis must be\n# started with the file path as first argument:\n#\n# ./redis-server /path/to/redis.conf\n\n# note on units: when memory size is needed, it is possible to specify\n# it in the usual form of 1k 5gb 4m and so forth:\n#\n# 1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024 bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n#\n# units are case insensitive so 1gb 1gb 1gb are all the same.\n\n\n\n# includes 包含\n\n类似jsp中的include，多实例的情况可以把公用的配置文件提取出来\n\n################################## includes ###################################\n\n# include one or more other config files here.  this is useful if you\n# have a standard template that goes to all redis servers but also need\n# to customize a few per-server settings.  include files can include\n# other files, so use this wisely.\n#\n# note that option "include" won\'t be rewritten by command "config rewrite"\n# from admin or redis sentinel. since redis always uses the last processed\n# line as value of a configuration directive, you\'d better put includes\n# at the beginning of this file to avoid overwriting config change at runtime.\n#\n# if instead you are interested in using includes to override configuration\n# options, it is better to use include as the last line.\n#\n# include /path/to/local.conf\n# include /path/to/other.conf\n\n\n\n# network 网络相关配置\n\n\n# bind\n\n * 默认情况 bind=127.0.0.1 只能接受本机的访问请求\n * 不写的情况下，无限制接受任何ip地址的访问\n\n生产环境要写应用服务器的地址，服务器是需要远程访问的。\n\n> 如果开启了 protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，redis只允许接受本机的响应\n\n################################## network #####################################\n\n# by default, if no "bind" configuration directive is specified, redis listens\n# for connections from all available network interfaces on the host machine.\n# it is possible to listen to just one or multiple selected interfaces using\n# the "bind" configuration directive, followed by one or more ip addresses.\n# each address can be prefixed by "-", which means that redis will not fail to\n# start if the address is not available. being not available only refers to\n# addresses that does not correspond to any network interfece. addresses that\n# are already in use will always fail, and unsupported protocols will always be\n# silently skipped.\n#\n# examples:\n#\n# bind 192.168.1.100 10.0.0.1     # listens on two specific ipv4 addresses\n# bind 127.0.0.1 ::1              # listens on loopback ipv4 and ipv6\n# bind * -::*                     # like the default, all available interfaces\n#\n# ~~~ warning ~~~ if the computer running redis is directly exposed to the\n# internet, binding to all the interfaces is dangerous and will expose the\n# instance to everybody on the internet. so by default we uncomment the\n# following bind directive, that will force redis to listen only on the\n# ipv4 and ipv6 (if available) loopback interface addresses (this means redis\n# will only be able to accept client connections from the same host that it is\n# running on).\n#\n# if you are sure you want your instance to listen to all the interfaces\n# just comment out the following line.\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nbind 127.0.0.1 -::1\n\n\n\n\n\n# protected-mode\n\n本机访问保护模式，设置no\n\n# protected mode is a layer of security protection, in order to avoid that\n# redis instances left open on the internet are accessed and exploited.\n#\n# when protected mode is on and if:\n#\n# 1) the server is not binding explicitly to a set of addresses using the\n#    "bind" directive.\n# 2) no password is configured.\n#\t\n# the server only accepts connections from clients connecting from the\n# ipv4 and ipv6 loopback addresses 127.0.0.1 and ::1, and from unix domain\n# sockets.\n#\n# by default protected mode is enabled. you should disable it only if\n# you are sure you want clients from other hosts to connect to redis\n# even if no authentication is configured, nor a specific set of interfaces\n# are explicitly listed using the "bind" directive.\nprotected-mode no\n\n\n\n# port\n\n端口号，默认为6379\n\n# accept connections on the specified port, default is 6379 (iana #815344).\n# if port 0 is specified redis will not listen on a tcp socket.\nport 6379\n\n\n\n# tcp-backlog\n\n设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。\n\n在高并发环境下需要一个高backlog值来避免慢客户端连接问题。\n\n> linux内核会将这个值减小到 /proc/sys/net/core/somaxconn 的值（128），所以需要确认增大 /proc/sys/net/core/somaxconn 和 /proc/sys/net/ipv4/tcp_max_syn_backlog （128）两个值来达到想要的效果。\n\n# tcp listen() backlog.\n#\n# in high requests-per-second environments you need a high backlog in order\n# to avoid slow clients connection issues. note that the linux kernel\n# will silently truncate it to the value of /proc/sys/net/core/somaxconn so\n# make sure to raise both the value of somaxconn and tcp_max_syn_backlog\n# in order to get the desired effect.\ntcp-backlog 511\n\n\n\n# timeout\n\n一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。\n\n# close the connection after a client is idle for n seconds (0 to disable)\ntimeout 0\n\n\n\n# tcp-keepalive\n\n对访问客户端的一种心跳检测，每个n秒检测一次，单位为秒。\n\n如果设置为0，则不会进行keepalive检测。\n\n建议设置成60。\n\n# tcp keepalive.\n#\n# if non-zero, use so_keepalive to send tcp acks to clients in absence\n# of communication. this is useful for two reasons:\n#\n# 1) detect dead peers.\n# 2) force network equipment in the middle to consider the connection to be\n#    alive.\n#\n# on linux, the specified value (in seconds) is the period used to send acks.\n# note that to close the connection the double of the time is needed.\n# on other kernels the period depends on the kernel configuration.\n#\n# a reasonable value for this option is 300 seconds, which is the new\n# redis default starting with redis 3.2.1.\ntcp-keepalive 300\n\n\n\n# general 通用\n\n\n# daemonize\n\n是否为后台进程，设置为 yes\n\n守护进程，后台启动\n\n# by default redis does not run as a daemon. use \'yes\' if you need it.\n# note that redis will write a pid file in /var/run/redis.pid when daemonized.\n# when redis is supervised by upstart or systemd, this parameter has no impact.\ndaemonize yes\n\n\n\n# pidfile\n\n存放pid文件的位置，每个实例会产生一个不同的pid文件\n\n# if a pid file is specified, redis writes it where specified at startup\n# and removes it at exit.\n#\n# when the server runs non daemonized, no pid file is created if none is\n# specified in the configuration. when the server is daemonized, the pid file\n# is used even if not specified, defaulting to "/var/run/redis.pid".\n#\n# creating a pid file is best effort: if redis is not able to create it\n# nothing bad happens, the server will start and run normally.\n#\n# note that on modern linux systems "/run/redis.pid" is more conforming\n# and should be used instead.\npidfile /var/run/redis_6379.pid\n\n\n\n# loglevel\n\n指定日志记录级别，redis总共支持四个级别： debug 、 verbose 、 notice 、 warning ，默认为 notice\n\n四个级别根据使用阶段来选择，生产环境选择 notice 或者 warning\n\n# specify the server verbosity level.\n# this can be one of:\n# debug (a lot of information, useful for development/testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged)\nloglevel notice\n\n\n\n# logfile\n\n日志文件名称\n\n# specify the log file name. also the empty string can be used to force\n# redis to log on the standard output. note that if you use standard\n# output for logging but daemonize, logs will be sent to /dev/null\nlogfile ""\n\n\n\n# databases\n\n设定库的数量 默认16，默认数据库为0，可以使用 select <dbid> 命令在连接上指定数据库id\n\n# set the number of databases. the default database is db 0, you can select\n# a different one on a per-connection basis using select <dbid> where\n# dbid is a number between 0 and \'databases\'-1\ndatabases 16\n\n\n\n# security 安全\n\n\n# 设置密码\n\n访问密码的查看、设置和取消\n\n在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。\n\n永久设置，需要再配置文件中进行设置。\n\n# important note: starting with redis 6 "requirepass" is just a compatibility\n# layer on top of the new acl system. the option effect will be just setting\n# the password for the default user. clients will still authenticate using\n# auth <password> as usually, or more explicitly with auth default <password>\n# if they follow the new protocol: both will work.\n#\n# the requirepass is not compatable with aclfile option and the acl load\n# command, these will cause requirepass to be ignored.\n#\n# requirepass foobared\n\n\n临时设置密码：\n\n127.0.0.1:6379> config get requirepass\n1) "requirepass"\n2) ""\n127.0.0.1:6379> config set requirepass "123456"\nok\n127.0.0.1:6379> config get requirepass\n1) "requirepass"\n2) "123456"\n\n\n\n# limits 限制\n\n\n# maxclients\n\n设置redis同时可以与多少个客户端进行连接，默认情况下为10000个客户端。\n\n如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。\n\n# set the max number of connected clients at the same time. by default\n# this limit is set to 10000 clients, however if the redis server is not\n# able to configure the process file limit to allow for the specified limit\n# the max number of allowed clients is set to the current file limit\n# minus 32 (as redis reserves a few file descriptors for internal uses).\n#\n# once the limit is reached redis will close all the new connections sending\n# an error \'max number of clients reached\'.\n#\n# important: when redis cluster is used, the max number of connections is also\n# shared with the cluster bus: every node in the cluster will use two\n# connections, one incoming and another outgoing. it is important to size the\n# limit accordingly in case of very large clusters.\n#\n# maxclients 10000\n\n\n\n# maxmemory\n\n设置redis可以使用的内存量，一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定。\n\n建议设置，否则可能内存占满，造成服务器宕机。\n\n如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如set、lpush等。\n\n但是对于无内存申请的指令，仍然会正常响应，比如get等。如果redis是主redis（说明redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在设置的是“不移除”的情况下，才不用考虑这个因素。\n\n# set a memory usage limit to the specified amount of bytes.\n# when the memory limit is reached redis will try to remove keys\n# according to the eviction policy selected (see maxmemory-policy).\n#\n# if redis can\'t remove keys according to the policy, or if the policy is\n# set to \'noeviction\', redis will start to reply with errors to commands\n# that would use more memory, like set, lpush, and so on, and will continue\n# to reply to read-only commands like get.\n#\n# this option is usually useful when using redis as an lru or lfu cache, or to\n# set a hard memory limit for an instance (using the \'noeviction\' policy).\n#\n# warning: if you have replicas attached to an instance with maxmemory on,\n# the size of the output buffers needed to feed the replicas are subtracted\n# from the used memory count, so that network problems / resyncs will\n# not trigger a loop where keys are evicted, and in turn the output\n# buffer of replicas is full with dels of keys evicted triggering the deletion\n# of more keys, and so forth until the database is completely emptied.\n#\n# in short... if you have replicas attached it is suggested that you set a lower\n# limit for maxmemory so that there is some free ram on the system for replica\n# output buffers (but this is not needed if the policy is \'noeviction\').\n#\n# maxmemory <bytes>\n\n\n\n# maxmemory-policy\n\n * volatile-lru ：使用lru算法移除key，只对设置了过期时间的键；（最近最少使用）\n * allkeys-lru ：在所有集合key中，使用lru算法移除key\n * volatile-random ：在过期集合中移除随机的key，只对设置了过期时间的键\n * allkeys-random ：在所有集合key中，移除随机的key\n * volatile-ttl ：移除那些ttl值最小的key，即那些最近要过期的key\n * noeviction ：不进行移除，针对写操作，只是返回错误信息\n\n# maxmemory policy: how redis will select what to remove when maxmemory\n# is reached. you can select one from the following behaviors:\n#\n# volatile-lru -> evict using approximated lru, only keys with an expire set.\n# allkeys-lru -> evict any key using approximated lru.\n# volatile-lfu -> evict using approximated lfu, only keys with an expire set.\n# allkeys-lfu -> evict any key using approximated lfu.\n# volatile-random -> remove a random key having an expire set.\n# allkeys-random -> remove a random key, any key.\n# volatile-ttl -> remove the key with the nearest expire time (minor ttl)\n# noeviction -> don\'t evict anything, just return an error on write operations.\n#\n# lru means least recently used\n# lfu means least frequently used\n#\n# both lru, lfu and volatile-ttl are implemented using approximated\n# randomized algorithms.\n#\n# note: with any of the above policies, when there are no suitable keys for\n# eviction, redis will return an error on write operations that require\n# more memory. these are usually commands that create new keys, add data or\n# modify existing keys. a few examples are: set, incr, hset, lpush, sunionstore,\n# sort (due to the store argument), and exec (if the transaction includes any\n# command that requires memory).\n#\n# the default is:\n#\n# maxmemory-policy noeviction\n\n\n\n# maxmemory-samples\n\n设置样本数量，lru算法和最小ttl算法都并非是精确的算法，而是估算值，所以可以设置样本的大小，redis默认会检查这么多个key并选择其中lru的那个。\n\n一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。\n\n# lru, lfu and minimal ttl algorithms are not precise algorithms but approximated\n# algorithms (in order to save memory), so you can tune it for speed or\n# accuracy. by default redis will check five keys and pick the one that was\n# used least recently, you can change the sample size using the following\n# configuration directive.\n#\n# the default of 5 produces good enough results. 10 approximates very closely\n# true lru but costs more cpu. 3 is faster but not very accurate.\n#\n# maxmemory-samples 5\n',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"RabbitMQ介绍",frontmatter:{title:"RabbitMQ介绍",date:"2022-11-28T11:15:53.000Z",permalink:"/pages/vd45cpcf/",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/01.RabbitMQ%E4%BB%8B%E7%BB%8D.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/01.RabbitMQ介绍.md",key:"v-3fbbc302",path:"/pages/vd45cpcf/",headers:[{level:2,title:"RabbitMQ的概念",slug:"rabbitmq的概念",normalizedTitle:"rabbitmq的概念",charIndex:2},{level:2,title:"四大核心概念",slug:"四大核心概念",normalizedTitle:"四大核心概念",charIndex:181},{level:3,title:"1. 生产者",slug:"_1-生产者",normalizedTitle:"1. 生产者",charIndex:192},{level:3,title:"2. 交换机",slug:"_2-交换机",normalizedTitle:"2. 交换机",charIndex:217},{level:3,title:"3. 队列",slug:"_3-队列",normalizedTitle:"3. 队列",charIndex:348},{level:3,title:"4. 消费者",slug:"_4-消费者",normalizedTitle:"4. 消费者",charIndex:499},{level:2,title:"RabbitMQ特性",slug:"rabbitmq特性",normalizedTitle:"rabbitmq特性",charIndex:597},{level:2,title:"名词介绍",slug:"名词介绍",normalizedTitle:"名词介绍",charIndex:614}],excerpt:'<h2 id="rabbitmq的概念"><a class="header-anchor" href="#rabbitmq的概念">#</a> RabbitMQ的概念</h2>\n<p>RabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。</p>\n',headersStr:"RabbitMQ的概念 四大核心概念 1. 生产者 2. 交换机 3. 队列 4. 消费者 RabbitMQ特性 名词介绍",content:"# RabbitMQ的概念\n\nRabbitMQ 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。\n\n\n# 四大核心概念\n\n\n# 1. 生产者\n\n产生数据发送消息的程序。\n\n\n# 2. 交换机\n\n是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。\n\n\n# 3. 队列\n\n是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。\n\n\n# 4. 消费者\n\n消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\n\n\n# RabbitMQ特性\n\n\n\n\n# 名词介绍\n\n\n\n * Broker：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker。\n * Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。\n * Connection：publisher／consumer 和 broker 之间的 TCP 连接。\n * Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。\n * Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)\n * Queue：消息最终被送到这里等待 consumer 取走。\n * Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据。",normalizedContent:"# rabbitmq的概念\n\nrabbitmq 是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 rabbitmq 是 一个快递站，一个快递员帮你传递快件。rabbitmq 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。\n\n\n# 四大核心概念\n\n\n# 1. 生产者\n\n产生数据发送消息的程序。\n\n\n# 2. 交换机\n\n是 rabbitmq 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得有交换机类型决定。\n\n\n# 3. 队列\n\n是 rabbitmq 内部使用的一种数据结构，尽管消息流经 rabbitmq 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。\n\n\n# 4. 消费者\n\n消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\n\n\n# rabbitmq特性\n\n\n\n\n# 名词介绍\n\n\n\n * broker：接收和分发消息的应用，rabbitmq server 就是 message broker。\n * virtual host：出于多租户和安全因素设计的，把 amqp 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 rabbitmq server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等。\n * connection：publisher／consumer 和 broker 之间的 tcp 连接。\n * channel：如果每一次访问 rabbitmq 都建立一个 connection，在消息量大的时候建立 tcp connection 的开销将是巨大的，效率也较低。channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，amqp method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。channel 作为轻量级的 connection 极大减少了操作系统建立 tcp connection 的开销。\n * exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point)，topic (publish-subscribe) and fanout (multicast)\n * queue：消息最终被送到这里等待 consumer 取走。\n * binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据。",charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"RabbitMQ安装&常用命令",frontmatter:{title:"RabbitMQ安装&常用命令",date:"2022-11-29T15:04:09.000Z",permalink:"/pages/kr5yv2xa/",categories:["中间件","运维"],tags:["Linux","RabbitMQ","Docker"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/02.RabbitMQ%E5%AE%89%E8%A3%85&%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/02.RabbitMQ安装&常用命令.md",key:"v-39560dc6",path:"/pages/kr5yv2xa/",headers:[{level:2,title:"下载&安装",slug:"下载-安装",normalizedTitle:"下载&amp;安装",charIndex:null},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:291},{level:3,title:"添加开机启动 RabbitMQ 服务",slug:"添加开机启动-rabbitmq-服务",normalizedTitle:"添加开机启动 rabbitmq 服务",charIndex:300},{level:3,title:"启动服务",slug:"启动服务",normalizedTitle:"启动服务",charIndex:354},{level:3,title:"查看服务状态",slug:"查看服务状态",normalizedTitle:"查看服务状态",charIndex:401},{level:3,title:"停止服务",slug:"停止服务",normalizedTitle:"停止服务",charIndex:453},{level:3,title:"开启 web 管理插件",slug:"开启-web-管理插件",normalizedTitle:"开启 web 管理插件",charIndex:499},{level:4,title:"问题解决",slug:"问题解决",normalizedTitle:"问题解决",charIndex:653},{level:2,title:"设置权限",slug:"设置权限",normalizedTitle:"设置权限",charIndex:1159},{level:3,title:"创建账号",slug:"创建账号",normalizedTitle:"创建账号",charIndex:1225},{level:3,title:"设置用户角色",slug:"设置用户角色",normalizedTitle:"设置用户角色",charIndex:1266},{level:3,title:"设置用户权限",slug:"设置用户权限",normalizedTitle:"设置用户权限",charIndex:1332},{level:3,title:"查询用户和角色",slug:"查询用户和角色",normalizedTitle:"查询用户和角色",charIndex:1533},{level:3,title:"再次登录",slug:"再次登录",normalizedTitle:"再次登录",charIndex:1573},{level:3,title:"重置命令",slug:"重置命令",normalizedTitle:"重置命令",charIndex:1600},{level:4,title:"关闭应用",slug:"关闭应用",normalizedTitle:"关闭应用",charIndex:1608},{level:4,title:"清除",slug:"清除",normalizedTitle:"清除",charIndex:1639},{level:4,title:"重新启动",slug:"重新启动",normalizedTitle:"重新启动",charIndex:1665},{level:2,title:"Docker安装",slug:"docker安装",normalizedTitle:"docker安装",charIndex:1698}],headersStr:"下载&安装 常用命令 添加开机启动 RabbitMQ 服务 启动服务 查看服务状态 停止服务 开启 web 管理插件 问题解决 设置权限 创建账号 设置用户角色 设置用户权限 查询用户和角色 再次登录 重置命令 关闭应用 清除 重新启动 Docker安装",content:'# 下载&安装\n\n官方下载地址：https://www.rabbitmq.com/download.html\n\n在安装之前需要先安装Erlang环境\n\n\n\n上传到/usr/local/software目录下(如果没有 software 需要自己创建)，执行uname -a可以查看当前系统版本是el7，和下载的安装包是符合。\n\n\n\n安装命令，按顺序安装：\n\nrpm -ivh erlang-21.3-1.el7.x86_64.rpm\nyum install socat -y\nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n\n\n# 常用命令\n\n\n# 添加开机启动 RabbitMQ 服务\n\nchkconfig rabbitmq-server on\n\n\n\n# 启动服务\n\n/sbin/service rabbitmq-server start\n\n\n\n# 查看服务状态\n\n/sbin/service rabbitmq-server status\n\n\n\n\n\n# 停止服务\n\n/sbin/service rabbitmq-server stop\n\n\n\n# 开启 web 管理插件\n\n需要先停止rabbitmq服务，进入rabbitmq的安装目录，然后执行下面命令，再重新运行rabbitmq服务。\n\nrabbitmq-plugins enable rabbitmq_management\n\n\n开启服务后，进入web界面，地址是http://ip:15672\n\n# 问题解决\n\n如果进不去的话，可以看下防火墙有没有关掉。\n\n * 关闭防火墙：\n\nsystemctl stop firewalld.service\n\n\n * 查看防火墙状态：\n\nsystemctl status firewalld.service\n\n\n * 下次开机也关闭防火墙：\n\nsystemctl disable firewalld.service\n\n\n如果还是进不去，进入rabbitmq的安装目录的bin目录中执行命令：\n\n 1. 先查看rabbitmq的安装目录，可以先进入第一个文件夹中看看是否安装到该目录(看下该目录中是否有bin目录)\n\nwhereis rabbitmq\n\n\n\n\n 2. 进入安装目录后执行下面命令：\n\nrabbitmq-plugins enable rabbitmq_management\n\n\n 3. 执行后，重启rabbitmq服务（先停止，再启动，然后查看状态是否运行）：\n\n/sbin/service rabbitmq-server stop\n/sbin/service rabbitmq-server start\n\n\n 4. 此时进入web界面即可看到内容\n\n\n\n\n# 设置权限\n\n使用默认账号密码(guest)登录，会发现登录不上，该账号只支持本地登录，所以需要设置新的账号和设置权限。\n\n\n\n\n# 创建账号\n\nrabbitmqctl add_user 用户名 密码\n\n\n\n\n\n# 设置用户角色\n\nrabbitmqctl set_user_tags vh 用户名 权限(administrator)\n\n\n\n\n\n# 设置用户权限\n\nrabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\n\n# 案例：用户 admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限\nrabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"\n\n\n\n\n\n# 查询用户和角色\n\n rabbitmqctl list_users\n\n\n\n\n\n# 再次登录\n\n后续可以在web界面添加账户\n\n\n\n\n# 重置命令\n\n# 关闭应用\n\nrabbitmqctl stop_app\n\n\n# 清除\n\nrabbitmqctl reset\n\n\n# 重新启动\n\nrabbitmqctl start_app\n\n\n\n# Docker安装\n\n拉取镜像\n\ndocker pull rabbitmq:3-management\n\n\n创建并运行容器：\n\ndocker run \\\n -e RABBITMQ_DEFAULT_USER=admin \\\n -e RABBITMQ_DEFAULT_PASS=123123 \\\n --name mq \\\n --hostname mq1 \\\n -p 15672:15672 \\\n -p 5672:5672 \\\n -d \\\n rabbitmq:3-management\n',normalizedContent:'# 下载&安装\n\n官方下载地址：https://www.rabbitmq.com/download.html\n\n在安装之前需要先安装erlang环境\n\n\n\n上传到/usr/local/software目录下(如果没有 software 需要自己创建)，执行uname -a可以查看当前系统版本是el7，和下载的安装包是符合。\n\n\n\n安装命令，按顺序安装：\n\nrpm -ivh erlang-21.3-1.el7.x86_64.rpm\nyum install socat -y\nrpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n\n\n\n# 常用命令\n\n\n# 添加开机启动 rabbitmq 服务\n\nchkconfig rabbitmq-server on\n\n\n\n# 启动服务\n\n/sbin/service rabbitmq-server start\n\n\n\n# 查看服务状态\n\n/sbin/service rabbitmq-server status\n\n\n\n\n\n# 停止服务\n\n/sbin/service rabbitmq-server stop\n\n\n\n# 开启 web 管理插件\n\n需要先停止rabbitmq服务，进入rabbitmq的安装目录，然后执行下面命令，再重新运行rabbitmq服务。\n\nrabbitmq-plugins enable rabbitmq_management\n\n\n开启服务后，进入web界面，地址是http://ip:15672\n\n# 问题解决\n\n如果进不去的话，可以看下防火墙有没有关掉。\n\n * 关闭防火墙：\n\nsystemctl stop firewalld.service\n\n\n * 查看防火墙状态：\n\nsystemctl status firewalld.service\n\n\n * 下次开机也关闭防火墙：\n\nsystemctl disable firewalld.service\n\n\n如果还是进不去，进入rabbitmq的安装目录的bin目录中执行命令：\n\n 1. 先查看rabbitmq的安装目录，可以先进入第一个文件夹中看看是否安装到该目录(看下该目录中是否有bin目录)\n\nwhereis rabbitmq\n\n\n\n\n 2. 进入安装目录后执行下面命令：\n\nrabbitmq-plugins enable rabbitmq_management\n\n\n 3. 执行后，重启rabbitmq服务（先停止，再启动，然后查看状态是否运行）：\n\n/sbin/service rabbitmq-server stop\n/sbin/service rabbitmq-server start\n\n\n 4. 此时进入web界面即可看到内容\n\n\n\n\n# 设置权限\n\n使用默认账号密码(guest)登录，会发现登录不上，该账号只支持本地登录，所以需要设置新的账号和设置权限。\n\n\n\n\n# 创建账号\n\nrabbitmqctl add_user 用户名 密码\n\n\n\n\n\n# 设置用户角色\n\nrabbitmqctl set_user_tags vh 用户名 权限(administrator)\n\n\n\n\n\n# 设置用户权限\n\nrabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\n\n# 案例：用户 admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限\nrabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"\n\n\n\n\n\n# 查询用户和角色\n\n rabbitmqctl list_users\n\n\n\n\n\n# 再次登录\n\n后续可以在web界面添加账户\n\n\n\n\n# 重置命令\n\n# 关闭应用\n\nrabbitmqctl stop_app\n\n\n# 清除\n\nrabbitmqctl reset\n\n\n# 重新启动\n\nrabbitmqctl start_app\n\n\n\n# docker安装\n\n拉取镜像\n\ndocker pull rabbitmq:3-management\n\n\n创建并运行容器：\n\ndocker run \\\n -e rabbitmq_default_user=admin \\\n -e rabbitmq_default_pass=123123 \\\n --name mq \\\n --hostname mq1 \\\n -p 15672:15672 \\\n -p 5672:5672 \\\n -d \\\n rabbitmq:3-management\n',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"RabbitMQ入门程序",frontmatter:{title:"RabbitMQ入门程序",date:"2022-11-30T19:46:01.000Z",permalink:"/pages/hs9by9nl/",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/03.RabbitMQ%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/03.RabbitMQ入门程序.md",key:"v-01b3aea8",path:"/pages/hs9by9nl/",headers:[{level:2,title:"搭建环境",slug:"搭建环境",normalizedTitle:"搭建环境",charIndex:104},{level:2,title:"生产者：发消息",slug:"生产者-发消息",normalizedTitle:"生产者：发消息",charIndex:525},{level:2,title:"消费者：接收消息",slug:"消费者-接收消息",normalizedTitle:"消费者：接收消息",charIndex:1695}],excerpt:"<p>用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者。</p>\n",headersStr:"搭建环境 生产者：发消息 消费者：接收消息",content:'用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者。\n\n在下图中，“ P”是生产者，“ C”是消费者。中间的框是一个队列(RabbitMQ)代表使用者保留的消息缓冲区。\n\n\n\n\n# 搭建环境\n\n创建一个空的Maven工程。添加下面的依赖：\n\n<dependencies>\n\n    \x3c!--rabbitmq 依赖客户端--\x3e\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>5.8.0</version>\n    </dependency>\n\n    \x3c!--操作文件流的一个依赖--\x3e\n    <dependency>\n        <groupId>commons-io</groupId>\n        <artifactId>commons-io</artifactId>\n        <version>2.11.0</version>\n    </dependency>\n\n</dependencies>\n\n\n\n# 生产者：发消息\n\npublic class Producer {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        // 1. 创建一个连接工厂，并设置MQ的相关信息\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("192.168.182.130");\n        factory.setUsername("admin");\n        factory.setPassword("123123");\n\n        // 2. 创建连接\n        Connection connection = factory.newConnection();\n        // 3. 获取信道\n        Channel channel = connection.createChannel();\n        /* 4. 创建队列(入门程序，先不做交换机，有默认的交换机)\n         *     4.1 队列名称\n         *     4.2 队列里面的消息是否持久化 默认消息存储在内存中\n         *     4.3 该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费\n         *     4.4 是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除\n         *     4.5 其他参数\n         */\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        String message = "hello world";\n        /* 5. 发送一个消息\n         *     5.1 发送到那个交换机\n         *     5.2 路由的 key 是哪个\n         *     5.3 其他的参数信息\n         *     5.4 发送消息的消息体\n         */\n        channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n        System.out.println("消息发送完毕");\n    }\n}\n\n\n\n# 消费者：接收消息\n\npublic class Consumer {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        // 1. 创建一个连接工厂，并设置MQ的相关信息\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("192.168.182.130");\n        factory.setUsername("admin");\n        factory.setPassword("123123");\n\n        // 2. 创建连接\n        Connection connection = factory.newConnection();\n        // 3. 获取信道\n        Channel channel = connection.createChannel();\n        System.out.println("等待接收消息.........");\n\n        // 4. 接收消息，并交付消息\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        // 5. 取消消息时的回调，如在消费的时候队列被删除掉了\n        CancelCallback cancelCallback = (consumerTag) \n                -> System.out.println("消息消费被中断");\n\n        /*\n         * 6. 消费者消费消息\n         *     6.1 消费哪个队列\n         *     6.2 消费成功之后是否要自动应答(true:自动应答；false:手动应答)\n         *     6.3 消费者成功消费的回调\n         *     6.4 消费者取消消费的回调\n         */\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n}\n',normalizedContent:'用 java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者。\n\n在下图中，“ p”是生产者，“ c”是消费者。中间的框是一个队列(rabbitmq)代表使用者保留的消息缓冲区。\n\n\n\n\n# 搭建环境\n\n创建一个空的maven工程。添加下面的依赖：\n\n<dependencies>\n\n    \x3c!--rabbitmq 依赖客户端--\x3e\n    <dependency>\n        <groupid>com.rabbitmq</groupid>\n        <artifactid>amqp-client</artifactid>\n        <version>5.8.0</version>\n    </dependency>\n\n    \x3c!--操作文件流的一个依赖--\x3e\n    <dependency>\n        <groupid>commons-io</groupid>\n        <artifactid>commons-io</artifactid>\n        <version>2.11.0</version>\n    </dependency>\n\n</dependencies>\n\n\n\n# 生产者：发消息\n\npublic class producer {\n\n    // 队列的名称\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        // 1. 创建一个连接工厂，并设置mq的相关信息\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("192.168.182.130");\n        factory.setusername("admin");\n        factory.setpassword("123123");\n\n        // 2. 创建连接\n        connection connection = factory.newconnection();\n        // 3. 获取信道\n        channel channel = connection.createchannel();\n        /* 4. 创建队列(入门程序，先不做交换机，有默认的交换机)\n         *     4.1 队列名称\n         *     4.2 队列里面的消息是否持久化 默认消息存储在内存中\n         *     4.3 该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费\n         *     4.4 是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除\n         *     4.5 其他参数\n         */\n        channel.queuedeclare(queue_name, false, false, false, null);\n        string message = "hello world";\n        /* 5. 发送一个消息\n         *     5.1 发送到那个交换机\n         *     5.2 路由的 key 是哪个\n         *     5.3 其他的参数信息\n         *     5.4 发送消息的消息体\n         */\n        channel.basicpublish("", queue_name, null, message.getbytes());\n        system.out.println("消息发送完毕");\n    }\n}\n\n\n\n# 消费者：接收消息\n\npublic class consumer {\n\n    // 队列的名称\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        // 1. 创建一个连接工厂，并设置mq的相关信息\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("192.168.182.130");\n        factory.setusername("admin");\n        factory.setpassword("123123");\n\n        // 2. 创建连接\n        connection connection = factory.newconnection();\n        // 3. 获取信道\n        channel channel = connection.createchannel();\n        system.out.println("等待接收消息.........");\n\n        // 4. 接收消息，并交付消息\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody());\n            system.out.println(message);\n        };\n        // 5. 取消消息时的回调，如在消费的时候队列被删除掉了\n        cancelcallback cancelcallback = (consumertag) \n                -> system.out.println("消息消费被中断");\n\n        /*\n         * 6. 消费者消费消息\n         *     6.1 消费哪个队列\n         *     6.2 消费成功之后是否要自动应答(true:自动应答；false:手动应答)\n         *     6.3 消费者成功消费的回调\n         *     6.4 消费者取消消费的回调\n         */\n        channel.basicconsume(queue_name, true, delivercallback, cancelcallback);\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"Redis发布和订阅",frontmatter:{title:"Redis发布和订阅",date:"2022-12-11T15:52:40.000Z",permalink:"/pages/3a16c7g6",categories:["数据库"],tags:["Redis"],author:{name:"乔木先生"}},regularPath:"/03.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Redis/04.Redis%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85.html",relativePath:"03.数据库/02.Redis/04.Redis发布和订阅.md",key:"v-064b0f4d",path:"/pages/3a16c7g6/",headers:[{level:2,title:"发布订阅命令行实现",slug:"发布订阅命令行实现",normalizedTitle:"发布订阅命令行实现",charIndex:136}],excerpt:"<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>\n<p>Redis 客户端可以订阅任意数量的频道。</p>\n",headersStr:"发布订阅命令行实现",content:"Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。\n\nRedis 客户端可以订阅任意数量的频道。\n\n客户端可以订阅频道如下图：\n\n\n\n当给这个频道发布消息后，消息就会发送给订阅的客户端：\n\n\n\n\n# 发布订阅命令行实现\n\n 1. 打开一个客户端进行订阅\n\nsubscribe channel1\n\n\n\n\n 2. 打开另一个客户端，给channel1发布消息hello\n\n publish channel1 hello\n\n\n\n\n 3. 打开第一个客户端可以看到发送的消息\n\n\n\n> 如果发布的消息没有持久化，在订阅的客户端收不到hello，只能收到订阅后发布的消息",normalizedContent:"redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。\n\nredis 客户端可以订阅任意数量的频道。\n\n客户端可以订阅频道如下图：\n\n\n\n当给这个频道发布消息后，消息就会发送给订阅的客户端：\n\n\n\n\n# 发布订阅命令行实现\n\n 1. 打开一个客户端进行订阅\n\nsubscribe channel1\n\n\n\n\n 2. 打开另一个客户端，给channel1发布消息hello\n\n publish channel1 hello\n\n\n\n\n 3. 打开第一个客户端可以看到发送的消息\n\n\n\n> 如果发布的消息没有持久化，在订阅的客户端收不到hello，只能收到订阅后发布的消息",charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"RabbitMQ工作队列",frontmatter:{title:"RabbitMQ工作队列",date:"2022-12-01T10:56:02.000Z",permalink:"/pages/b2xtwkg7",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/04.RabbitMQ%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/04.RabbitMQ工作队列.md",key:"v-5ea527a0",path:"/pages/b2xtwkg7/",headers:[{level:2,title:"轮询分发消息",slug:"轮询分发消息",normalizedTitle:"轮询分发消息",charIndex:131},{level:3,title:"抽取工具类",slug:"抽取工具类",normalizedTitle:"抽取工具类",charIndex:199},{level:3,title:"启动两个工作线程",slug:"启动两个工作线程",normalizedTitle:"启动两个工作线程",charIndex:649},{level:3,title:"启动一个发送线程",slug:"启动一个发送线程",normalizedTitle:"启动一个发送线程",charIndex:1357},{level:2,title:"消息应答",slug:"消息应答",normalizedTitle:"消息应答",charIndex:1912},{level:3,title:"自动应答",slug:"自动应答",normalizedTitle:"自动应答",charIndex:2084},{level:3,title:"手动应答",slug:"手动应答",normalizedTitle:"手动应答",charIndex:2268},{level:4,title:"应答方法",slug:"应答方法",normalizedTitle:"应答方法",charIndex:2301},{level:4,title:"消息自动重新入队",slug:"消息自动重新入队",normalizedTitle:"消息自动重新入队",charIndex:2607},{level:4,title:"Demo",slug:"demo",normalizedTitle:"demo",charIndex:2770},{level:5,title:"生产者",slug:"生产者",normalizedTitle:"生产者",charIndex:2778},{level:5,title:"两个消费者",slug:"两个消费者",normalizedTitle:"两个消费者",charIndex:3331},{level:2,title:"持久化",slug:"持久化",normalizedTitle:"持久化",charIndex:5366},{level:3,title:"队列持久化",slug:"队列持久化",normalizedTitle:"队列持久化",charIndex:5514},{level:3,title:"消息持久化",slug:"消息持久化",normalizedTitle:"消息持久化",charIndex:5716},{level:2,title:"不公平分发",slug:"不公平分发",normalizedTitle:"不公平分发",charIndex:6726},{level:3,title:"预取值",slug:"预取值",normalizedTitle:"预取值",charIndex:7001}],excerpt:"<p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。</p>\n<p>相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>\n",headersStr:"轮询分发消息 抽取工具类 启动两个工作线程 启动一个发送线程 消息应答 自动应答 手动应答 应答方法 消息自动重新入队 Demo 生产者 两个消费者 持久化 队列持久化 消息持久化 不公平分发 预取值",content:'工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。\n\n相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n\n# 轮询分发消息\n\n启动一个消息发送线程，两个工作线程，需要保证一个消息只能被处理一次，不能处理多次，多个工作线程之前是竞争关系。\n\n\n# 抽取工具类\n\npublic class RabbitMqUtil {\n    public static Channel getChannel() throws Exception{\n        // 创建一个连接工厂，并设置MQ的相关信息\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("192.168.182.130");\n        factory.setUsername("admin");\n        factory.setPassword("123123");\n        // 创建连接\n        Connection connection = factory.newConnection();\n        // 获取信道\n        return connection.createChannel();\n    }\n}\n\n\n\n# 启动两个工作线程\n\npublic class Worker01 {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        System.out.println("线程02：等待接收消息.........");\n\n        // 1. 接收消息，并交付消息\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody());\n            System.out.println(message);\n        };\n        // 2. 取消消息时的回调\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n        // 3. 消费者消费消息\n        Channel channel = RabbitMqUtil.getChannel();\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n\n\n# 启动一个发送线程\n\npublic class Task01 {\n    // 队列的名称\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        // 创建队列\n        Channel channel = RabbitMqUtil.getChannel();\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        // 发送一个消息\n        for (int i = 0; i < 10; i++) {\n            String message = "第" + i + "条消息";\n            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            System.out.println("消息发送完毕：" + message);\n        }\n    }\n}\n\n\n\n# 消息应答\n\n消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，将丢失正在处理的消息。\n\n为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。\n\n\n# 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，如果消息在接收到之前，消费者出现连接或者 channel 关闭，消息就会丢失了。\n\n另一方面消费者没有对传递的消息数量进行限制，有可能接收太多来不及处理的消息，导致消息积压，使内存耗尽，最终被操作系统杀死，这种模式仅适用在消费者可以高效处理这些消息的情况下使用。\n\n\n# 手动应答\n\n手动应答的好处是可以批量应答并且减少网络拥堵。\n\n# 应答方法\n\nChannel类：\n\nbasicAck(long deliveryTag, boolean multiple)：用于肯定确认，告知RabbitMQ已经处理消息，可以将其丢弃。\n\n * multiple ：是否批量应答，如果设置为true，则会将信道中还未应答的消息应答。false只会应答指定的消息。\n\nbasicNack(long deliveryTag, boolean multiple, boolean requeue)：用于否定确认\n\nbasicReject(long deliveryTag, boolean requeue)：用于否定确认，不处理该消息了直接拒绝，可以将其丢弃了\n\n# 消息自动重新入队\n\n如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息 未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n\n\n\n# Demo\n\n# 生产者\n\npublic class Task02 {\n    // 队列的名称\n    private final static String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        // 创建队列\n        Channel channel = RabbitMqUtil.getChannel();\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        // 发送一个消息\n        for (int i = 0; i < 10; i++) {\n            String message = "第" + i + "条消息";\n            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            System.out.println("消息发送完毕：" + message);\n        }\n    }\n}\n\n\n# 两个消费者\n\npublic class Worker02 {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        System.out.println("线程02：等待接收消息.........");\n\n        boolean autoAck = false;\n        // 1. 接收消息，并交付消息，手动应答\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            SleepUtils.sleep(1);\n            String message = new String(delivery.getBody());\n            System.out.println("收到的消息：" + message);\n            // 手动应答：\n            // 参数1：消息标记的tag\n            // 参数2：是否批量应答\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n        // 2. 取消消息时的回调\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n        // 3. 消费者消费消息\n        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n    }\n}\n\n\npublic class Worker03 {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        System.out.println("线程03：等待接收消息.........");\n\n        boolean autoAck = false;\n        // 1. 接收消息，并交付消息，手动应答\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            SleepUtils.sleep(30);\n            String message = new String(delivery.getBody());\n            System.out.println("收到的消息：" + message);\n            // 手动应答：\n            // 参数1：消息标记的tag\n            // 参数2：是否批量应答\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n        // 2. 取消消息时的回调\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n        // 3. 消费者消费消息\n        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n    }\n}\n\n\n> 正常情况下消息发送方发送两个消息两个线程分别接收到消息并进行处理，但这里设置的是，一个线程处理的时间为1秒，另一个线程处理的时间为30秒。\n\n> 发送10条，线程1很快处理完消息，而线程2还没有处理，此时把线程2关掉(模拟宕机或异常)，消息会重新发给线程1，被线程1处理，就说明数据不会丢失。\n\n\n\n\n# 持久化\n\n上面是如何处理任务不丢失的情况，持久化可以保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。\n\n> 默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。\n\n确保消息不会丢失需要做两件事：将队列和消息都标记为持久化\n\n\n# 队列持久化\n\n之前创建的队列都是非持久化的，rabbitmq 如果重启的话，队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化。\n\n如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。\n\n\n\n非持久化队列和持久化队列在UI界面的区别：\n\n\n\n持久化队列后，即使重启 rabbitmq 队列也依然存在。\n\n\n# 消息持久化\n\n要想让消息实现持久化需要在消息生产者修改代码，MessageProperties.PERSISTENT_TEXT_PLAIN添加这个属性。\n\n将消息标记为持久化并不能完全保证不会丢失消息。尽管告诉 RabbitMQ 将消息保存到磁盘，依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。 此时并没有真正写入磁盘。持久性保证并不强，对于简单任务队列而言绰绰有余。如果需要更强有力的持久化策略，可以进行发布确认。\n\npublic class Task02 {\n    // 队列的名称\n    private final static String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        // 创建队列\n        Channel channel = RabbitMqUtil.getChannel();\n        // 队列持久化\n        boolean durable = true;\n        channel.queueDeclare(QUEUE_NAME, durable, false, false, null);\n        // 发送一个消息\n        for (int i = 0; i < 10; i++) {\n            String message = "第" + i + "条消息";\n            \n            // 消息持久化\n            channel.basicPublish("", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());\n            // 消息非持久化\n            // channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            \n            System.out.println("消息发送完毕：" + message);\n        }\n    }\n}\n\n\n\n# 不公平分发\n\nRabbitMQ分发消息采用的轮询分发，在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者1处理任务的速度非常快，而另外一个消费者2处理速度却很慢，这个时候采用轮询分发的话就会导致处理速度快的消费者很大一部分时间处于空闲状态，而处理慢的消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是RabbitMQ并不知道这种情况它依然很公平的进行分发。\n\n为了避免这种情况，可以设置参数channel.basicQos(1);\n\n> 只有手动应答的情况下，不公平分发才有效，传参都设置为1才是不公平分发，否则是预取值的模式分发。\n\npublic class Worker02 {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        System.out.println("线程02：等待接收消息.........");\n\n        boolean autoAck = false;\n        // 1. 接收消息，并交付消息，手动应答\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            SleepUtils.sleep(1);\n            String message = new String(delivery.getBody());\n            System.out.println("收到的消息：" + message);\n            // 手动应答\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n        // 2. 取消消息时的回调\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 设置不公平分发\n        int prefetchCount = 1;\n        channel.basicQos(prefetchCount);\n\n        // 3. 消费者消费消息\n        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n    }\n}\n\n\n如果这个任务还没有处理完或者还没有应答，先不分配任务，然后rabbitmq会把该任务分配给空闲消费者，如果所有的消费者都没有完成任务，队列还在添加新任务，有可能会遇到队列被撑满的情况，就只能添加新的 worker 或者改变其他存储任务的策略。\n\n\n# 预取值\n\n预取值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ将停止在通道上传递更多消息。\n\n> 例如，假设在通道上有未确认的消息[5, 6, 7, 8]，并且通道的预取值为 4 (channel.basicQos(4);)，此时RabbitMQ将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被确认。比方说tag=6这个消息刚刚被确认，RabbitMQ将会感知到这个情况并再发送一条消息。消息应答和Qos预取值对用户吞吐量有重大影响。\n\n增加预取值可以提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但已传递尚未处理的消息的数量也会增加，从而增加了消费者的RAM的消耗(随机存取存储器)，应该小心使用具有无限预处理的自动确认模式或手动确认模式 ，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大。\n\n找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同，100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\n\n预取值为 1 是最保守的，但吞吐量变得很低，特别是消费者连接延迟很严重或消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n发送线程： 发送15条消息\n\n消费线程： 处理消息时间1秒，预取值为2\n\npublic class Worker02 {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        System.out.println("线程02：等待接收消息.........");\n\n        // 接收并交付消息，手动应答\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            SleepUtils.sleep(1);\n            String message = new String(delivery.getBody());\n            System.out.println("收到的消息：" + message);\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n        // 取消消息时的回调\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 预取值\n        int prefetchCount = 2;\n        channel.basicQos(prefetchCount);\n\n        // 消费者消费消息\n        boolean autoAck = false;\n        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n    }\n}\n\n\n消费线程： 处理消息时间5秒，预取值为5\n\npublic class Worker03 {\n\n    // 队列的名称\n    private final static String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        System.out.println("线程03：等待接收消息.........");\n\n        // 接收并交付消息，手动应答\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            SleepUtils.sleep(5);\n            String message = new String(delivery.getBody());\n            System.out.println("收到的消息：" + message);\n            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n        };\n        // 取消消息时的回调\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 预取值\n        int prefetchCount = 5;\n        channel.basicQos(prefetchCount);\n\n        // 消费者消费消息\n        boolean autoAck = false;\n        channel.basicConsume(QUEUE_NAME, autoAck, deliverCallback, cancelCallback);\n    }\n}\n\n\n**发送线程： ** 发送15条消息\n\n消费线程： 处理消息时间1秒，预取值为2\n\n消费线程： 处理消息时间5秒，预取值为5\n\n刚发送消息的时候，线程02和线程03进行轮询，直到将线程02的预取值填满，满了之后会将线程03的预取值填满。都满了之后，线程02是空闲的会一直处理消息，当线程03处理完第一条消息后，会填充进来一条消息，然后又满了，又发现线程02是空闲的，又给线程02处理。\n\n',normalizedContent:'工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。\n\n相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\n\n\n# 轮询分发消息\n\n启动一个消息发送线程，两个工作线程，需要保证一个消息只能被处理一次，不能处理多次，多个工作线程之前是竞争关系。\n\n\n# 抽取工具类\n\npublic class rabbitmqutil {\n    public static channel getchannel() throws exception{\n        // 创建一个连接工厂，并设置mq的相关信息\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("192.168.182.130");\n        factory.setusername("admin");\n        factory.setpassword("123123");\n        // 创建连接\n        connection connection = factory.newconnection();\n        // 获取信道\n        return connection.createchannel();\n    }\n}\n\n\n\n# 启动两个工作线程\n\npublic class worker01 {\n\n    // 队列的名称\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        system.out.println("线程02：等待接收消息.........");\n\n        // 1. 接收消息，并交付消息\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody());\n            system.out.println(message);\n        };\n        // 2. 取消消息时的回调\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n        // 3. 消费者消费消息\n        channel channel = rabbitmqutil.getchannel();\n        channel.basicconsume(queue_name, true, delivercallback, cancelcallback);\n    }\n}\n\n\n\n\n# 启动一个发送线程\n\npublic class task01 {\n    // 队列的名称\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        // 创建队列\n        channel channel = rabbitmqutil.getchannel();\n        channel.queuedeclare(queue_name, false, false, false, null);\n        // 发送一个消息\n        for (int i = 0; i < 10; i++) {\n            string message = "第" + i + "条消息";\n            channel.basicpublish("", queue_name, null, message.getbytes());\n            system.out.println("消息发送完毕：" + message);\n        }\n    }\n}\n\n\n\n# 消息应答\n\n消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，将丢失正在处理的消息。\n\n为了保证消息在发送过程中不丢失，rabbitmq 引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。\n\n\n# 自动应答\n\n消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，如果消息在接收到之前，消费者出现连接或者 channel 关闭，消息就会丢失了。\n\n另一方面消费者没有对传递的消息数量进行限制，有可能接收太多来不及处理的消息，导致消息积压，使内存耗尽，最终被操作系统杀死，这种模式仅适用在消费者可以高效处理这些消息的情况下使用。\n\n\n# 手动应答\n\n手动应答的好处是可以批量应答并且减少网络拥堵。\n\n# 应答方法\n\nchannel类：\n\nbasicack(long deliverytag, boolean multiple)：用于肯定确认，告知rabbitmq已经处理消息，可以将其丢弃。\n\n * multiple ：是否批量应答，如果设置为true，则会将信道中还未应答的消息应答。false只会应答指定的消息。\n\nbasicnack(long deliverytag, boolean multiple, boolean requeue)：用于否定确认\n\nbasicreject(long deliverytag, boolean requeue)：用于否定确认，不处理该消息了直接拒绝，可以将其丢弃了\n\n# 消息自动重新入队\n\n如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 tcp 连接丢失)，导致消息 未发送 ack 确认，rabbitmq 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\n\n\n\n# demo\n\n# 生产者\n\npublic class task02 {\n    // 队列的名称\n    private final static string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        // 创建队列\n        channel channel = rabbitmqutil.getchannel();\n        channel.queuedeclare(queue_name, false, false, false, null);\n        // 发送一个消息\n        for (int i = 0; i < 10; i++) {\n            string message = "第" + i + "条消息";\n            channel.basicpublish("", queue_name, null, message.getbytes());\n            system.out.println("消息发送完毕：" + message);\n        }\n    }\n}\n\n\n# 两个消费者\n\npublic class worker02 {\n\n    // 队列的名称\n    private final static string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        system.out.println("线程02：等待接收消息.........");\n\n        boolean autoack = false;\n        // 1. 接收消息，并交付消息，手动应答\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            sleeputils.sleep(1);\n            string message = new string(delivery.getbody());\n            system.out.println("收到的消息：" + message);\n            // 手动应答：\n            // 参数1：消息标记的tag\n            // 参数2：是否批量应答\n            channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n        };\n        // 2. 取消消息时的回调\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n        // 3. 消费者消费消息\n        channel.basicconsume(queue_name, autoack, delivercallback, cancelcallback);\n    }\n}\n\n\npublic class worker03 {\n\n    // 队列的名称\n    private final static string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        system.out.println("线程03：等待接收消息.........");\n\n        boolean autoack = false;\n        // 1. 接收消息，并交付消息，手动应答\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            sleeputils.sleep(30);\n            string message = new string(delivery.getbody());\n            system.out.println("收到的消息：" + message);\n            // 手动应答：\n            // 参数1：消息标记的tag\n            // 参数2：是否批量应答\n            channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n        };\n        // 2. 取消消息时的回调\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n        // 3. 消费者消费消息\n        channel.basicconsume(queue_name, autoack, delivercallback, cancelcallback);\n    }\n}\n\n\n> 正常情况下消息发送方发送两个消息两个线程分别接收到消息并进行处理，但这里设置的是，一个线程处理的时间为1秒，另一个线程处理的时间为30秒。\n\n> 发送10条，线程1很快处理完消息，而线程2还没有处理，此时把线程2关掉(模拟宕机或异常)，消息会重新发给线程1，被线程1处理，就说明数据不会丢失。\n\n\n\n\n# 持久化\n\n上面是如何处理任务不丢失的情况，持久化可以保障当 rabbitmq 服务停掉以后消息生产者发送过来的消息不丢失。\n\n> 默认情况下 rabbitmq 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。\n\n确保消息不会丢失需要做两件事：将队列和消息都标记为持久化\n\n\n# 队列持久化\n\n之前创建的队列都是非持久化的，rabbitmq 如果重启的话，队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为持久化。\n\n如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。\n\n\n\n非持久化队列和持久化队列在ui界面的区别：\n\n\n\n持久化队列后，即使重启 rabbitmq 队列也依然存在。\n\n\n# 消息持久化\n\n要想让消息实现持久化需要在消息生产者修改代码，messageproperties.persistent_text_plain添加这个属性。\n\n将消息标记为持久化并不能完全保证不会丢失消息。尽管告诉 rabbitmq 将消息保存到磁盘，依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。 此时并没有真正写入磁盘。持久性保证并不强，对于简单任务队列而言绰绰有余。如果需要更强有力的持久化策略，可以进行发布确认。\n\npublic class task02 {\n    // 队列的名称\n    private final static string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        // 创建队列\n        channel channel = rabbitmqutil.getchannel();\n        // 队列持久化\n        boolean durable = true;\n        channel.queuedeclare(queue_name, durable, false, false, null);\n        // 发送一个消息\n        for (int i = 0; i < 10; i++) {\n            string message = "第" + i + "条消息";\n            \n            // 消息持久化\n            channel.basicpublish("", queue_name, messageproperties.persistent_text_plain, message.getbytes());\n            // 消息非持久化\n            // channel.basicpublish("", queue_name, null, message.getbytes());\n            \n            system.out.println("消息发送完毕：" + message);\n        }\n    }\n}\n\n\n\n# 不公平分发\n\nrabbitmq分发消息采用的轮询分发，在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者1处理任务的速度非常快，而另外一个消费者2处理速度却很慢，这个时候采用轮询分发的话就会导致处理速度快的消费者很大一部分时间处于空闲状态，而处理慢的消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是rabbitmq并不知道这种情况它依然很公平的进行分发。\n\n为了避免这种情况，可以设置参数channel.basicqos(1);\n\n> 只有手动应答的情况下，不公平分发才有效，传参都设置为1才是不公平分发，否则是预取值的模式分发。\n\npublic class worker02 {\n\n    // 队列的名称\n    private final static string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        system.out.println("线程02：等待接收消息.........");\n\n        boolean autoack = false;\n        // 1. 接收消息，并交付消息，手动应答\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            sleeputils.sleep(1);\n            string message = new string(delivery.getbody());\n            system.out.println("收到的消息：" + message);\n            // 手动应答\n            channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n        };\n        // 2. 取消消息时的回调\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 设置不公平分发\n        int prefetchcount = 1;\n        channel.basicqos(prefetchcount);\n\n        // 3. 消费者消费消息\n        channel.basicconsume(queue_name, autoack, delivercallback, cancelcallback);\n    }\n}\n\n\n如果这个任务还没有处理完或者还没有应答，先不分配任务，然后rabbitmq会把该任务分配给空闲消费者，如果所有的消费者都没有完成任务，队列还在添加新任务，有可能会遇到队列被撑满的情况，就只能添加新的 worker 或者改变其他存储任务的策略。\n\n\n# 预取值\n\n预取值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，rabbitmq将停止在通道上传递更多消息。\n\n> 例如，假设在通道上有未确认的消息[5, 6, 7, 8]，并且通道的预取值为 4 (channel.basicqos(4);)，此时rabbitmq将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被确认。比方说tag=6这个消息刚刚被确认，rabbitmq将会感知到这个情况并再发送一条消息。消息应答和qos预取值对用户吞吐量有重大影响。\n\n增加预取值可以提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但已传递尚未处理的消息的数量也会增加，从而增加了消费者的ram的消耗(随机存取存储器)，应该小心使用具有无限预处理的自动确认模式或手动确认模式 ，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大。\n\n找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同，100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。\n\n预取值为 1 是最保守的，但吞吐量变得很低，特别是消费者连接延迟很严重或消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。\n\n发送线程： 发送15条消息\n\n消费线程： 处理消息时间1秒，预取值为2\n\npublic class worker02 {\n\n    // 队列的名称\n    private final static string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        system.out.println("线程02：等待接收消息.........");\n\n        // 接收并交付消息，手动应答\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            sleeputils.sleep(1);\n            string message = new string(delivery.getbody());\n            system.out.println("收到的消息：" + message);\n            channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n        };\n        // 取消消息时的回调\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 预取值\n        int prefetchcount = 2;\n        channel.basicqos(prefetchcount);\n\n        // 消费者消费消息\n        boolean autoack = false;\n        channel.basicconsume(queue_name, autoack, delivercallback, cancelcallback);\n    }\n}\n\n\n消费线程： 处理消息时间5秒，预取值为5\n\npublic class worker03 {\n\n    // 队列的名称\n    private final static string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        system.out.println("线程03：等待接收消息.........");\n\n        // 接收并交付消息，手动应答\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            sleeputils.sleep(5);\n            string message = new string(delivery.getbody());\n            system.out.println("收到的消息：" + message);\n            channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n        };\n        // 取消消息时的回调\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 预取值\n        int prefetchcount = 5;\n        channel.basicqos(prefetchcount);\n\n        // 消费者消费消息\n        boolean autoack = false;\n        channel.basicconsume(queue_name, autoack, delivercallback, cancelcallback);\n    }\n}\n\n\n**发送线程： ** 发送15条消息\n\n消费线程： 处理消息时间1秒，预取值为2\n\n消费线程： 处理消息时间5秒，预取值为5\n\n刚发送消息的时候，线程02和线程03进行轮询，直到将线程02的预取值填满，满了之后会将线程03的预取值填满。都满了之后，线程02是空闲的会一直处理消息，当线程03处理完第一条消息后，会填充进来一条消息，然后又满了，又发现线程02是空闲的，又给线程02处理。\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"RabbitMQ发布确认",frontmatter:{title:"RabbitMQ发布确认",date:"2022-12-02T10:56:02.000Z",permalink:"/pages/hf5rpdk0",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/05.RabbitMQ%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/05.RabbitMQ发布确认.md",key:"v-09e33dd4",path:"/pages/hf5rpdk0/",headers:[{level:2,title:"开启发布确认",slug:"开启发布确认",normalizedTitle:"开启发布确认",charIndex:456},{level:2,title:"单个确认发布",slug:"单个确认发布",normalizedTitle:"单个确认发布",charIndex:856},{level:2,title:"批量确认发布",slug:"批量确认发布",normalizedTitle:"批量确认发布",charIndex:2005},{level:2,title:"异步确认发布",slug:"异步确认发布",normalizedTitle:"异步确认发布",charIndex:3367},{level:2,title:"发布确认速度对比",slug:"发布确认速度对比",normalizedTitle:"发布确认速度对比",charIndex:5695}],excerpt:"<p>生产者可以将信道设置成 confirm 模式，当信道进入 confirm 模式后，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了。</p>\n",headersStr:"开启发布确认 单个确认发布 批量确认发布 异步确认发布 发布确认速度对比",content:'生产者可以将信道设置成 confirm 模式，当信道进入 confirm 模式后，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了。\n\n如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\nconfirm 模式的好处是异步的，一旦发布一条消息，生产者就可以在信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n\n# 开启发布确认\n\n发布确认默认没有开启，如果要开启需要调用方法 confirmSelect，每当要使用发布确认，都要在 channel 上调用该方法。\n\n// 创建一个连接工厂，并设置MQ的相关信息\nConnectionFactory factory = new ConnectionFactory();\nfactory.setHost("192.168.182.130");\nfactory.setUsername("admin");\nfactory.setPassword("123123");\n// 创建连接\nConnection connection = factory.newConnection();\n// 获取信道\nChannel channel = connection.createChannel();\n// 开启发布确认\nchannel.confirmSelect();\n\n\n\n# 单个确认发布\n\n是一种同步确认发布的方式，发布一个消息被确认发布后，后续的消息才能继续发布。\n\nwaitForConfirmsOrDie(long)方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n\n这种确认方式有一个最大的缺点，发布速度特别的慢。\n\n因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。对于某些应用程序来说这可能已经足够了。\n\npublic class Task05 {\n    // 队列的名称\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        // 创建队列\n        Channel channel = RabbitMqUtil.getChannel();\n        // 开启发布确认\n        channel.confirmSelect();\n\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 计时\n        long startTime = System.currentTimeMillis();\n        // 发送消息\n        for (int i = 1; i <= 10000; i++) {\n            String message = "第" + i + "条消息";\n            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            // 服务端返回 false 或超时时间内未返回，生产者可以消息重发\n            boolean flag = channel.waitForConfirms();\n            if (flag) {\n                System.out.println("消息发送完毕：" + message);\n            }\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println("耗时：" + (endTime - startTime) + "毫秒");\n    }\n}\n\n\n\n\n\n# 批量确认发布\n\n上面的方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量。\n\n这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出了问题，必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。\n\n这种方案仍然是同步的，一样阻塞消息的发布。\n\npublic class Task05 {\n    // 队列的名称\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        // 创建队列\n        Channel channel = RabbitMqUtil.getChannel();\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 开启发布确认\n        channel.confirmSelect();\n        //批量确认消息大小\n        int batchSize = 100;\n        //未确认消息个数\n        int outstandingMessageCount = 0;\n\n        // 计时\n        long startTime = System.currentTimeMillis();\n        // 发送消息\n        for (int i = 1; i <= 10000; i++) {\n            String message = "第" + i + "条消息";\n            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            outstandingMessageCount++;\n            if (outstandingMessageCount == batchSize) {\n                channel.waitForConfirms();\n                outstandingMessageCount = 0;\n            }\n            System.out.println("消息发送完毕：" + message);\n        }\n        //为了确保还有剩余没有确认消息 再次确认\n        if (outstandingMessageCount > 0) {\n            channel.waitForConfirms();\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println("耗时：" + (endTime - startTime) + "毫秒");\n    }\n}\n\n\n\n\n\n# 异步确认发布\n\n异步确认利用回调函数来达到消息可靠性传递，也通过函数回调来保证投递成功。\n\n\n\n> 处理异步未确认消息： 最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n\npublic class Task0501 {\n    // 队列的名称\n    private final static String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        // 开启发布确认\n        channel.confirmSelect();\n        /* 线程安全有序的一个哈希表，适用于高并发的情况\n         * 1.轻松的将序号与消息进行关联\n         * 2.轻松批量删除条目 只要给到序列号\n         * 3.支持并发访问\n         */\n        ConcurrentSkipListMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();\n\n        /* 确认收到消息的一个回调\n         * 1.消息序列号\n         * 2.true 可以确认小于等于当前序列号的消息  false 确认当前序列号消息\n         */\n        ConfirmCallback ackCallback = (sequenceNumber, multiple) -> {\n            if (multiple) {\n                // 返回的是小于等于当前序列号的未确认消息 是一个 map\n                ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(sequenceNumber, true);\n                // 清除该部分未确认消息\n                confirmed.clear();\n            } else {\n                // 只清除当前序列号的消息\n                outstandingConfirms.remove(sequenceNumber);\n            }\n        };\n\n        ConfirmCallback nackCallback = (sequenceNumber, multiple) -> {\n            String message = outstandingConfirms.get(sequenceNumber);\n            System.out.println("发布的消息" + message + "未被确认，序列号" + sequenceNumber);\n        };\n\n        /* 添加一个异步确认的监听器\n         * 1.确认收到消息的回调\n         * 2.未收到消息的回调\n         */\n        channel.addConfirmListener(ackCallback, nackCallback);\n\n        // 计时\n        long startTime = System.currentTimeMillis();\n        // 发送消息\n        for (int i = 1; i <= 10000; i++) {\n            String message = "第" + i + "条消息";\n            /* channel.getNextPublishSeqNo()获取下一个消息的序列号\n             * 通过序列号与消息体进行一个关联\n             * 全部都是未确认的消息体\n             */\n            outstandingConfirms.put(channel.getNextPublishSeqNo(), message);\n            channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            System.out.println("消息发送完毕：" + message);\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println("耗时：" + (endTime - startTime) + "毫秒");\n    }\n}\n\n\n\n\n\n# 发布确认速度对比\n\n * 单独发布消息：同步等待确认，简单，但吞吐量非常有限。\n * 批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\n * 异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。',normalizedContent:'生产者可以将信道设置成 confirm 模式，当信道进入 confirm 模式后，所有在该信道上面发布的消息都将会被指派一个唯一的 id(从 1 开始)，消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 id)，这就使得生产者知道消息已经正确到达目的队列了。\n\n如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。\n\nconfirm 模式的好处是异步的，一旦发布一条消息，生产者就可以在信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者便可以通过回调方法来处理该确认消息，如果 rabbitmq 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。\n\n\n# 开启发布确认\n\n发布确认默认没有开启，如果要开启需要调用方法 confirmselect，每当要使用发布确认，都要在 channel 上调用该方法。\n\n// 创建一个连接工厂，并设置mq的相关信息\nconnectionfactory factory = new connectionfactory();\nfactory.sethost("192.168.182.130");\nfactory.setusername("admin");\nfactory.setpassword("123123");\n// 创建连接\nconnection connection = factory.newconnection();\n// 获取信道\nchannel channel = connection.createchannel();\n// 开启发布确认\nchannel.confirmselect();\n\n\n\n# 单个确认发布\n\n是一种同步确认发布的方式，发布一个消息被确认发布后，后续的消息才能继续发布。\n\nwaitforconfirmsordie(long)方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\n\n这种确认方式有一个最大的缺点，发布速度特别的慢。\n\n因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。对于某些应用程序来说这可能已经足够了。\n\npublic class task05 {\n    // 队列的名称\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        // 创建队列\n        channel channel = rabbitmqutil.getchannel();\n        // 开启发布确认\n        channel.confirmselect();\n\n        channel.queuedeclare(queue_name, false, false, false, null);\n\n        // 计时\n        long starttime = system.currenttimemillis();\n        // 发送消息\n        for (int i = 1; i <= 10000; i++) {\n            string message = "第" + i + "条消息";\n            channel.basicpublish("", queue_name, null, message.getbytes());\n            // 服务端返回 false 或超时时间内未返回，生产者可以消息重发\n            boolean flag = channel.waitforconfirms();\n            if (flag) {\n                system.out.println("消息发送完毕：" + message);\n            }\n        }\n        long endtime = system.currenttimemillis();\n        system.out.println("耗时：" + (endtime - starttime) + "毫秒");\n    }\n}\n\n\n\n\n\n# 批量确认发布\n\n上面的方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量。\n\n这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出了问题，必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。\n\n这种方案仍然是同步的，一样阻塞消息的发布。\n\npublic class task05 {\n    // 队列的名称\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        // 创建队列\n        channel channel = rabbitmqutil.getchannel();\n        channel.queuedeclare(queue_name, false, false, false, null);\n\n        // 开启发布确认\n        channel.confirmselect();\n        //批量确认消息大小\n        int batchsize = 100;\n        //未确认消息个数\n        int outstandingmessagecount = 0;\n\n        // 计时\n        long starttime = system.currenttimemillis();\n        // 发送消息\n        for (int i = 1; i <= 10000; i++) {\n            string message = "第" + i + "条消息";\n            channel.basicpublish("", queue_name, null, message.getbytes());\n            outstandingmessagecount++;\n            if (outstandingmessagecount == batchsize) {\n                channel.waitforconfirms();\n                outstandingmessagecount = 0;\n            }\n            system.out.println("消息发送完毕：" + message);\n        }\n        //为了确保还有剩余没有确认消息 再次确认\n        if (outstandingmessagecount > 0) {\n            channel.waitforconfirms();\n        }\n        long endtime = system.currenttimemillis();\n        system.out.println("耗时：" + (endtime - starttime) + "毫秒");\n    }\n}\n\n\n\n\n\n# 异步确认发布\n\n异步确认利用回调函数来达到消息可靠性传递，也通过函数回调来保证投递成功。\n\n\n\n> 处理异步未确认消息： 最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如用 concurrentlinkedqueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。\n\npublic class task0501 {\n    // 队列的名称\n    private final static string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建队列\n        channel.queuedeclare(queue_name, false, false, false, null);\n        // 开启发布确认\n        channel.confirmselect();\n        /* 线程安全有序的一个哈希表，适用于高并发的情况\n         * 1.轻松的将序号与消息进行关联\n         * 2.轻松批量删除条目 只要给到序列号\n         * 3.支持并发访问\n         */\n        concurrentskiplistmap<long, string> outstandingconfirms = new concurrentskiplistmap<>();\n\n        /* 确认收到消息的一个回调\n         * 1.消息序列号\n         * 2.true 可以确认小于等于当前序列号的消息  false 确认当前序列号消息\n         */\n        confirmcallback ackcallback = (sequencenumber, multiple) -> {\n            if (multiple) {\n                // 返回的是小于等于当前序列号的未确认消息 是一个 map\n                concurrentnavigablemap<long, string> confirmed = outstandingconfirms.headmap(sequencenumber, true);\n                // 清除该部分未确认消息\n                confirmed.clear();\n            } else {\n                // 只清除当前序列号的消息\n                outstandingconfirms.remove(sequencenumber);\n            }\n        };\n\n        confirmcallback nackcallback = (sequencenumber, multiple) -> {\n            string message = outstandingconfirms.get(sequencenumber);\n            system.out.println("发布的消息" + message + "未被确认，序列号" + sequencenumber);\n        };\n\n        /* 添加一个异步确认的监听器\n         * 1.确认收到消息的回调\n         * 2.未收到消息的回调\n         */\n        channel.addconfirmlistener(ackcallback, nackcallback);\n\n        // 计时\n        long starttime = system.currenttimemillis();\n        // 发送消息\n        for (int i = 1; i <= 10000; i++) {\n            string message = "第" + i + "条消息";\n            /* channel.getnextpublishseqno()获取下一个消息的序列号\n             * 通过序列号与消息体进行一个关联\n             * 全部都是未确认的消息体\n             */\n            outstandingconfirms.put(channel.getnextpublishseqno(), message);\n            channel.basicpublish("", queue_name, null, message.getbytes());\n            system.out.println("消息发送完毕：" + message);\n        }\n        long endtime = system.currenttimemillis();\n        system.out.println("耗时：" + (endtime - starttime) + "毫秒");\n    }\n}\n\n\n\n\n\n# 发布确认速度对比\n\n * 单独发布消息：同步等待确认，简单，但吞吐量非常有限。\n * 批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。\n * 异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"RabbitMQ交换机",frontmatter:{title:"RabbitMQ交换机",date:"2022-12-03T15:22:41.000Z",permalink:"/pages/umb37yap",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/06.RabbitMQ%E4%BA%A4%E6%8D%A2%E6%9C%BA.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/06.RabbitMQ交换机.md",key:"v-1efa53dd",path:"/pages/umb37yap/",headers:[{level:2,title:"Exchanges",slug:"exchanges",normalizedTitle:"exchanges",charIndex:191},{level:2,title:"默认exchange",slug:"默认exchange",normalizedTitle:"默认exchange",charIndex:460},{level:2,title:"临时队列",slug:"临时队列",normalizedTitle:"临时队列",charIndex:628},{level:2,title:"绑定(bindings)",slug:"绑定-bindings",normalizedTitle:"绑定(bindings)",charIndex:786},{level:2,title:"Fanout",slug:"fanout",normalizedTitle:"fanout",charIndex:862},{level:2,title:"Direct",slug:"direct",normalizedTitle:"direct",charIndex:3863},{level:2,title:"Topics",slug:"topics",normalizedTitle:"topics",charIndex:7877},{level:3,title:"匹配案例",slug:"匹配案例",normalizedTitle:"匹配案例",charIndex:8236}],excerpt:"<p>假设工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。而将消息传达给多个消费者，这种模式称为“发布/订阅”。</p>\n<blockquote>\n<p>例：构建一个简单的日志系统。它将由两个程序组成：第一个程序将发出日志消息，第二个程序是消费者。会启动两个消费者，一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。</p>\n</blockquote>\n",headersStr:"Exchanges 默认exchange 临时队列 绑定(bindings) Fanout Direct Topics 匹配案例",content:'假设工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。而将消息传达给多个消费者，这种模式称为“发布/订阅”。\n\n> 例：构建一个简单的日志系统。它将由两个程序组成：第一个程序将发出日志消息，第二个程序是消费者。会启动两个消费者，一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。\n\n\n# Exchanges\n\nRabbitMQ 消息传递模型的核心思想是：生产者生产的消息从不会直接发送到队列。\n\n通常生产者不知道消息传递到了哪些队列中，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，接收来自生产者的消息，并将它们推入队列。 交换机必须确切知道如何处理收到的消息。\n\n交换机的类型决定把消息放到特定队列，还是放到许多队列中，或者丢弃它们。\n\n\n\nExchanges 的类型：\n\n * 直接(direct)\n * 主题(topic)\n * 标题(headers)\n * 扇出(fanout)\n\n\n# 默认exchange\n\nchannel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n\n\n第一个参数是交换机的名称。空字符串表示默认或无名称交换机，消息能路由发送到队列中其实是由routingKey(bindingkey)绑定 key 指定的，如果它存在的话。\n\n\n# 临时队列\n\n当连接 RabbitMQ 时，需要一个全新的空队列，为此可以创建一个具有随机名称的队列，或者能让服务器随机生成队列名称。一旦断开了消费者连接，队列将被自动删除。\n\n创建临时队列：\n\nString queueName = channel.queueDeclare().getQueue();\n\n\n\n\n\n# 绑定(bindings)\n\n实是 exchange 和 queue 之间的桥梁，比如说下面这张图就是 X 与 Q1 和 Q2 进行了绑定：\n\n\n\n\n# Fanout\n\nFanout 类型非常简单。将接收到的所有消息广播到它知道的所有队列中。\n\n系统中默认有些Fanout类型的exchange：\n\n\n\n案例：\n\n消费者：将接收到的消息打印在控制台\n\npublic class Worker0601 {\n\n    private static final String EXCHANGE_NAME = "logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");\n        // 生成一个临时队列，名称随机，当消费者与队列断开连接时，该队列对自动删除\n        String queueName = channel.queueDeclare().getQueue();\n        // 将交换机和随机队列绑定，routingKey也就是bindingKey为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, "");\n\n        System.out.println("等待接收消息，该队列会将收到的消息打印出来....");\n\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            System.out.println("收到的消息：" + message);\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n消费者：将接收到的消息存储在磁盘\n\npublic class Worker0602 {\n\n    private static final String EXCHANGE_NAME = "logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");\n        // 生成一个临时队列，名称随机，当消费者与队列断开连接时，该队列对自动删除\n        String queueName = channel.queueDeclare().getQueue();\n        // 将交换机和随机队列绑定，routingKey也就是bindingKey为空字符串\n        channel.queueBind(queueName, EXCHANGE_NAME, "");\n\n        System.out.println("等待接收消息，该队列会将收到的消息写入文件....");\n\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            File file = new File("D:\\\\rabbitmq_info.txt");\n            BufferedWriter bw = new BufferedWriter(new FileWriter(file, true));\n            bw.write(message);\n            bw.newLine();\n            bw.close();\n            System.out.println("数据写入文件成功");\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n生产者：发送消息给两个消费者接收\n\npublic class Task0601 {\n    private static final String EXCHANGE_NAME = "logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangeDeclare(EXCHANGE_NAME, "fanout");\n\n        Scanner sc = new Scanner(System.in);\n        System.out.println("请输入信息：");\n        while (sc.hasNext()) {\n            String message = sc.nextLine();\n            channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes("UTF-8"));\n            System.out.println("生产者发出消息" + message);\n        }\n    }\n}\n\n\n\n# Direct\n\n对于上面的案例，希望将日志消息写入磁盘的程序仅写入严重错误(errros)，而不存储警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 交换类型只能进行无意识的广播，所以这里使用 direct 类型来进行替换，它工作方式是，消息只去到它绑定的routingKey 队列中去。\n\n\n\n在上面这张图中，可以看到 X 绑定了两个队列，绑定类型是 direct。队列Q1 绑定键为 orange，队列 Q2 绑定键有两个，一个绑定键为 black，另一个绑定键为 green。\n\n在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列Q1。绑定键为black和green的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。\n\n多重绑定：\n\n\n\n当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。\n\n案例：\n\n\n\n消息发送者：\n\npublic class Task0701 {\n    private static final String EXCHANGE_NAME = "direct_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n\n        Map<String, String>  bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put("info","普通 info 信息");\n        bindingKeyMap.put("warning","警告 warning 信息");\n        bindingKeyMap.put("error","错误 error 信息");\n        // debug 没有消费这接收这个消息 所有就丢失了\n        bindingKeyMap.put("debug","调试 debug 信息");\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(StandardCharsets.UTF_8));\n            System.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n消息接收者：\n\npublic class Worker0701 {\n\n    private static final String EXCHANGE_NAME = "direct_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n        // 声明一个队列\n        String queueName = "console";\n        channel.queueDeclare(queueName, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "info");\n        channel.queueBind(queueName, EXCHANGE_NAME, "warning");\n\n        System.out.println("等待接收消息，该队列会将收到的消息打印出来....");\n\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            message = "接收绑定键：" + delivery.getEnvelope().getRoutingKey() + "，消息：" + message;\n            System.out.println(message);\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n消息接收者：\n\npublic class Worker0702 {\n\n    private static final String EXCHANGE_NAME = "direct_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n        // 声明一个队列\n        String queueName = "disk";\n        channel.queueDeclare(queueName, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "error");\n\n        System.out.println("等待接收消息，该队列会将收到的消息写入文件....");\n\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            message = "接收绑定键：" + delivery.getEnvelope().getRoutingKey() + "，消息：" + message;\n            File file = new File("D:\\\\rabbitmq_info.txt");\n            BufferedWriter bw = new BufferedWriter(new FileWriter(file, true));\n            bw.write(message);\n            bw.newLine();\n            bw.close();\n            System.out.println("错误日志写入文件成功");\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n\n# Topics\n\n尽管使用direct交换机改进了日志系统，仍然存在局限性，比如想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型。\n\n发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说："stock.usd.nyse", "nyse.vmw", "quick.orange.rabbit"这种类型的。当然这个单词列表最多不能超过 255 个字节。\n\n在这个规则列表中，有两个替换符：\n\n * *(星号)可以代替一个单词\n * #(井号)可以替代零个或多个单词\n\n\n# 匹配案例\n\n下图绑定关系如下：\n\n * Q1--\x3e绑定的是中间带 orange 带 3 个单词的字符串(*.orange.*)\n * Q2--\x3e绑定的是最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)，第一个单词是 lazy 的多个单词(lazy.#)\n\n\n\n上图是一个队列绑定关系图，他们之间数据接收情况：\n\n * quick.orange.rabbit：被队列 Q1Q2 接收到\n * lazy.orange.elephant：被队列 Q1Q2 接收到\n * quick.orange.fox：被队列 Q1 接收到\n * lazy.brown.fox：被队列 Q2 接收到\n * lazy.pink.rabbit：虽然满足两个绑定但只被队列 Q2 接收一次\n * quick.brown.fox：不匹配任何绑定不会被任何队列接收到会被丢弃\n * quick.orange.male.rabbit：是四个单词不匹配任何绑定会被丢弃\n * lazy.orange.male.rabbit：是四个单词但匹配 Q2\n\n当队列绑定关系是下列这种情况时需要引起注意\n\n * 当一个队列绑定键是#，这个队列将接收所有数据，像 fanout\n * 如果队列绑定键当中没有#和*出现，该队列绑定类型就是 direct\n\n案例：\n\n消息发送者：\n\npublic class Task0801 {\n    private static final String EXCHANGE_NAME = "topic_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n\n        Map<String, String> bindingKeyMap = new HashMap<>();\n        bindingKeyMap.put("quick.orange.rabbit", "被队列 Q1Q2 接收到");\n        bindingKeyMap.put("lazy.orange.elephant", "被队列 Q1Q2 接收到");\n        bindingKeyMap.put("quick.orange.fox", "被队列 Q1 接收到");\n        bindingKeyMap.put("lazy.brown.fox", "被队列 Q2 接收到");\n        bindingKeyMap.put("lazy.pink.rabbit", "虽然满足两个绑定但只被队列 Q2 接收一次");\n        bindingKeyMap.put("quick.brown.fox", "不匹配任何绑定不会被任何队列接收到会被丢弃");\n        bindingKeyMap.put("quick.orange.male.rabbit", "是四个单词不匹配任何绑定会被丢弃");\n        bindingKeyMap.put("lazy.orange.male.rabbit", "是四个单词但匹配 Q2");\n\n        for (Map.Entry<String, String> bindingKeyEntry : bindingKeyMap.entrySet()) {\n            String bindingKey = bindingKeyEntry.getKey();\n            String message = bindingKeyEntry.getValue();\n            channel.basicPublish(EXCHANGE_NAME, bindingKey, null, message.getBytes(StandardCharsets.UTF_8));\n            System.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n消息接收者：\n\npublic class Worker0801 {\n\n    private static final String EXCHANGE_NAME = "topic_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        // 声明一个队列\n        String queueName = "Q1";\n        channel.queueDeclare(queueName, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "*.orange.*");\n\n        System.out.println("Q1等待接收消息....");\n\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            message = "接收绑定键：" + delivery.getEnvelope().getRoutingKey() + "，消息：" + message;\n            System.out.println(message);\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n消息接收者：\n\npublic class Worker0802 {\n\n    private static final String EXCHANGE_NAME = "topic_logs";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        // 声明一个队列\n        String queueName = "Q2";\n        channel.queueDeclare(queueName, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queueBind(queueName, EXCHANGE_NAME, "*.*.rabbit");\n        channel.queueBind(queueName, EXCHANGE_NAME, "lazy.#");\n\n        System.out.println("Q2等待接收消息....");\n\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            message = "接收绑定键：" + delivery.getEnvelope().getRoutingKey() + "，消息：" + message;\n            System.out.println(message);\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(queueName, true, deliverCallback, cancelCallback);\n    }\n}\n',normalizedContent:'假设工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。而将消息传达给多个消费者，这种模式称为“发布/订阅”。\n\n> 例：构建一个简单的日志系统。它将由两个程序组成：第一个程序将发出日志消息，第二个程序是消费者。会启动两个消费者，一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。\n\n\n# exchanges\n\nrabbitmq 消息传递模型的核心思想是：生产者生产的消息从不会直接发送到队列。\n\n通常生产者不知道消息传递到了哪些队列中，生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，接收来自生产者的消息，并将它们推入队列。 交换机必须确切知道如何处理收到的消息。\n\n交换机的类型决定把消息放到特定队列，还是放到许多队列中，或者丢弃它们。\n\n\n\nexchanges 的类型：\n\n * 直接(direct)\n * 主题(topic)\n * 标题(headers)\n * 扇出(fanout)\n\n\n# 默认exchange\n\nchannel.basicpublish("", queue_name, null, message.getbytes());\n\n\n第一个参数是交换机的名称。空字符串表示默认或无名称交换机，消息能路由发送到队列中其实是由routingkey(bindingkey)绑定 key 指定的，如果它存在的话。\n\n\n# 临时队列\n\n当连接 rabbitmq 时，需要一个全新的空队列，为此可以创建一个具有随机名称的队列，或者能让服务器随机生成队列名称。一旦断开了消费者连接，队列将被自动删除。\n\n创建临时队列：\n\nstring queuename = channel.queuedeclare().getqueue();\n\n\n\n\n\n# 绑定(bindings)\n\n实是 exchange 和 queue 之间的桥梁，比如说下面这张图就是 x 与 q1 和 q2 进行了绑定：\n\n\n\n\n# fanout\n\nfanout 类型非常简单。将接收到的所有消息广播到它知道的所有队列中。\n\n系统中默认有些fanout类型的exchange：\n\n\n\n案例：\n\n消费者：将接收到的消息打印在控制台\n\npublic class worker0601 {\n\n    private static final string exchange_name = "logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangedeclare(exchange_name, "fanout");\n        // 生成一个临时队列，名称随机，当消费者与队列断开连接时，该队列对自动删除\n        string queuename = channel.queuedeclare().getqueue();\n        // 将交换机和随机队列绑定，routingkey也就是bindingkey为空字符串\n        channel.queuebind(queuename, exchange_name, "");\n\n        system.out.println("等待接收消息，该队列会将收到的消息打印出来....");\n\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            system.out.println("收到的消息：" + message);\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(queuename, true, delivercallback, cancelcallback);\n    }\n}\n\n\n消费者：将接收到的消息存储在磁盘\n\npublic class worker0602 {\n\n    private static final string exchange_name = "logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangedeclare(exchange_name, "fanout");\n        // 生成一个临时队列，名称随机，当消费者与队列断开连接时，该队列对自动删除\n        string queuename = channel.queuedeclare().getqueue();\n        // 将交换机和随机队列绑定，routingkey也就是bindingkey为空字符串\n        channel.queuebind(queuename, exchange_name, "");\n\n        system.out.println("等待接收消息，该队列会将收到的消息写入文件....");\n\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            file file = new file("d:\\\\rabbitmq_info.txt");\n            bufferedwriter bw = new bufferedwriter(new filewriter(file, true));\n            bw.write(message);\n            bw.newline();\n            bw.close();\n            system.out.println("数据写入文件成功");\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(queuename, true, delivercallback, cancelcallback);\n    }\n}\n\n\n生产者：发送消息给两个消费者接收\n\npublic class task0601 {\n    private static final string exchange_name = "logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangedeclare(exchange_name, "fanout");\n\n        scanner sc = new scanner(system.in);\n        system.out.println("请输入信息：");\n        while (sc.hasnext()) {\n            string message = sc.nextline();\n            channel.basicpublish(exchange_name, "", null, message.getbytes("utf-8"));\n            system.out.println("生产者发出消息" + message);\n        }\n    }\n}\n\n\n\n# direct\n\n对于上面的案例，希望将日志消息写入磁盘的程序仅写入严重错误(errros)，而不存储警告(warning)或信息(info)日志 消息避免浪费磁盘空间。fanout 交换类型只能进行无意识的广播，所以这里使用 direct 类型来进行替换，它工作方式是，消息只去到它绑定的routingkey 队列中去。\n\n\n\n在上面这张图中，可以看到 x 绑定了两个队列，绑定类型是 direct。队列q1 绑定键为 orange，队列 q2 绑定键有两个，一个绑定键为 black，另一个绑定键为 green。\n\n在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列q1。绑定键为black和green的消息会被发布到队列 q2，其他消息类型的消息将被丢弃。\n\n多重绑定：\n\n\n\n当然如果 exchange 的绑定类型是direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。\n\n案例：\n\n\n\n消息发送者：\n\npublic class task0701 {\n    private static final string exchange_name = "direct_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机\n        channel.exchangedeclare(exchange_name, builtinexchangetype.direct);\n\n        map<string, string>  bindingkeymap = new hashmap<>();\n        bindingkeymap.put("info","普通 info 信息");\n        bindingkeymap.put("warning","警告 warning 信息");\n        bindingkeymap.put("error","错误 error 信息");\n        // debug 没有消费这接收这个消息 所有就丢失了\n        bindingkeymap.put("debug","调试 debug 信息");\n        for (map.entry<string, string> bindingkeyentry : bindingkeymap.entryset()) {\n            string bindingkey = bindingkeyentry.getkey();\n            string message = bindingkeyentry.getvalue();\n            channel.basicpublish(exchange_name, bindingkey, null, message.getbytes(standardcharsets.utf_8));\n            system.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n消息接收者：\n\npublic class worker0701 {\n\n    private static final string exchange_name = "direct_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangedeclare(exchange_name, builtinexchangetype.direct);\n        // 声明一个队列\n        string queuename = "console";\n        channel.queuedeclare(queuename, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queuebind(queuename, exchange_name, "info");\n        channel.queuebind(queuename, exchange_name, "warning");\n\n        system.out.println("等待接收消息，该队列会将收到的消息打印出来....");\n\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            message = "接收绑定键：" + delivery.getenvelope().getroutingkey() + "，消息：" + message;\n            system.out.println(message);\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(queuename, true, delivercallback, cancelcallback);\n    }\n}\n\n\n消息接收者：\n\npublic class worker0702 {\n\n    private static final string exchange_name = "direct_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangedeclare(exchange_name, builtinexchangetype.direct);\n        // 声明一个队列\n        string queuename = "disk";\n        channel.queuedeclare(queuename, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queuebind(queuename, exchange_name, "error");\n\n        system.out.println("等待接收消息，该队列会将收到的消息写入文件....");\n\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            message = "接收绑定键：" + delivery.getenvelope().getroutingkey() + "，消息：" + message;\n            file file = new file("d:\\\\rabbitmq_info.txt");\n            bufferedwriter bw = new bufferedwriter(new filewriter(file, true));\n            bw.write(message);\n            bw.newline();\n            bw.close();\n            system.out.println("错误日志写入文件成功");\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(queuename, true, delivercallback, cancelcallback);\n    }\n}\n\n\n\n# topics\n\n尽管使用direct交换机改进了日志系统，仍然存在局限性，比如想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候direct 就办不到了。这个时候就只能使用 topic 类型。\n\n发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说："stock.usd.nyse", "nyse.vmw", "quick.orange.rabbit"这种类型的。当然这个单词列表最多不能超过 255 个字节。\n\n在这个规则列表中，有两个替换符：\n\n * *(星号)可以代替一个单词\n * #(井号)可以替代零个或多个单词\n\n\n# 匹配案例\n\n下图绑定关系如下：\n\n * q1--\x3e绑定的是中间带 orange 带 3 个单词的字符串(*.orange.*)\n * q2--\x3e绑定的是最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)，第一个单词是 lazy 的多个单词(lazy.#)\n\n\n\n上图是一个队列绑定关系图，他们之间数据接收情况：\n\n * quick.orange.rabbit：被队列 q1q2 接收到\n * lazy.orange.elephant：被队列 q1q2 接收到\n * quick.orange.fox：被队列 q1 接收到\n * lazy.brown.fox：被队列 q2 接收到\n * lazy.pink.rabbit：虽然满足两个绑定但只被队列 q2 接收一次\n * quick.brown.fox：不匹配任何绑定不会被任何队列接收到会被丢弃\n * quick.orange.male.rabbit：是四个单词不匹配任何绑定会被丢弃\n * lazy.orange.male.rabbit：是四个单词但匹配 q2\n\n当队列绑定关系是下列这种情况时需要引起注意\n\n * 当一个队列绑定键是#，这个队列将接收所有数据，像 fanout\n * 如果队列绑定键当中没有#和*出现，该队列绑定类型就是 direct\n\n案例：\n\n消息发送者：\n\npublic class task0801 {\n    private static final string exchange_name = "topic_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机\n        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n\n        map<string, string> bindingkeymap = new hashmap<>();\n        bindingkeymap.put("quick.orange.rabbit", "被队列 q1q2 接收到");\n        bindingkeymap.put("lazy.orange.elephant", "被队列 q1q2 接收到");\n        bindingkeymap.put("quick.orange.fox", "被队列 q1 接收到");\n        bindingkeymap.put("lazy.brown.fox", "被队列 q2 接收到");\n        bindingkeymap.put("lazy.pink.rabbit", "虽然满足两个绑定但只被队列 q2 接收一次");\n        bindingkeymap.put("quick.brown.fox", "不匹配任何绑定不会被任何队列接收到会被丢弃");\n        bindingkeymap.put("quick.orange.male.rabbit", "是四个单词不匹配任何绑定会被丢弃");\n        bindingkeymap.put("lazy.orange.male.rabbit", "是四个单词但匹配 q2");\n\n        for (map.entry<string, string> bindingkeyentry : bindingkeymap.entryset()) {\n            string bindingkey = bindingkeyentry.getkey();\n            string message = bindingkeyentry.getvalue();\n            channel.basicpublish(exchange_name, bindingkey, null, message.getbytes(standardcharsets.utf_8));\n            system.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n消息接收者：\n\npublic class worker0801 {\n\n    private static final string exchange_name = "topic_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n        // 声明一个队列\n        string queuename = "q1";\n        channel.queuedeclare(queuename, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queuebind(queuename, exchange_name, "*.orange.*");\n\n        system.out.println("q1等待接收消息....");\n\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            message = "接收绑定键：" + delivery.getenvelope().getroutingkey() + "，消息：" + message;\n            system.out.println(message);\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(queuename, true, delivercallback, cancelcallback);\n    }\n}\n\n\n消息接收者：\n\npublic class worker0802 {\n\n    private static final string exchange_name = "topic_logs";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机，交换机的名字为logs\n        channel.exchangedeclare(exchange_name, builtinexchangetype.topic);\n        // 声明一个队列\n        string queuename = "q2";\n        channel.queuedeclare(queuename, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queuebind(queuename, exchange_name, "*.*.rabbit");\n        channel.queuebind(queuename, exchange_name, "lazy.#");\n\n        system.out.println("q2等待接收消息....");\n\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            message = "接收绑定键：" + delivery.getenvelope().getroutingkey() + "，消息：" + message;\n            system.out.println(message);\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(queuename, true, delivercallback, cancelcallback);\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"SpringBoot整合RabbitMQ",frontmatter:{title:"SpringBoot整合RabbitMQ",date:"2022-12-05T10:38:33.000Z",permalink:"/pages/0dmo0ykv/",categories:["中间件","Spring生态"],tags:["RabbitMQ","SpringBoot"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/08.SpringBoot%E6%95%B4%E5%90%88RabbitMQ.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/08.SpringBoot整合RabbitMQ.md",key:"v-61a56867",path:"/pages/0dmo0ykv/",headers:[{level:2,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:124},{level:2,title:"修改pom文件",slug:"修改pom文件",normalizedTitle:"修改pom文件",charIndex:135},{level:2,title:"修改配置文件",slug:"修改配置文件",normalizedTitle:"修改配置文件",charIndex:1010},{level:2,title:"创建配置文件类",slug:"创建配置文件类",normalizedTitle:"创建配置文件类",charIndex:1149},{level:2,title:"消息生产者",slug:"消息生产者",normalizedTitle:"消息生产者",charIndex:3862},{level:2,title:"消息消费者",slug:"消息消费者",normalizedTitle:"消息消费者",charIndex:4362},{level:2,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:572}],excerpt:'<p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>\n<p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener noreferrer">https://spring.io/projects/spring-amqp<OutboundLink/></a></p>\n',headersStr:"创建项目 修改pom文件 修改配置文件 创建配置文件类 消息生产者 消息消费者 测试",content:'SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。\n\nSpringAmqp的官方地址：https://spring.io/projects/spring-amqp\n\n\n# 创建项目\n\n\n\n\n# 修改pom文件\n\n将SpringBoot的版本改为2.3.4.RELEASE\n\n<parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.3.4.RELEASE</version>\n    <relativePath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n\n添加RabbitMQ依赖：\n\n\x3c!--RabbitMQ 依赖--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\x3c!--RabbitMQ 测试依赖--\x3e\n<dependency>\n    <groupId>org.springframework.amqp</groupId>\n    <artifactId>spring-rabbit-test</artifactId>\n    <scope>test</scope>\n</dependency>\n\n\n其他依赖根据实际情况添加：\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <scope>provided</scope>\n</dependency>\n\n\n\n# 修改配置文件\n\nspring.rabbitmq.host=192.168.182.130\nspring.rabbitmq.port=5672\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=123123\n\n\n\n# 创建配置文件类\n\n创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：\n\n\n\nimport org.springframework.amqp.core.*;\n\n@Configuration\npublic class TtlQueueConfig {\n\n    public static final String X_EXCHANGE = "X";\n    public static final String QUEUE_A = "A";\n    public static final String QUEUE_B = "B";\n    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";\n    public static final String DEAD_LETTER_QUEUE = "D";\n\n    /**\n     * 声明 X 交换机\n     */\n    @Bean("xExchange")\n    public DirectExchange xExchange() {\n        return new DirectExchange(X_EXCHANGE);\n    }\n\n    /**\n     * 声明 Y 死信交换机\n     */\n    @Bean("yExchange")\n    public DirectExchange yExchange() {\n        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);\n    }\n\n    /**\n     * 声明 A 队列，绑定死信交换机，并设置TTL时间为 10 秒\n     */\n    @Bean("aQueue")\n    public Queue aQueue() {\n        Map<String, Object> args = new HashMap<>(3);\n        // 声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        // 声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        // 声明队列的 TTL\n        args.put("x-message-ttl", 10000);\n        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();\n    }\n\n    /**\n     * 声明 A 队列与 X 交换机绑定\n     */\n    @Bean\n    public Binding aQueueBindingX(@Qualifier("aQueue") Queue aQueue,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(aQueue).to(xExchange).with("XA");\n    }\n\n    /**\n     * 声明 B 队列，绑定死信交换机，并设置TTL时间为 40 秒\n     */\n    @Bean("bQueue")\n    public Queue bQueue() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        //声明队列的 TTL\n        args.put("x-message-ttl", 40000);\n        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();\n    }\n\n    /**\n     * 声明队列A与交换机X绑定\n     */\n    @Bean\n    public Binding bQueueBindingX(@Qualifier("bQueue") Queue bQueue,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(bQueue).to(xExchange).with("XB");\n    }\n\n    /**\n     * 声明死信队列 D\n     */\n    @Bean("dQueue")\n    public Queue dQueue() {\n        return new Queue(DEAD_LETTER_QUEUE);\n    }\n\n    /**\n     * 声明死信队列 D 与死信交换机 Y 绑定\n     */\n    @Bean\n    public Binding dDeadLetterQueueBindingY(@Qualifier("dQueue") Queue queueD,\n                                            @Qualifier("yExchange") DirectExchange yExchange) {\n        return BindingBuilder.bind(queueD).to(yExchange).with("YD");\n    }\n}\n\n\n\n# 消息生产者\n\n@Slf4j\n@RequestMapping("/ttl")\n@RestController\npublic class SendMsgController {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping("sendMsg/{message}")\n    public void sendMsg(@PathVariable String message) {\n        log.info("当前时间：{}，发送一条信息给两个 TTL 队列：{}", LocalDateTime.now(), message);\n        rabbitTemplate.convertAndSend("X", "XA", "消息来自 ttl 为 10S 的队列: " + message);\n        rabbitTemplate.convertAndSend("X", "XB", "消息来自 ttl 为 40S 的队列: " + message);\n    }\n}\n\n\n\n# 消息消费者\n\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n    @RabbitListener(queues = TtlQueueConfig.DEAD_LETTER_QUEUE)\n    public void receiveD(Message message, Channel channel) {\n        String msg = new String(message.getBody());\n        log.info("当前时间：{}，收到死信队列信息{}", LocalDateTime.now(), msg);\n    }\n}\n\n\n\n# 测试\n\n启动项目，发起一个请求 http://localhost:8080/ttl/sendMsg/124123\n\n\n\n第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。',normalizedContent:'springamqp是基于rabbitmq封装的一套模板，并且还利用springboot对其实现了自动装配，使用起来非常方便。\n\nspringamqp的官方地址：https://spring.io/projects/spring-amqp\n\n\n# 创建项目\n\n\n\n\n# 修改pom文件\n\n将springboot的版本改为2.3.4.release\n\n<parent>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-parent</artifactid>\n    <version>2.3.4.release</version>\n    <relativepath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n\n添加rabbitmq依赖：\n\n\x3c!--rabbitmq 依赖--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-amqp</artifactid>\n</dependency>\n\x3c!--rabbitmq 测试依赖--\x3e\n<dependency>\n    <groupid>org.springframework.amqp</groupid>\n    <artifactid>spring-rabbit-test</artifactid>\n    <scope>test</scope>\n</dependency>\n\n\n其他依赖根据实际情况添加：\n\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-web</artifactid>\n</dependency>\n\n<dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n    <scope>provided</scope>\n</dependency>\n\n\n\n# 修改配置文件\n\nspring.rabbitmq.host=192.168.182.130\nspring.rabbitmq.port=5672\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=123123\n\n\n\n# 创建配置文件类\n\n创建两个队列 qa 和 qb，两者队列 ttl 分别设置为 10s 和 40s，然后在创建一个交换机 x 和死信交换机 y，它们的类型都是direct，创建一个死信队列 qd，它们的绑定关系如下：\n\n\n\nimport org.springframework.amqp.core.*;\n\n@configuration\npublic class ttlqueueconfig {\n\n    public static final string x_exchange = "x";\n    public static final string queue_a = "a";\n    public static final string queue_b = "b";\n    public static final string y_dead_letter_exchange = "y";\n    public static final string dead_letter_queue = "d";\n\n    /**\n     * 声明 x 交换机\n     */\n    @bean("xexchange")\n    public directexchange xexchange() {\n        return new directexchange(x_exchange);\n    }\n\n    /**\n     * 声明 y 死信交换机\n     */\n    @bean("yexchange")\n    public directexchange yexchange() {\n        return new directexchange(y_dead_letter_exchange);\n    }\n\n    /**\n     * 声明 a 队列，绑定死信交换机，并设置ttl时间为 10 秒\n     */\n    @bean("aqueue")\n    public queue aqueue() {\n        map<string, object> args = new hashmap<>(3);\n        // 声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        // 声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        // 声明队列的 ttl\n        args.put("x-message-ttl", 10000);\n        return queuebuilder.durable(queue_a).witharguments(args).build();\n    }\n\n    /**\n     * 声明 a 队列与 x 交换机绑定\n     */\n    @bean\n    public binding aqueuebindingx(@qualifier("aqueue") queue aqueue,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(aqueue).to(xexchange).with("xa");\n    }\n\n    /**\n     * 声明 b 队列，绑定死信交换机，并设置ttl时间为 40 秒\n     */\n    @bean("bqueue")\n    public queue bqueue() {\n        map<string, object> args = new hashmap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        //声明队列的 ttl\n        args.put("x-message-ttl", 40000);\n        return queuebuilder.durable(queue_b).witharguments(args).build();\n    }\n\n    /**\n     * 声明队列a与交换机x绑定\n     */\n    @bean\n    public binding bqueuebindingx(@qualifier("bqueue") queue bqueue,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(bqueue).to(xexchange).with("xb");\n    }\n\n    /**\n     * 声明死信队列 d\n     */\n    @bean("dqueue")\n    public queue dqueue() {\n        return new queue(dead_letter_queue);\n    }\n\n    /**\n     * 声明死信队列 d 与死信交换机 y 绑定\n     */\n    @bean\n    public binding ddeadletterqueuebindingy(@qualifier("dqueue") queue queued,\n                                            @qualifier("yexchange") directexchange yexchange) {\n        return bindingbuilder.bind(queued).to(yexchange).with("yd");\n    }\n}\n\n\n\n# 消息生产者\n\n@slf4j\n@requestmapping("/ttl")\n@restcontroller\npublic class sendmsgcontroller {\n\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    @getmapping("sendmsg/{message}")\n    public void sendmsg(@pathvariable string message) {\n        log.info("当前时间：{}，发送一条信息给两个 ttl 队列：{}", localdatetime.now(), message);\n        rabbittemplate.convertandsend("x", "xa", "消息来自 ttl 为 10s 的队列: " + message);\n        rabbittemplate.convertandsend("x", "xb", "消息来自 ttl 为 40s 的队列: " + message);\n    }\n}\n\n\n\n# 消息消费者\n\n@slf4j\n@component\npublic class deadletterqueueconsumer {\n\n    @rabbitlistener(queues = ttlqueueconfig.dead_letter_queue)\n    public void received(message message, channel channel) {\n        string msg = new string(message.getbody());\n        log.info("当前时间：{}，收到死信队列信息{}", localdatetime.now(), msg);\n    }\n}\n\n\n\n# 测试\n\n启动项目，发起一个请求 http://localhost:8080/ttl/sendmsg/124123\n\n\n\n第一条消息在 10s 后变成了死信消息，然后被消费者消费掉，第二条消息在 40s 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"RabbitMQ死信队列",frontmatter:{title:"RabbitMQ死信队列",date:"2022-12-04T17:24:29.000Z",permalink:"/pages/l98puwie",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/07.RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/07.RabbitMQ死信队列.md",key:"v-676e814a",path:"/pages/l98puwie/",headers:[{level:2,title:"死信的来源",slug:"死信的来源",normalizedTitle:"死信的来源",charIndex:260},{level:2,title:"消息TTL过期",slug:"消息ttl过期",normalizedTitle:"消息ttl过期",charIndex:371},{level:2,title:"队列达到最大长度",slug:"队列达到最大长度",normalizedTitle:"队列达到最大长度",charIndex:283},{level:2,title:"消息被拒",slug:"消息被拒",normalizedTitle:"消息被拒",charIndex:315}],excerpt:"<p>死信，就是无法被消费的消息，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>\n<p>应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。</p>\n",headersStr:"死信的来源 消息TTL过期 队列达到最大长度 消息被拒",content:'死信，就是无法被消费的消息，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。\n\n\n# 死信的来源\n\n * 消息 TTL 过期\n * 队列达到最大长度(队列满了，无法再添加数据到 mq 中)\n * 消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.\n\n\n\n\n# 消息TTL过期\n\n消息发送者：\n\npublic class Task0901 {\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        //设置消息的 TTL 时间  毫秒值\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration("10000").build();\n\n        for (int i = 1; i <= 10; i++) {\n            String message = "info:" + i;\n            channel.basicPublish(NORMAL_EXCHANGE, "aaa", properties, message.getBytes(StandardCharsets.UTF_8));\n            System.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n死信队列：\n\npublic class Worker0902 {\n\n    private static final String DEAD_EXCHANGE = "dead_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n\n        // ------------创建死信队列------------\n        // 创建一个死信交换机\n        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n        // 声明一个死信队列\n        String deadQueue = "dead_queue";\n        channel.queueDeclare(deadQueue, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queueBind(deadQueue, DEAD_EXCHANGE, "bbb");\n\n        // ------------接收并处理消息------------\n        System.out.println("死信队列等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            System.out.println("死信队列收到并处理消息：" + message);\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(deadQueue, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n消息接收者：启动之后关闭该消费者，模拟其接收不到消息\n\npublic class Worker0901 {\n\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n    private static final String DEAD_EXCHANGE = "dead_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n\n        // ------------创建死信队列与普通队列的绑定信息------------\n        // 正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        // 正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", DEAD_EXCHANGE);\n        // 正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "bbb");\n\n        // ------------创建普通队列------------\n        // 创建一个普通交换机\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        // 声明一个普通队列\n        String normalQueue = "normal_queue";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        // 将交换机和队列绑定\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, "aaa");\n\n        // ------------接收并处理消息------------\n        System.out.println("等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            System.out.println("消费者收到并处理消息：" + message);\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(normalQueue, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n\n\n\n# 队列达到最大长度\n\n> 最新的消息会顶出之前发送的消息。\n\n消息发送者：\n\npublic class Task0902 {\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n        // 创建一个交换机\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        for (int i = 1; i <= 10; i++) {\n            String message = "info:" + i;\n            channel.basicPublish(NORMAL_EXCHANGE, "aaa", null, message.getBytes(StandardCharsets.UTF_8));\n            System.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n死信队列：保持不变，和上面的一样\n\n消费者（设置队列的最大长度）：需要先删除原先的队列，在启动并停止该队列，因为参数变了\n\npublic class Worker0903 {\n\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n    private static final String DEAD_EXCHANGE = "dead_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n\n        // ------------创建死信队列与普通队列的绑定信息------------\n        // 正常队列绑定死信队列信息\n        Map<String, Object> params = new HashMap<>();\n        // 正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", DEAD_EXCHANGE);\n        // 正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "bbb");\n        // 设置队列的最大长度\n        params.put("x-max-length", 6);\n\n        // ------------创建普通队列------------\n        // 创建一个普通交换机\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        // 声明一个普通队列\n        String normalQueue = "normal_queue";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        // 将交换机和队列绑定\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, "aaa");\n\n        // ------------接收并处理消息------------\n        System.out.println("等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            System.out.println("消费者收到并处理消息：" + message);\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicConsume(normalQueue, true, deliverCallback, cancelCallback);\n    }\n}\n\n\n\n\n\n# 消息被拒\n\n消息发送者：和上面代码一样\n\n死信队列：和上面代码一样\n\n消费者（设置拒绝第五条消息）：先删掉之前的队列，启动之后关闭该消费者，模拟其接收不到消息\n\npublic class Worker0904 {\n\n    private static final String NORMAL_EXCHANGE = "normal_exchange";\n    private static final String DEAD_EXCHANGE = "dead_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtil.getChannel();\n\n        // ------------创建普通队列------------\n        // 创建一个普通交换机\n        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        // 声明一个普通队列\n        String normalQueue = "normal_queue";\n        channel.queueDeclare(normalQueue, false, false, false, params);\n        // 将交换机和队列绑定\n        channel.queueBind(normalQueue, NORMAL_EXCHANGE, "aaa");\n\n        // ------------接收并处理消息------------\n        System.out.println("等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);\n            if (message.equals("info:5")) {\n                System.out.println("消费者收到并拒绝该消息：" + message);\n                //requeue设置为 false 代表拒绝重新入队，该队列如果配置了死信交换机将发送到死信队列中\n                channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);\n            } else {\n                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n                System.out.println("消费者收到并处理消息：" + message);\n            }\n        };\n        // 取消消息时的回调：\n        CancelCallback cancelCallback = (consumerTag) -> System.out.println("消息消费被中断");\n\n        // 消费消息 设置手动应答\n        channel.basicConsume(normalQueue, false, deliverCallback, cancelCallback);\n    }\n}\n\n\n',normalizedContent:'死信，就是无法被消费的消息，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\n\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到 rabbitmq 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。\n\n\n# 死信的来源\n\n * 消息 ttl 过期\n * 队列达到最大长度(队列满了，无法再添加数据到 mq 中)\n * 消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false.\n\n\n\n\n# 消息ttl过期\n\n消息发送者：\n\npublic class task0901 {\n    private static final string normal_exchange = "normal_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        //设置消息的 ttl 时间  毫秒值\n        amqp.basicproperties properties = new amqp.basicproperties().builder().expiration("10000").build();\n\n        for (int i = 1; i <= 10; i++) {\n            string message = "info:" + i;\n            channel.basicpublish(normal_exchange, "aaa", properties, message.getbytes(standardcharsets.utf_8));\n            system.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n死信队列：\n\npublic class worker0902 {\n\n    private static final string dead_exchange = "dead_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n\n        // ------------创建死信队列------------\n        // 创建一个死信交换机\n        channel.exchangedeclare(dead_exchange, builtinexchangetype.direct);\n        // 声明一个死信队列\n        string deadqueue = "dead_queue";\n        channel.queuedeclare(deadqueue, false, false, false, null);\n        // 将交换机和队列绑定\n        channel.queuebind(deadqueue, dead_exchange, "bbb");\n\n        // ------------接收并处理消息------------\n        system.out.println("死信队列等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            system.out.println("死信队列收到并处理消息：" + message);\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(deadqueue, true, delivercallback, cancelcallback);\n    }\n}\n\n\n消息接收者：启动之后关闭该消费者，模拟其接收不到消息\n\npublic class worker0901 {\n\n    private static final string normal_exchange = "normal_exchange";\n    private static final string dead_exchange = "dead_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n\n        // ------------创建死信队列与普通队列的绑定信息------------\n        // 正常队列绑定死信队列信息\n        map<string, object> params = new hashmap<>();\n        // 正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", dead_exchange);\n        // 正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "bbb");\n\n        // ------------创建普通队列------------\n        // 创建一个普通交换机\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        // 声明一个普通队列\n        string normalqueue = "normal_queue";\n        channel.queuedeclare(normalqueue, false, false, false, params);\n        // 将交换机和队列绑定\n        channel.queuebind(normalqueue, normal_exchange, "aaa");\n\n        // ------------接收并处理消息------------\n        system.out.println("等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            system.out.println("消费者收到并处理消息：" + message);\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(normalqueue, true, delivercallback, cancelcallback);\n    }\n}\n\n\n\n\n\n# 队列达到最大长度\n\n> 最新的消息会顶出之前发送的消息。\n\n消息发送者：\n\npublic class task0902 {\n    private static final string normal_exchange = "normal_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n        // 创建一个交换机\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n\n        for (int i = 1; i <= 10; i++) {\n            string message = "info:" + i;\n            channel.basicpublish(normal_exchange, "aaa", null, message.getbytes(standardcharsets.utf_8));\n            system.out.println("生产者发出消息:" + message);\n        }\n    }\n}\n\n\n死信队列：保持不变，和上面的一样\n\n消费者（设置队列的最大长度）：需要先删除原先的队列，在启动并停止该队列，因为参数变了\n\npublic class worker0903 {\n\n    private static final string normal_exchange = "normal_exchange";\n    private static final string dead_exchange = "dead_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n\n        // ------------创建死信队列与普通队列的绑定信息------------\n        // 正常队列绑定死信队列信息\n        map<string, object> params = new hashmap<>();\n        // 正常队列设置死信交换机 参数 key 是固定值\n        params.put("x-dead-letter-exchange", dead_exchange);\n        // 正常队列设置死信 routing-key 参数 key 是固定值\n        params.put("x-dead-letter-routing-key", "bbb");\n        // 设置队列的最大长度\n        params.put("x-max-length", 6);\n\n        // ------------创建普通队列------------\n        // 创建一个普通交换机\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        // 声明一个普通队列\n        string normalqueue = "normal_queue";\n        channel.queuedeclare(normalqueue, false, false, false, params);\n        // 将交换机和队列绑定\n        channel.queuebind(normalqueue, normal_exchange, "aaa");\n\n        // ------------接收并处理消息------------\n        system.out.println("等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            system.out.println("消费者收到并处理消息：" + message);\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息\n        channel.basicconsume(normalqueue, true, delivercallback, cancelcallback);\n    }\n}\n\n\n\n\n\n# 消息被拒\n\n消息发送者：和上面代码一样\n\n死信队列：和上面代码一样\n\n消费者（设置拒绝第五条消息）：先删掉之前的队列，启动之后关闭该消费者，模拟其接收不到消息\n\npublic class worker0904 {\n\n    private static final string normal_exchange = "normal_exchange";\n    private static final string dead_exchange = "dead_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutil.getchannel();\n\n        // ------------创建普通队列------------\n        // 创建一个普通交换机\n        channel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        // 声明一个普通队列\n        string normalqueue = "normal_queue";\n        channel.queuedeclare(normalqueue, false, false, false, params);\n        // 将交换机和队列绑定\n        channel.queuebind(normalqueue, normal_exchange, "aaa");\n\n        // ------------接收并处理消息------------\n        system.out.println("等待接收消息....");\n        // 接收到消息后的处理逻辑：\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string message = new string(delivery.getbody(), standardcharsets.utf_8);\n            if (message.equals("info:5")) {\n                system.out.println("消费者收到并拒绝该消息：" + message);\n                //requeue设置为 false 代表拒绝重新入队，该队列如果配置了死信交换机将发送到死信队列中\n                channel.basicreject(delivery.getenvelope().getdeliverytag(), false);\n            } else {\n                channel.basicack(delivery.getenvelope().getdeliverytag(), false);\n                system.out.println("消费者收到并处理消息：" + message);\n            }\n        };\n        // 取消消息时的回调：\n        cancelcallback cancelcallback = (consumertag) -> system.out.println("消息消费被中断");\n\n        // 消费消息 设置手动应答\n        channel.basicconsume(normalqueue, false, delivercallback, cancelcallback);\n    }\n}\n\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"RabbitMQ延时队列",frontmatter:{title:"RabbitMQ延时队列",date:"2022-12-06T15:57:32.000Z",permalink:"/pages/8s5gukww",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/09.RabbitMQ%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/09.RabbitMQ延时队列.md",key:"v-176b8424",path:"/pages/8s5gukww/",headers:[{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:88},{level:2,title:"TTL",slug:"ttl",normalizedTitle:"ttl",charIndex:519},{level:3,title:"队列设置TTL",slug:"队列设置ttl",normalizedTitle:"队列设置ttl",charIndex:695},{level:4,title:"创建配置文件类",slug:"创建配置文件类",normalizedTitle:"创建配置文件类",charIndex:1108},{level:4,title:"消息生产者",slug:"消息生产者",normalizedTitle:"消息生产者",charIndex:3718},{level:4,title:"消息消费者",slug:"消息消费者",normalizedTitle:"消息消费者",charIndex:4217},{level:4,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:4536},{level:3,title:"消息设置TTL",slug:"消息设置ttl",normalizedTitle:"消息设置ttl",charIndex:4674},{level:4,title:"创建一个新的配置类",slug:"创建一个新的配置类",normalizedTitle:"创建一个新的配置类",charIndex:5298},{level:4,title:"消息生产者",slug:"消息生产者-2",normalizedTitle:"消息生产者",charIndex:3718},{level:4,title:"消息消费者",slug:"消息消费者-2",normalizedTitle:"消息消费者",charIndex:4217},{level:4,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:4536},{level:3,title:"两者的区别",slug:"两者的区别",normalizedTitle:"两者的区别",charIndex:7284},{level:2,title:"延时队列插件",slug:"延时队列插件",normalizedTitle:"延时队列插件",charIndex:7497},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:7661},{level:3,title:"配置文件类",slug:"配置文件类",normalizedTitle:"配置文件类",charIndex:1110},{level:3,title:"消息生产者",slug:"消息生产者-3",normalizedTitle:"消息生产者",charIndex:3718},{level:3,title:"消息消费者",slug:"消息消费者-3",normalizedTitle:"消息消费者",charIndex:4217},{level:3,title:"测试",slug:"测试-3",normalizedTitle:"测试",charIndex:4536},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:10298}],excerpt:"<p>延时队列内部是有序的，最重要的特性就是延时，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p>\n",headersStr:"使用场景 TTL 队列设置TTL 创建配置文件类 消息生产者 消息消费者 测试 消息设置TTL 创建一个新的配置类 消息生产者 消息消费者 测试 两者的区别 延时队列插件 安装 配置文件类 消息生产者 消息消费者 测试 总结",content:'延时队列内部是有序的，最重要的特性就是延时，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。\n\n\n# 使用场景\n\n 1. 订单在十分钟之内未支付则自动取消\n 2. 新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。\n 3. 用户注册成功后，如果三天内没有登陆则进行短信提醒。\n 4. 用户发起退款，如果三天内没有得到处理则通知相关运营人员。\n 5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。\n\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理，如果数据量比较少，可以这样做，但对于数据量比较大，并且时效性较强的场景，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量使用轮询的方式是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n\n\n\n# TTL\n\nTTL 是 RabbitMQ 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\n\n如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，这条消息如果在TTL设置的时间内没有被消费，则会成为"死信"。如果同时配置了队列的TTL和消息的TTL，会使用较小的值，有两种方式设置 TTL。\n\n\n# 队列设置TTL\n\n在创建队列的时候设置队列的x-message-ttl属性，使用SpringBoot整合设置：\n\n/**\n * 声明 A 队列，并设置TTL时间为 10 秒\n */\n@Bean("aQueue")\npublic Queue aQueue() {\n    Map<String, Object> args = new HashMap<>(3);\n    // 声明队列的 TTL\n    args.put("x-message-ttl", 10000);\n    return QueueBuilder.durable(QUEUE_A).withArguments(args).build();\n}\n\n\n创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是direct，创建一个死信队列 QD，它们的绑定关系如下：\n\n\n\n# 创建配置文件类\n\nimport org.springframework.amqp.core.*;\n\n@Configuration\npublic class TtlQueueConfig {\n\n    public static final String X_EXCHANGE = "X";\n    public static final String QUEUE_A = "A";\n    public static final String QUEUE_B = "B";\n    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";\n    public static final String DEAD_LETTER_QUEUE = "D";\n\n    /**\n     * 声明 X 交换机\n     */\n    @Bean("xExchange")\n    public DirectExchange xExchange() {\n        return new DirectExchange(X_EXCHANGE);\n    }\n\n    /**\n     * 声明 Y 死信交换机\n     */\n    @Bean("yExchange")\n    public DirectExchange yExchange() {\n        return new DirectExchange(Y_DEAD_LETTER_EXCHANGE);\n    }\n\n    /**\n     * 声明 A 队列，绑定死信交换机，并设置TTL时间为 10 秒\n     */\n    @Bean("aQueue")\n    public Queue aQueue() {\n        Map<String, Object> args = new HashMap<>(3);\n        // 声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        // 声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        // 声明队列的 TTL\n        args.put("x-message-ttl", 10000);\n        return QueueBuilder.durable(QUEUE_A).withArguments(args).build();\n    }\n\n    /**\n     * 声明 A 队列与 X 交换机绑定\n     */\n    @Bean\n    public Binding aQueueBindingX(@Qualifier("aQueue") Queue aQueue,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(aQueue).to(xExchange).with("XA");\n    }\n\n    /**\n     * 声明 B 队列，绑定死信交换机，并设置TTL时间为 40 秒\n     */\n    @Bean("bQueue")\n    public Queue bQueue() {\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        //声明队列的 TTL\n        args.put("x-message-ttl", 40000);\n        return QueueBuilder.durable(QUEUE_B).withArguments(args).build();\n    }\n\n    /**\n     * 声明队列A与交换机X绑定\n     */\n    @Bean\n    public Binding bQueueBindingX(@Qualifier("bQueue") Queue bQueue,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(bQueue).to(xExchange).with("XB");\n    }\n\n    /**\n     * 声明死信队列 D\n     */\n    @Bean("dQueue")\n    public Queue dQueue() {\n        return new Queue(DEAD_LETTER_QUEUE);\n    }\n\n    /**\n     * 声明死信队列 D 与死信交换机 Y 绑定\n     */\n    @Bean\n    public Binding dDeadLetterQueueBindingY(@Qualifier("dQueue") Queue queueD,\n                                            @Qualifier("yExchange") DirectExchange yExchange) {\n        return BindingBuilder.bind(queueD).to(yExchange).with("YD");\n    }\n}\n\n\n# 消息生产者\n\n@Slf4j\n@RequestMapping("/ttl")\n@RestController\npublic class SendMsgController {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping("sendMsg/{message}")\n    public void sendMsg(@PathVariable String message) {\n        log.info("当前时间：{}，发送一条信息给两个 TTL 队列：{}", LocalDateTime.now(), message);\n        rabbitTemplate.convertAndSend("X", "XA", "消息来自 ttl 为 10S 的队列: " + message);\n        rabbitTemplate.convertAndSend("X", "XB", "消息来自 ttl 为 40S 的队列: " + message);\n    }\n}\n\n\n# 消息消费者\n\n@Slf4j\n@Component\npublic class DeadLetterQueueConsumer {\n\n    @RabbitListener(queues = TtlQueueConfig.DEAD_LETTER_QUEUE)\n    public void receiveD(Message message, Channel channel) {\n        String msg = new String(message.getBody());\n        log.info("当前时间：{}，收到死信队列信息{}", LocalDateTime.now(), msg);\n    }\n}\n\n\n# 测试\n\n启动项目，发起一个请求 http://localhost:8080/ttl/sendMsg/124123\n\n\n\n第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。\n\n\n# 消息设置TTL\n\n对每条消息设置TTL，使用SpringBoot整合设置：\n\n@GetMapping("sendMsg/{message}")\npublic void sendMsg(@PathVariable String message) {\n    log.info("当前时间：{}，发送一条信息给两个 TTL 队列：{}", LocalDateTime.now(), message);\n    rabbitTemplate.convertAndSend("X", "XA", "消息来自 ttl 为 10S 的队列: " + message);\n    rabbitTemplate.convertAndSend("X", "XB", "消息来自 ttl 为 40S 的队列: " + message,\n            // 消息来自设置了40S的队列，但消息的TTL是2S，如果都设置了，则以少的为准\n            correlationData -> {\n                correlationData.getMessageProperties().setExpiration("2000");\n                return correlationData;\n            });\n}\n\n\n在上面的案例中新增一个C队列，绑定关系如下，该队列不设置TTL 时间：\n\n\n\n# 创建一个新的配置类\n\n@Component\npublic class MsgQueueConfig {\n\n    public static final String QUEUE_C = "C";\n    public static final String Y_DEAD_LETTER_EXCHANGE = "Y";\n\n    /**\n     * 声明 C 队列，绑定死信交换机\n     */\n    @Bean("cQueue")\n    public Queue cQueue(){\n        Map<String, Object> args = new HashMap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", Y_DEAD_LETTER_EXCHANGE);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "YD");\n        //没有声明 TTL 属性\n        return QueueBuilder.durable(QUEUE_C).withArguments(args).build();\n    }\n\n    /**\n     * 声明队列C与交换机X绑定\n     */\n    @Bean\n    public Binding cQueueBindingX(@Qualifier("cQueue") Queue bQueue,\n                                  @Qualifier("xExchange") DirectExchange xExchange) {\n        return BindingBuilder.bind(bQueue).to(xExchange).with("XC");\n    }\n}\n\n\n# 消息生产者\n\n@GetMapping("sendMsg/{message}")\npublic void sendMsg(@PathVariable String message) {\n    log.info("当前时间：{}，发送一条信息给两个 TTL 队列：{}", LocalDateTime.now(), message);\n    rabbitTemplate.convertAndSend("X", "XA", "消息来自 ttl 为 10S 的队列: " + message);\n    rabbitTemplate.convertAndSend("X", "XB", "消息来自 ttl 为 40S 的队列: " + message,\n            // 消息来自设置了40S的队列，但消息的TTL是2S，如果都设置了，则以少的为准\n            correlationData -> {\n                correlationData.getMessageProperties().setExpiration("2000");\n                return correlationData;\n            });\n}\n\n@GetMapping("sendExpirationMsg/{message}/{ttlTime}")\npublic void sendMsg(@PathVariable String message, @PathVariable String ttlTime) {\n    rabbitTemplate.convertAndSend("X", "XC", message, correlationData -> {\n        correlationData.getMessageProperties().setExpiration(ttlTime);\n        return correlationData;\n    });\n    log.info("当前时间：{}，发送一条时长{}毫秒 TTL 信息给队列 C: {}", LocalDateTime.now(), ttlTime, message);\n}\n\n\n# 消息消费者\n\n和上面的保持一致\n\n# 测试\n\n启动项目，发起两个请求\n\n * http://localhost:8080/ttl/sendExpirationMsg/你好2/20000\n * http://localhost:8080/ttl/sendExpirationMsg/你好/2000\n\n\n\n执行成功。\n\n\n# 两者的区别\n\n设置队列的 TTL 属性，一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)。\n\n设置消息的 TTL 属性，消息过期，不一定会被马上丢弃，消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n\n# 延时队列插件\n\n上面消息TTL设置时，看起来没什么问题，但如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\n\n使用延时队列插件解决：\n\n\n# 安装\n\n官网下载地址：https://www.rabbitmq.com/community-plugins.html\n\n找到 rabbitmq_delayed_message_exchange 插件，点击Releases，进入github页面点击下载ez格式的文件，并将该文件上传到 RabbitMQ 的插件目录/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins。\n\n> 下载合适的版本，mq是3.8.8，插件就下载支持该版本的，否则执行下面命令会报错。\n\n\n\n执行命令：\n\n rabbitmq-plugins enable rabbitmq_delayed_message_exchange\n\n\n> 如果执行了没反应，可以进入rabbitmq的安装目录执行，然后重启试试。\n\n\n\n\n\n新增一个队列delayed.queue，一个交换机delayed.exchange，绑定关系如下：\n\n\n\n\n# 配置文件类\n\n@Configuration\npublic class DelayedQueueConfig {\n    public static final String DELAYED_QUEUE_NAME = "delayed.queue";\n    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";\n    public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";\n\n    /**\n     * 声明 delayed.queue 队列\n     */\n    @Bean\n    public Queue delayedQueue() {\n        return new Queue(DELAYED_QUEUE_NAME);\n    }\n\n    /**\n     * 声明 delayed.exchange 交换机\n     * 交换机使用新类型的交换机：x-delayed-message\n     */\n    @Bean\n    public CustomExchange delayedExchange() {\n        Map<String, Object> args = new HashMap<>();\n        // 自定义交换机的类型\n        args.put("x-delayed-type", "direct");\n        return new CustomExchange(DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, args);\n    }\n\n    /**\n     * 声明队列与交换机绑定\n     */\n    @Bean\n    public Binding bindingDelayedQueue(@Qualifier("delayedQueue") Queue queue,\n                                       @Qualifier("delayedExchange") CustomExchange delayedExchange) {\n        return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();\n    }\n}\n\n\n\n# 消息生产者\n\npublic static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";\npublic static final String DELAYED_ROUTING_KEY = "delayed.routingkey";\n\n@GetMapping("sendDelayMsg/{message}/{delayTime}")\npublic void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) {\n    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message, correlationData -> {\n                correlationData.getMessageProperties().setDelay(delayTime);\n                return correlationData;\n            });\n    log.info("当前时间：{}，发送一条延时 {} 毫秒的信息给队列 delayed.queue：{}", \n        LocalDateTime.now(), delayTime, message);\n}\n\n\n\n# 消息消费者\n\n@RabbitListener(queues = DelayedQueueConfig.DELAYED_QUEUE_NAME)\npublic void receiveDelayedQueue(Message message) {\n    String msg = new String(message.getBody());\n    log.info("当前时间：{}，收到延时队列的消息：{}", LocalDateTime.now(), msg);\n}\n\n\n\n# 测试\n\n启动项目，发起两个请求\n\nhttp://localhost:8080/ttl/sendDelayMsg/{message}/{delayTime}\n\n * http://localhost:8080/ttl/sendDelayMsg/第1条消息/20000\n * http://localhost:8080/ttl/sendDelayMsg/第2条消息/2000\n\n\n\n第二个消息被先消费掉，符合预期。\n\n\n# 总结\n\n延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用其特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。\n\n另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。\n\n当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz或者利用 kafka 的时间轮，这些方式各有特点，看需要适用的场景。',normalizedContent:'延时队列内部是有序的，最重要的特性就是延时，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。\n\n\n# 使用场景\n\n 1. 订单在十分钟之内未支付则自动取消\n 2. 新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。\n 3. 用户注册成功后，如果三天内没有登陆则进行短信提醒。\n 4. 用户发起退款，如果三天内没有得到处理则通知相关运营人员。\n 5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。\n\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理，如果数据量比较少，可以这样做，但对于数据量比较大，并且时效性较强的场景，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量使用轮询的方式是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\n\n\n\n\n# ttl\n\nttl 是 rabbitmq 中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒。\n\n如果一条消息设置了 ttl 属性或者进入了设置ttl 属性的队列，这条消息如果在ttl设置的时间内没有被消费，则会成为"死信"。如果同时配置了队列的ttl和消息的ttl，会使用较小的值，有两种方式设置 ttl。\n\n\n# 队列设置ttl\n\n在创建队列的时候设置队列的x-message-ttl属性，使用springboot整合设置：\n\n/**\n * 声明 a 队列，并设置ttl时间为 10 秒\n */\n@bean("aqueue")\npublic queue aqueue() {\n    map<string, object> args = new hashmap<>(3);\n    // 声明队列的 ttl\n    args.put("x-message-ttl", 10000);\n    return queuebuilder.durable(queue_a).witharguments(args).build();\n}\n\n\n创建两个队列 qa 和 qb，两者队列 ttl 分别设置为 10s 和 40s，然后在创建一个交换机 x 和死信交换机 y，它们的类型都是direct，创建一个死信队列 qd，它们的绑定关系如下：\n\n\n\n# 创建配置文件类\n\nimport org.springframework.amqp.core.*;\n\n@configuration\npublic class ttlqueueconfig {\n\n    public static final string x_exchange = "x";\n    public static final string queue_a = "a";\n    public static final string queue_b = "b";\n    public static final string y_dead_letter_exchange = "y";\n    public static final string dead_letter_queue = "d";\n\n    /**\n     * 声明 x 交换机\n     */\n    @bean("xexchange")\n    public directexchange xexchange() {\n        return new directexchange(x_exchange);\n    }\n\n    /**\n     * 声明 y 死信交换机\n     */\n    @bean("yexchange")\n    public directexchange yexchange() {\n        return new directexchange(y_dead_letter_exchange);\n    }\n\n    /**\n     * 声明 a 队列，绑定死信交换机，并设置ttl时间为 10 秒\n     */\n    @bean("aqueue")\n    public queue aqueue() {\n        map<string, object> args = new hashmap<>(3);\n        // 声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        // 声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        // 声明队列的 ttl\n        args.put("x-message-ttl", 10000);\n        return queuebuilder.durable(queue_a).witharguments(args).build();\n    }\n\n    /**\n     * 声明 a 队列与 x 交换机绑定\n     */\n    @bean\n    public binding aqueuebindingx(@qualifier("aqueue") queue aqueue,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(aqueue).to(xexchange).with("xa");\n    }\n\n    /**\n     * 声明 b 队列，绑定死信交换机，并设置ttl时间为 40 秒\n     */\n    @bean("bqueue")\n    public queue bqueue() {\n        map<string, object> args = new hashmap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        //声明队列的 ttl\n        args.put("x-message-ttl", 40000);\n        return queuebuilder.durable(queue_b).witharguments(args).build();\n    }\n\n    /**\n     * 声明队列a与交换机x绑定\n     */\n    @bean\n    public binding bqueuebindingx(@qualifier("bqueue") queue bqueue,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(bqueue).to(xexchange).with("xb");\n    }\n\n    /**\n     * 声明死信队列 d\n     */\n    @bean("dqueue")\n    public queue dqueue() {\n        return new queue(dead_letter_queue);\n    }\n\n    /**\n     * 声明死信队列 d 与死信交换机 y 绑定\n     */\n    @bean\n    public binding ddeadletterqueuebindingy(@qualifier("dqueue") queue queued,\n                                            @qualifier("yexchange") directexchange yexchange) {\n        return bindingbuilder.bind(queued).to(yexchange).with("yd");\n    }\n}\n\n\n# 消息生产者\n\n@slf4j\n@requestmapping("/ttl")\n@restcontroller\npublic class sendmsgcontroller {\n\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    @getmapping("sendmsg/{message}")\n    public void sendmsg(@pathvariable string message) {\n        log.info("当前时间：{}，发送一条信息给两个 ttl 队列：{}", localdatetime.now(), message);\n        rabbittemplate.convertandsend("x", "xa", "消息来自 ttl 为 10s 的队列: " + message);\n        rabbittemplate.convertandsend("x", "xb", "消息来自 ttl 为 40s 的队列: " + message);\n    }\n}\n\n\n# 消息消费者\n\n@slf4j\n@component\npublic class deadletterqueueconsumer {\n\n    @rabbitlistener(queues = ttlqueueconfig.dead_letter_queue)\n    public void received(message message, channel channel) {\n        string msg = new string(message.getbody());\n        log.info("当前时间：{}，收到死信队列信息{}", localdatetime.now(), msg);\n    }\n}\n\n\n# 测试\n\n启动项目，发起一个请求 http://localhost:8080/ttl/sendmsg/124123\n\n\n\n第一条消息在 10s 后变成了死信消息，然后被消费者消费掉，第二条消息在 40s 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。\n\n\n# 消息设置ttl\n\n对每条消息设置ttl，使用springboot整合设置：\n\n@getmapping("sendmsg/{message}")\npublic void sendmsg(@pathvariable string message) {\n    log.info("当前时间：{}，发送一条信息给两个 ttl 队列：{}", localdatetime.now(), message);\n    rabbittemplate.convertandsend("x", "xa", "消息来自 ttl 为 10s 的队列: " + message);\n    rabbittemplate.convertandsend("x", "xb", "消息来自 ttl 为 40s 的队列: " + message,\n            // 消息来自设置了40s的队列，但消息的ttl是2s，如果都设置了，则以少的为准\n            correlationdata -> {\n                correlationdata.getmessageproperties().setexpiration("2000");\n                return correlationdata;\n            });\n}\n\n\n在上面的案例中新增一个c队列，绑定关系如下，该队列不设置ttl 时间：\n\n\n\n# 创建一个新的配置类\n\n@component\npublic class msgqueueconfig {\n\n    public static final string queue_c = "c";\n    public static final string y_dead_letter_exchange = "y";\n\n    /**\n     * 声明 c 队列，绑定死信交换机\n     */\n    @bean("cqueue")\n    public queue cqueue(){\n        map<string, object> args = new hashmap<>(3);\n        //声明当前队列绑定的死信交换机\n        args.put("x-dead-letter-exchange", y_dead_letter_exchange);\n        //声明当前队列的死信路由 key\n        args.put("x-dead-letter-routing-key", "yd");\n        //没有声明 ttl 属性\n        return queuebuilder.durable(queue_c).witharguments(args).build();\n    }\n\n    /**\n     * 声明队列c与交换机x绑定\n     */\n    @bean\n    public binding cqueuebindingx(@qualifier("cqueue") queue bqueue,\n                                  @qualifier("xexchange") directexchange xexchange) {\n        return bindingbuilder.bind(bqueue).to(xexchange).with("xc");\n    }\n}\n\n\n# 消息生产者\n\n@getmapping("sendmsg/{message}")\npublic void sendmsg(@pathvariable string message) {\n    log.info("当前时间：{}，发送一条信息给两个 ttl 队列：{}", localdatetime.now(), message);\n    rabbittemplate.convertandsend("x", "xa", "消息来自 ttl 为 10s 的队列: " + message);\n    rabbittemplate.convertandsend("x", "xb", "消息来自 ttl 为 40s 的队列: " + message,\n            // 消息来自设置了40s的队列，但消息的ttl是2s，如果都设置了，则以少的为准\n            correlationdata -> {\n                correlationdata.getmessageproperties().setexpiration("2000");\n                return correlationdata;\n            });\n}\n\n@getmapping("sendexpirationmsg/{message}/{ttltime}")\npublic void sendmsg(@pathvariable string message, @pathvariable string ttltime) {\n    rabbittemplate.convertandsend("x", "xc", message, correlationdata -> {\n        correlationdata.getmessageproperties().setexpiration(ttltime);\n        return correlationdata;\n    });\n    log.info("当前时间：{}，发送一条时长{}毫秒 ttl 信息给队列 c: {}", localdatetime.now(), ttltime, message);\n}\n\n\n# 消息消费者\n\n和上面的保持一致\n\n# 测试\n\n启动项目，发起两个请求\n\n * http://localhost:8080/ttl/sendexpirationmsg/你好2/20000\n * http://localhost:8080/ttl/sendexpirationmsg/你好/2000\n\n\n\n执行成功。\n\n\n# 两者的区别\n\n设置队列的 ttl 属性，一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)。\n\n设置消息的 ttl 属性，消息过期，不一定会被马上丢弃，消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；如果不设置 ttl，表示消息永远不会过期，如果将 ttl 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。\n\n\n# 延时队列插件\n\n上面消息ttl设置时，看起来没什么问题，但如果使用在消息属性上设置 ttl 的方式，消息可能并不会按时“死亡“，因为 rabbitmq 只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\n\n使用延时队列插件解决：\n\n\n# 安装\n\n官网下载地址：https://www.rabbitmq.com/community-plugins.html\n\n找到 rabbitmq_delayed_message_exchange 插件，点击releases，进入github页面点击下载ez格式的文件，并将该文件上传到 rabbitmq 的插件目录/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins。\n\n> 下载合适的版本，mq是3.8.8，插件就下载支持该版本的，否则执行下面命令会报错。\n\n\n\n执行命令：\n\n rabbitmq-plugins enable rabbitmq_delayed_message_exchange\n\n\n> 如果执行了没反应，可以进入rabbitmq的安装目录执行，然后重启试试。\n\n\n\n\n\n新增一个队列delayed.queue，一个交换机delayed.exchange，绑定关系如下：\n\n\n\n\n# 配置文件类\n\n@configuration\npublic class delayedqueueconfig {\n    public static final string delayed_queue_name = "delayed.queue";\n    public static final string delayed_exchange_name = "delayed.exchange";\n    public static final string delayed_routing_key = "delayed.routingkey";\n\n    /**\n     * 声明 delayed.queue 队列\n     */\n    @bean\n    public queue delayedqueue() {\n        return new queue(delayed_queue_name);\n    }\n\n    /**\n     * 声明 delayed.exchange 交换机\n     * 交换机使用新类型的交换机：x-delayed-message\n     */\n    @bean\n    public customexchange delayedexchange() {\n        map<string, object> args = new hashmap<>();\n        // 自定义交换机的类型\n        args.put("x-delayed-type", "direct");\n        return new customexchange(delayed_exchange_name, "x-delayed-message", true, false, args);\n    }\n\n    /**\n     * 声明队列与交换机绑定\n     */\n    @bean\n    public binding bindingdelayedqueue(@qualifier("delayedqueue") queue queue,\n                                       @qualifier("delayedexchange") customexchange delayedexchange) {\n        return bindingbuilder.bind(queue).to(delayedexchange).with(delayed_routing_key).noargs();\n    }\n}\n\n\n\n# 消息生产者\n\npublic static final string delayed_exchange_name = "delayed.exchange";\npublic static final string delayed_routing_key = "delayed.routingkey";\n\n@getmapping("senddelaymsg/{message}/{delaytime}")\npublic void sendmsg(@pathvariable string message, @pathvariable integer delaytime) {\n    rabbittemplate.convertandsend(delayed_exchange_name, delayed_routing_key, message, correlationdata -> {\n                correlationdata.getmessageproperties().setdelay(delaytime);\n                return correlationdata;\n            });\n    log.info("当前时间：{}，发送一条延时 {} 毫秒的信息给队列 delayed.queue：{}", \n        localdatetime.now(), delaytime, message);\n}\n\n\n\n# 消息消费者\n\n@rabbitlistener(queues = delayedqueueconfig.delayed_queue_name)\npublic void receivedelayedqueue(message message) {\n    string msg = new string(message.getbody());\n    log.info("当前时间：{}，收到延时队列的消息：{}", localdatetime.now(), msg);\n}\n\n\n\n# 测试\n\n启动项目，发起两个请求\n\nhttp://localhost:8080/ttl/senddelaymsg/{message}/{delaytime}\n\n * http://localhost:8080/ttl/senddelaymsg/第1条消息/20000\n * http://localhost:8080/ttl/senddelaymsg/第2条消息/2000\n\n\n\n第二个消息被先消费掉，符合预期。\n\n\n# 总结\n\n延时队列在需要延时处理的场景下非常有用，使用 rabbitmq 来实现延时队列可以很好的利用其特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。\n\n另外，通过 rabbitmq 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。\n\n当然，延时队列还有很多其它选择，比如利用 java 的 delayqueue，利用 redis 的 zset，利用 quartz或者利用 kafka 的时间轮，这些方式各有特点，看需要适用的场景。',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"RabbitMQ发布确认高级",frontmatter:{title:"RabbitMQ发布确认高级",date:"2022-12-07T14:27:01.000Z",permalink:"/pages/mcht59cm",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/10.RabbitMQ%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/10.RabbitMQ发布确认高级.md",key:"v-313f6d8e",path:"/pages/mcht59cm/",headers:[{level:2,title:"发布确认",slug:"发布确认",normalizedTitle:"发布确认",charIndex:121},{level:3,title:"配置文件",slug:"配置文件",normalizedTitle:"配置文件",charIndex:151},{level:3,title:"配置类",slug:"配置类",normalizedTitle:"配置类",charIndex:531},{level:3,title:"回调接口",slug:"回调接口",normalizedTitle:"回调接口",charIndex:1357},{level:3,title:"消息生产者",slug:"消息生产者",normalizedTitle:"消息生产者",charIndex:1920},{level:3,title:"消息消费者",slug:"消息消费者",normalizedTitle:"消息消费者",charIndex:3022},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:3361},{level:2,title:"回退消息",slug:"回退消息",normalizedTitle:"回退消息",charIndex:3602},{level:2,title:"备份交换机",slug:"备份交换机",normalizedTitle:"备份交换机",charIndex:5620},{level:3,title:"配置类",slug:"配置类-2",normalizedTitle:"配置类",charIndex:531},{level:3,title:"消息生产者",slug:"消息生产者-2",normalizedTitle:"消息生产者",charIndex:1920},{level:3,title:"消息消费者",slug:"消息消费者-2",normalizedTitle:"消息消费者",charIndex:3022},{level:3,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:3361}],excerpt:"<p>在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。 在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢？</p>\n",headersStr:"发布确认 配置文件 配置类 回调接口 消息生产者 消息消费者 测试 回退消息 备份交换机 配置类 消息生产者 消息消费者 测试",content:'在生产环境中由于一些不明原因，导致 RabbitMQ 重启，在 RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。 在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢？\n\n\n# 发布确认\n\n确认机制方案：\n\n\n\n代码架构图：\n\n\n\n\n# 配置文件\n\n在application.properties文件中加入下面的配置：\n\nspring.rabbitmq.publisher-confirm-type=correlated\n\n\n * NONE：禁用发布确认模式，是默认值\n * CORRELATED：发布消息成功到交换器后会触发回调方法\n * SIMPLE：有两种效果，其一效果和 CORRELATED 值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑。\n\n> 要注意的是waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。\n\n\n# 配置类\n\n@Configuration\npublic class ConfirmConfig {\n    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n\n    /**\n     * 声明交换机\n     */\n    @Bean("confirmExchange")\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n\n    /**\n     * 声明队列\n     * 该队列是确认队列\n     */\n    @Bean("confirmQueue")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    /**\n     * 声明交换机与队列绑定\n     */\n    @Bean\n    public Binding queueBinding(@Qualifier("confirmQueue") Queue queue,\n                                @Qualifier("confirmExchange") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with("key1");\n    }\n}\n\n\n\n# 回调接口\n\n@Component\n@Slf4j\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback {\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationData 消息相关数据\n     * @param ack             交换机是否收到消息\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : "";\n        if (ack) {\n            log.info("交换机已经收到 id 为：{}的消息", id);\n        } else {\n            log.info("交换机还未收到 id 为：{}消息，由于原因：{}", id, cause);\n        }\n    }\n}\n\n\n\n# 消息生产者\n\n@Slf4j\n@RestController\n@RequestMapping("/confirm")\npublic class Producer {\n    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    @Autowired\n    private MyCallBack myCallBack;\n\n    /**\n     * 依赖注入 rabbitTemplate 之后再设置它的回调对象\n     */\n    @PostConstruct\n    public void init() {\n        rabbitTemplate.setConfirmCallback(myCallBack);\n    }\n\n    @GetMapping("sendMessage/{message}")\n    public void sendMessage(@PathVariable String message) {\n        // 指定消息 id 为 1\n        CorrelationData correlationData1 = new CorrelationData("1");\n        String routingKey = "key1";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message, correlationData1);\n        log.info("发送消息routingKey={}，内容={}", routingKey, message);\n\n        CorrelationData correlationData2 = new CorrelationData("2");\n        routingKey = "key2";\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, routingKey, message, correlationData2);\n        log.info("发送消息routingKey={}，内容={}", routingKey, message);\n    }\n}\n\n\n\n# 消息消费者\n\n@Slf4j\n@Component\npublic class ConfirmConsumer {\n\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n\n    @RabbitListener(queues = CONFIRM_QUEUE_NAME)\n    public void receiveMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.info("接收到队列 confirm.queue 消息:{}", msg);\n    }\n}\n\n\n\n# 测试\n\n启动项目，发起一个请求：http://localhost:8080/confirm/sendMessage/xx1\n\n发送了两条消息，第一条消息的 RoutingKey 为 "key1"，第二条消息的 RoutingKey 为 "key2"，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\n\n\n\n\n# 回退消息\n\n在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，生产者是不知道消息被丢弃的。通过设置 mandatory** 参数**可以在当消息传递过程中不可达目的地时将消息返回给生产者。\n\n@Slf4j\n@RestController\npublic class MessageProducer implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnCallback {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    /**\n     * rabbitTemplate 注入之后就设置该值\n     */\n    @PostConstruct\n    private void init() {\n        // 设置收到消息的回调交给谁处理\n        rabbitTemplate.setConfirmCallback(this);\n        // true：交换机无法将消息进行路由时，会将该消息返回给生产者\n        // false：如果发现消息无法进行路由，则直接丢弃\n        rabbitTemplate.setMandatory(true);\n        // 设置回退消息交给谁处理\n        rabbitTemplate.setReturnCallback(this);\n    }\n\n    @GetMapping("/sendMessage/{message}")\n    public void sendMessage(@PathVariable String message) {\n        // 让消息绑定一个 id 值\n        CorrelationData correlationData1 = new CorrelationData(UUID.randomUUID().toString());\n        rabbitTemplate.convertAndSend("confirm.exchange", "key1", message + "key1", correlationData1);\n        log.info("发送消息id为:{}内容为{}", correlationData1.getId(), message + "key1");\n\n        CorrelationData correlationData2 = new CorrelationData(UUID.randomUUID().toString());\n        rabbitTemplate.convertAndSend("confirm.exchange", "key2", message + "key2", correlationData2);\n        log.info("发送消息id为:{}内容为{}", correlationData2.getId(), message + "key2");\n    }\n\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData != null ? correlationData.getId() : "";\n        if (ack) {\n            log.info("交换机收到消息确认成功，id:{}", id);\n        } else {\n            log.error("消息id:{}未成功投递到交换机，原因是:{}", id, cause);\n        }\n    }\n\n    @Override\n    public void returnedMessage(Message message, int replyCode, String replyText, \n            String exchange, String routingKey) {\n        log.info("消息{}被服务器退回，退回原因:{}，交换机是:{}，路由 key:{}", new String(message.getBody()), replyText,\n                exchange, routingKey);\n    }\n}\n\n\n\n\n\n# 备份交换机\n\n使用 mandatory 参数和回退消息，可以对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。\n\n而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。\n\n如果既不想丢失消息，又不想增加生产者的复杂性，可以为队列设置死信交换机来存储处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。\n\n在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 Fanout，这样就能把所有消息都投递到与其绑定的队列中，然后在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列。当然，还可以建立一个报警队列，用独立的消费者来进行监测和报警。\n\n\n\n\n# 配置类\n\n@Configuration\npublic class ConfirmConfig {\n\n    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n    public static final String BACKUP_EXCHANGE_NAME = "backup.exchange";\n    public static final String BACKUP_QUEUE_NAME = "backup.queue";\n    public static final String WARNING_QUEUE_NAME = "warning.queue";\n\n    /**\n     * 声明备份交换机\n     */\n    @Bean("backupExchange")\n    public FanoutExchange backupExchange() {\n        return new FanoutExchange(BACKUP_EXCHANGE_NAME);\n    }\n\n    /**\n     * 声明警告队列\n     */\n    @Bean("warningQueue")\n    public Queue warningQueue() {\n        return QueueBuilder.durable(WARNING_QUEUE_NAME).build();\n    }\n\n    /**\n     * 声明警告队列和备份交换机绑定\n     */\n    @Bean\n    public Binding warningBinding(@Qualifier("warningQueue") Queue queue,\n                                  @Qualifier("backupExchange") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n\n    /**\n     * 声明备份队列\n     */\n    @Bean("backQueue")\n    public Queue backQueue() {\n        return QueueBuilder.durable(BACKUP_QUEUE_NAME).build();\n    }\n\n    /**\n     * 声明备份队列和备份交换机绑定\n     */\n    @Bean\n    public Binding backupBinding(@Qualifier("backQueue") Queue queue,\n                                 @Qualifier("backupExchange") FanoutExchange backupExchange) {\n        return BindingBuilder.bind(queue).to(backupExchange);\n    }\n\n\n    /**\n     * 声明交换机\n     */\n    @Bean("confirmExchange")\n    public DirectExchange confirmExchange() {\n        ExchangeBuilder exchangeBuilder = ExchangeBuilder\n                .directExchange(CONFIRM_EXCHANGE_NAME)\n                .durable(true)\n                // 设置该交换机的备份交换机\n                .withArgument("alternate-exchange", BACKUP_EXCHANGE_NAME);\n        return exchangeBuilder.build();\n    }\n\n    /**\n     * 声明队列\n     * 该队列是确认队列\n     */\n    @Bean("confirmQueue")\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    /**\n     * 声明交换机与队列绑定\n     */\n    @Bean\n    public Binding queueBinding(@Qualifier("confirmQueue") Queue queue,\n                                @Qualifier("confirmExchange") DirectExchange exchange) {\n        return BindingBuilder.bind(queue).to(exchange).with("key1");\n    }\n}\n\n\n\n# 消息生产者\n\n和上面的保持不变\n\n\n# 消息消费者\n\n@Slf4j\n@Component\npublic class ConfirmConsumer {\n\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n\n    @RabbitListener(queues = CONFIRM_QUEUE_NAME)\n    public void receiveMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.info("接收到队列 confirm.queue 消息:{}", msg);\n    }\n\n    public static final String WARNING_QUEUE_NAME = "warning.queue";\n\n    @RabbitListener(queues = WARNING_QUEUE_NAME)\n    public void receiveWarningMsg(Message message) {\n        String msg = new String(message.getBody());\n        log.error("报警发现不可路由消息：{}", msg);\n    }\n}\n\n\n\n# 测试\n\n启动项目，发起一个请求：http://localhost:8080/sendMessage/aaaa\n\n\n\nmandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，经过上面结果显示答案是备份交换机优先级高。',normalizedContent:'在生产环境中由于一些不明原因，导致 rabbitmq 重启，在 rabbitmq 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复。 在这样比较极端的情况，rabbitmq 集群不可用的时候，无法投递的消息该如何处理呢？\n\n\n# 发布确认\n\n确认机制方案：\n\n\n\n代码架构图：\n\n\n\n\n# 配置文件\n\n在application.properties文件中加入下面的配置：\n\nspring.rabbitmq.publisher-confirm-type=correlated\n\n\n * none：禁用发布确认模式，是默认值\n * correlated：发布消息成功到交换器后会触发回调方法\n * simple：有两种效果，其一效果和 correlated 值一样会触发回调方法，其二在发布消息成功后使用 rabbittemplate 调用 waitforconfirms 或 waitforconfirmsordie 方法等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑。\n\n> 要注意的是waitforconfirmsordie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。\n\n\n# 配置类\n\n@configuration\npublic class confirmconfig {\n    public static final string confirm_exchange_name = "confirm.exchange";\n    public static final string confirm_queue_name = "confirm.queue";\n\n    /**\n     * 声明交换机\n     */\n    @bean("confirmexchange")\n    public directexchange confirmexchange() {\n        return new directexchange(confirm_exchange_name);\n    }\n\n    /**\n     * 声明队列\n     * 该队列是确认队列\n     */\n    @bean("confirmqueue")\n    public queue confirmqueue() {\n        return queuebuilder.durable(confirm_queue_name).build();\n    }\n\n    /**\n     * 声明交换机与队列绑定\n     */\n    @bean\n    public binding queuebinding(@qualifier("confirmqueue") queue queue,\n                                @qualifier("confirmexchange") directexchange exchange) {\n        return bindingbuilder.bind(queue).to(exchange).with("key1");\n    }\n}\n\n\n\n# 回调接口\n\n@component\n@slf4j\npublic class mycallback implements rabbittemplate.confirmcallback {\n    /**\n     * 交换机不管是否收到消息的一个回调方法\n     *\n     * @param correlationdata 消息相关数据\n     * @param ack             交换机是否收到消息\n     */\n    @override\n    public void confirm(correlationdata correlationdata, boolean ack, string cause) {\n        string id = correlationdata != null ? correlationdata.getid() : "";\n        if (ack) {\n            log.info("交换机已经收到 id 为：{}的消息", id);\n        } else {\n            log.info("交换机还未收到 id 为：{}消息，由于原因：{}", id, cause);\n        }\n    }\n}\n\n\n\n# 消息生产者\n\n@slf4j\n@restcontroller\n@requestmapping("/confirm")\npublic class producer {\n    public static final string confirm_exchange_name = "confirm.exchange";\n    @autowired\n    private rabbittemplate rabbittemplate;\n    @autowired\n    private mycallback mycallback;\n\n    /**\n     * 依赖注入 rabbittemplate 之后再设置它的回调对象\n     */\n    @postconstruct\n    public void init() {\n        rabbittemplate.setconfirmcallback(mycallback);\n    }\n\n    @getmapping("sendmessage/{message}")\n    public void sendmessage(@pathvariable string message) {\n        // 指定消息 id 为 1\n        correlationdata correlationdata1 = new correlationdata("1");\n        string routingkey = "key1";\n        rabbittemplate.convertandsend(confirm_exchange_name, routingkey, message, correlationdata1);\n        log.info("发送消息routingkey={}，内容={}", routingkey, message);\n\n        correlationdata correlationdata2 = new correlationdata("2");\n        routingkey = "key2";\n        rabbittemplate.convertandsend(confirm_exchange_name, routingkey, message, correlationdata2);\n        log.info("发送消息routingkey={}，内容={}", routingkey, message);\n    }\n}\n\n\n\n# 消息消费者\n\n@slf4j\n@component\npublic class confirmconsumer {\n\n    public static final string confirm_queue_name = "confirm.queue";\n\n    @rabbitlistener(queues = confirm_queue_name)\n    public void receivemsg(message message) {\n        string msg = new string(message.getbody());\n        log.info("接收到队列 confirm.queue 消息:{}", msg);\n    }\n}\n\n\n\n# 测试\n\n启动项目，发起一个请求：http://localhost:8080/confirm/sendmessage/xx1\n\n发送了两条消息，第一条消息的 routingkey 为 "key1"，第二条消息的 routingkey 为 "key2"，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 routingkey 与队列的 bindingkey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。\n\n\n\n\n# 回退消息\n\n在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，生产者是不知道消息被丢弃的。通过设置 mandatory** 参数**可以在当消息传递过程中不可达目的地时将消息返回给生产者。\n\n@slf4j\n@restcontroller\npublic class messageproducer implements rabbittemplate.confirmcallback, rabbittemplate.returncallback {\n\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    /**\n     * rabbittemplate 注入之后就设置该值\n     */\n    @postconstruct\n    private void init() {\n        // 设置收到消息的回调交给谁处理\n        rabbittemplate.setconfirmcallback(this);\n        // true：交换机无法将消息进行路由时，会将该消息返回给生产者\n        // false：如果发现消息无法进行路由，则直接丢弃\n        rabbittemplate.setmandatory(true);\n        // 设置回退消息交给谁处理\n        rabbittemplate.setreturncallback(this);\n    }\n\n    @getmapping("/sendmessage/{message}")\n    public void sendmessage(@pathvariable string message) {\n        // 让消息绑定一个 id 值\n        correlationdata correlationdata1 = new correlationdata(uuid.randomuuid().tostring());\n        rabbittemplate.convertandsend("confirm.exchange", "key1", message + "key1", correlationdata1);\n        log.info("发送消息id为:{}内容为{}", correlationdata1.getid(), message + "key1");\n\n        correlationdata correlationdata2 = new correlationdata(uuid.randomuuid().tostring());\n        rabbittemplate.convertandsend("confirm.exchange", "key2", message + "key2", correlationdata2);\n        log.info("发送消息id为:{}内容为{}", correlationdata2.getid(), message + "key2");\n    }\n\n    @override\n    public void confirm(correlationdata correlationdata, boolean ack, string cause) {\n        string id = correlationdata != null ? correlationdata.getid() : "";\n        if (ack) {\n            log.info("交换机收到消息确认成功，id:{}", id);\n        } else {\n            log.error("消息id:{}未成功投递到交换机，原因是:{}", id, cause);\n        }\n    }\n\n    @override\n    public void returnedmessage(message message, int replycode, string replytext, \n            string exchange, string routingkey) {\n        log.info("消息{}被服务器退回，退回原因:{}，交换机是:{}，路由 key:{}", new string(message.getbody()), replytext,\n                exchange, routingkey);\n    }\n}\n\n\n\n\n\n# 备份交换机\n\n使用 mandatory 参数和回退消息，可以对无法投递消息的感知能力，在生产者的消息无法被投递时发现并处理。但有时候，并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。\n\n而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。\n\n如果既不想丢失消息，又不想增加生产者的复杂性，可以为队列设置死信交换机来存储处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。\n\n在 rabbitmq 中，有一种备份交换机的机制存在，可以很好的应对这个问题。备份交换机可以理解为 rabbitmq 中交换机的“备胎”，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 fanout，这样就能把所有消息都投递到与其绑定的队列中，然后在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列。当然，还可以建立一个报警队列，用独立的消费者来进行监测和报警。\n\n\n\n\n# 配置类\n\n@configuration\npublic class confirmconfig {\n\n    public static final string confirm_exchange_name = "confirm.exchange";\n    public static final string confirm_queue_name = "confirm.queue";\n    public static final string backup_exchange_name = "backup.exchange";\n    public static final string backup_queue_name = "backup.queue";\n    public static final string warning_queue_name = "warning.queue";\n\n    /**\n     * 声明备份交换机\n     */\n    @bean("backupexchange")\n    public fanoutexchange backupexchange() {\n        return new fanoutexchange(backup_exchange_name);\n    }\n\n    /**\n     * 声明警告队列\n     */\n    @bean("warningqueue")\n    public queue warningqueue() {\n        return queuebuilder.durable(warning_queue_name).build();\n    }\n\n    /**\n     * 声明警告队列和备份交换机绑定\n     */\n    @bean\n    public binding warningbinding(@qualifier("warningqueue") queue queue,\n                                  @qualifier("backupexchange") fanoutexchange backupexchange) {\n        return bindingbuilder.bind(queue).to(backupexchange);\n    }\n\n    /**\n     * 声明备份队列\n     */\n    @bean("backqueue")\n    public queue backqueue() {\n        return queuebuilder.durable(backup_queue_name).build();\n    }\n\n    /**\n     * 声明备份队列和备份交换机绑定\n     */\n    @bean\n    public binding backupbinding(@qualifier("backqueue") queue queue,\n                                 @qualifier("backupexchange") fanoutexchange backupexchange) {\n        return bindingbuilder.bind(queue).to(backupexchange);\n    }\n\n\n    /**\n     * 声明交换机\n     */\n    @bean("confirmexchange")\n    public directexchange confirmexchange() {\n        exchangebuilder exchangebuilder = exchangebuilder\n                .directexchange(confirm_exchange_name)\n                .durable(true)\n                // 设置该交换机的备份交换机\n                .withargument("alternate-exchange", backup_exchange_name);\n        return exchangebuilder.build();\n    }\n\n    /**\n     * 声明队列\n     * 该队列是确认队列\n     */\n    @bean("confirmqueue")\n    public queue confirmqueue() {\n        return queuebuilder.durable(confirm_queue_name).build();\n    }\n\n    /**\n     * 声明交换机与队列绑定\n     */\n    @bean\n    public binding queuebinding(@qualifier("confirmqueue") queue queue,\n                                @qualifier("confirmexchange") directexchange exchange) {\n        return bindingbuilder.bind(queue).to(exchange).with("key1");\n    }\n}\n\n\n\n# 消息生产者\n\n和上面的保持不变\n\n\n# 消息消费者\n\n@slf4j\n@component\npublic class confirmconsumer {\n\n    public static final string confirm_queue_name = "confirm.queue";\n\n    @rabbitlistener(queues = confirm_queue_name)\n    public void receivemsg(message message) {\n        string msg = new string(message.getbody());\n        log.info("接收到队列 confirm.queue 消息:{}", msg);\n    }\n\n    public static final string warning_queue_name = "warning.queue";\n\n    @rabbitlistener(queues = warning_queue_name)\n    public void receivewarningmsg(message message) {\n        string msg = new string(message.getbody());\n        log.error("报警发现不可路由消息：{}", msg);\n    }\n}\n\n\n\n# 测试\n\n启动项目，发起一个请求：http://localhost:8080/sendmessage/aaaa\n\n\n\nmandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，经过上面结果显示答案是备份交换机优先级高。',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"RabbitMQ其他知识点",frontmatter:{title:"RabbitMQ其他知识点",date:"2022-12-08T14:33:51.000Z",permalink:"/pages/5ctcr5a6/",categories:["中间件"],tags:["RabbitMQ"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/11.RabbitMQ%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/11.RabbitMQ其他知识点.md",key:"v-504527c9",path:"/pages/5ctcr5a6/",headers:[{level:2,title:"幂等性",slug:"幂等性",normalizedTitle:"幂等性",charIndex:2},{level:2,title:"优先级队列",slug:"优先级队列",normalizedTitle:"优先级队列",charIndex:784},{level:3,title:"添加优先级队列",slug:"添加优先级队列",normalizedTitle:"添加优先级队列",charIndex:983},{level:4,title:"控制台页面添加",slug:"控制台页面添加",normalizedTitle:"控制台页面添加",charIndex:1087},{level:4,title:"代码中队列添加",slug:"代码中队列添加",normalizedTitle:"代码中队列添加",charIndex:1100},{level:4,title:"代码中消息添加",slug:"代码中消息添加",normalizedTitle:"代码中消息添加",charIndex:1250},{level:3,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:1356},{level:2,title:"惰性队列",slug:"惰性队列",normalizedTitle:"惰性队列",charIndex:2932},{level:3,title:"两种模式",slug:"两种模式",normalizedTitle:"两种模式",charIndex:3345},{level:3,title:"内存开销对比",slug:"内存开销对比",normalizedTitle:"内存开销对比",charIndex:3783}],headersStr:"幂等性 优先级队列 添加优先级队列 控制台页面添加 代码中队列添加 代码中消息添加 案例 惰性队列 两种模式 内存开销对比",content:'# 幂等性\n\n用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。\n\n用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。\n\n消息重复消费：\n\n消费者在消费MQ中的消息时，MQ已把消息发送给消费者，消费者在给MQ 返回 ack 时网络中断，故MQ未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\n\n解决思路：\n\nMQ消费者的幂等性的解决一般使用全局ID、唯一标识（比如时间戳）、UUID，订单消费者每次消费消息时用该 id 先判断该消息是否已消费过。\n\n消费端的幂等性保障：\n\n在海量订单生成的业务高峰期，生产端有可能会重复发出消息，这时候消费端就要实现幂等性，这就意味着即使收到了一样的消息，消息永远不会被消费多次。\n\n业界主流的幂等性有两种操作：\n\n 1. 唯一 ID+指纹码机制，利用数据库主键去重\n\n> 指纹码：一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是系统生成的，基本都是由业务规则拼接而来，但是一定要保证唯一性，然后判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈，也可以采用分库分表提升性能，但不是最推荐的方式。\n\n 2. 利用 redis 的原子性去实现\n\n> 利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费。\n\n\n# 优先级队列\n\n比如在系统中有一个订单催付的场景，客户在天猫下订单，如果在设定的时间内未付款，那么就会给客户推送一条短信提醒。比如像苹果，小米这样大商家，他们的订单得到优先处理，redis的定时轮询只能用List做一个简简单单的消息队列，并不能实现一个优先级的场景。\n\n订单量大了后采用 RabbitMQ 进行改造和优化，如果发现是大商家的订单给一个相对比较高的优先级，否则就是默认优先级。\n\n\n# 添加优先级队列\n\n要让队列实现优先级需要做的事情：\n\n 1. 队列需要设置为优先级队列\n 2. 需要设置消息的优先级\n 3. 消费者需要等待消息已经发送到队列中才去消费，这样才有机会对消息进行排序\n\n\n\n# 控制台页面添加\n\n\n\n# 代码中队列添加\n\nMap<String, Object> params = new HashMap();\nparams.put("x-max-priority", 10);\nchannel.queueDeclare("hello", true, false, false, params);\n\n\n# 代码中消息添加\n\nAMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(5).build();\n\n\n\n# 案例\n\n消息发布者：\n\npublic class Producer {\n    private static final String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        // 给消息赋予一个 priority 属性\n        AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().priority(5).build();\n        for (int i = 1; i <= 10; i++) {\n            String message = "info" + i;\n            if (i == 5) {\n                channel.basicPublish("", QUEUE_NAME, properties, message.getBytes());\n            } else {\n                channel.basicPublish("", QUEUE_NAME, null, message.getBytes());\n            }\n            System.out.println("发送消息完成:" + message);\n        }\n    }\n}\n\n\n消息接收者：\n\npublic class Consumer {\n    private static final String QUEUE_NAME = "hello";\n\n    public static void main(String[] args) throws Exception {\n        Channel channel = RabbitMqUtils.getChannel();\n        // 设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU\n        Map<String, Object> params = new HashMap();\n        params.put("x-max-priority", 10);\n        channel.queueDeclare(QUEUE_NAME, true, false, false, params);\n        System.out.println("消费者启动等待消费..............");\n        DeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String receivedMessage = new String(delivery.getBody());\n            System.out.println("接收到消息:" + receivedMessage);\n        };\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, (consumerTag) -> {\n            System.out.println("消费者无法消费消息时调用，如队列被删除");\n        });\n    }\n}\n\n\n\n# 惰性队列\n\nRabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。\n\n惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。\n\n虽然 RabbitMQ 的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n\n# 两种模式\n\n**队列具备两种模式：default 和 lazy。**默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy模式即为惰性队列的模式，可以通过调用channel.queueDeclare方法的时候在参数中设置，也可以通过Policy的方式设置，如果一个队列同时使用这两种方式设置的话，那么Policy的方式具备更高的优先级。\n\n如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n在队列声明的时候可以通过x-queue-mode参数来设置队列的模式，取值为default和lazy。\n\nMap<String, Object> args = new HashMap<String, Object>();\nargs.put("x-queue-mode", "lazy");\nchannel.queueDeclare("myqueue", false, false, false, args);\n\n\n\n# 内存开销对比\n\n\n\n在发送一百万条消息，每条消息大概占1KB的情况下，普通队列占用内存是1.2GB，而惰性队列仅仅占用1.5MB。',normalizedContent:'# 幂等性\n\n用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。\n\n用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。\n\n消息重复消费：\n\n消费者在消费mq中的消息时，mq已把消息发送给消费者，消费者在给mq 返回 ack 时网络中断，故mq未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。\n\n解决思路：\n\nmq消费者的幂等性的解决一般使用全局id、唯一标识（比如时间戳）、uuid，订单消费者每次消费消息时用该 id 先判断该消息是否已消费过。\n\n消费端的幂等性保障：\n\n在海量订单生成的业务高峰期，生产端有可能会重复发出消息，这时候消费端就要实现幂等性，这就意味着即使收到了一样的消息，消息永远不会被消费多次。\n\n业界主流的幂等性有两种操作：\n\n 1. 唯一 id+指纹码机制，利用数据库主键去重\n\n> 指纹码：一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是系统生成的，基本都是由业务规则拼接而来，但是一定要保证唯一性，然后判断这个 id 是否存在数据库中，优势就是实现简单就一个拼接，查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈，也可以采用分库分表提升性能，但不是最推荐的方式。\n\n 2. 利用 redis 的原子性去实现\n\n> 利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费。\n\n\n# 优先级队列\n\n比如在系统中有一个订单催付的场景，客户在天猫下订单，如果在设定的时间内未付款，那么就会给客户推送一条短信提醒。比如像苹果，小米这样大商家，他们的订单得到优先处理，redis的定时轮询只能用list做一个简简单单的消息队列，并不能实现一个优先级的场景。\n\n订单量大了后采用 rabbitmq 进行改造和优化，如果发现是大商家的订单给一个相对比较高的优先级，否则就是默认优先级。\n\n\n# 添加优先级队列\n\n要让队列实现优先级需要做的事情：\n\n 1. 队列需要设置为优先级队列\n 2. 需要设置消息的优先级\n 3. 消费者需要等待消息已经发送到队列中才去消费，这样才有机会对消息进行排序\n\n\n\n# 控制台页面添加\n\n\n\n# 代码中队列添加\n\nmap<string, object> params = new hashmap();\nparams.put("x-max-priority", 10);\nchannel.queuedeclare("hello", true, false, false, params);\n\n\n# 代码中消息添加\n\namqp.basicproperties properties = new amqp.basicproperties().builder().priority(5).build();\n\n\n\n# 案例\n\n消息发布者：\n\npublic class producer {\n    private static final string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        // 给消息赋予一个 priority 属性\n        amqp.basicproperties properties = new amqp.basicproperties().builder().priority(5).build();\n        for (int i = 1; i <= 10; i++) {\n            string message = "info" + i;\n            if (i == 5) {\n                channel.basicpublish("", queue_name, properties, message.getbytes());\n            } else {\n                channel.basicpublish("", queue_name, null, message.getbytes());\n            }\n            system.out.println("发送消息完成:" + message);\n        }\n    }\n}\n\n\n消息接收者：\n\npublic class consumer {\n    private static final string queue_name = "hello";\n\n    public static void main(string[] args) throws exception {\n        channel channel = rabbitmqutils.getchannel();\n        // 设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 cpu\n        map<string, object> params = new hashmap();\n        params.put("x-max-priority", 10);\n        channel.queuedeclare(queue_name, true, false, false, params);\n        system.out.println("消费者启动等待消费..............");\n        delivercallback delivercallback = (consumertag, delivery) -> {\n            string receivedmessage = new string(delivery.getbody());\n            system.out.println("接收到消息:" + receivedmessage);\n        };\n        channel.basicconsume(queue_name, true, delivercallback, (consumertag) -> {\n            system.out.println("消费者无法消费消息时调用，如队列被删除");\n        });\n    }\n}\n\n\n\n# 惰性队列\n\nrabbitmq 从 3.6.0 版本开始引入了惰性队列的概念。\n\n惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。\n\n默认情况下，生产者将消息发送到 rabbitmq 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 rabbitmq 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。\n\n虽然 rabbitmq 的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。\n\n\n# 两种模式\n\n**队列具备两种模式：default 和 lazy。**默认的为default 模式，在3.6.0 之前的版本无需做任何变更。lazy模式即为惰性队列的模式，可以通过调用channel.queuedeclare方法的时候在参数中设置，也可以通过policy的方式设置，如果一个队列同时使用这两种方式设置的话，那么policy的方式具备更高的优先级。\n\n如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。\n\n在队列声明的时候可以通过x-queue-mode参数来设置队列的模式，取值为default和lazy。\n\nmap<string, object> args = new hashmap<string, object>();\nargs.put("x-queue-mode", "lazy");\nchannel.queuedeclare("myqueue", false, false, false, args);\n\n\n\n# 内存开销对比\n\n\n\n在发送一百万条消息，每条消息大概占1kb的情况下，普通队列占用内存是1.2gb，而惰性队列仅仅占用1.5mb。',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"RabbitMQ集群",frontmatter:{title:"RabbitMQ集群",date:"2022-12-09T11:05:29.000Z",permalink:"/pages/1kma3r88/",categories:["中间件"],tags:["RabbitMQ","TODO"],author:{name:"乔木先生"}},regularPath:"/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/01.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/1001.RabbitMQ/12.RabbitMQ%E9%9B%86%E7%BE%A4.html",relativePath:"04.中间件/01.消息中间件/1001.RabbitMQ/12.RabbitMQ集群.md",key:"v-6bf9b24a",path:"/pages/1kma3r88/",headers:[{level:2,title:"搭建步骤",slug:"搭建步骤",normalizedTitle:"搭建步骤",charIndex:2},{level:2,title:"镜像队列",slug:"镜像队列",normalizedTitle:"镜像队列",charIndex:1220},{level:2,title:"Haproxy+Keepalive实现高可用负载均衡",slug:"haproxy-keepalive实现高可用负载均衡",normalizedTitle:"haproxy+keepalive实现高可用负载均衡",charIndex:1793},{level:3,title:"整体架构图",slug:"整体架构图",normalizedTitle:"整体架构图",charIndex:1853},{level:3,title:"HAProxy",slug:"haproxy",normalizedTitle:"haproxy",charIndex:1865},{level:3,title:"Keepalived实现双机(主备)热备",slug:"keepalived实现双机-主备-热备",normalizedTitle:"keepalived实现双机(主备)热备",charIndex:2356},{level:2,title:"Federation Exchange",slug:"federation-exchange",normalizedTitle:"federation exchange",charIndex:3315},{level:2,title:"Federation Queue",slug:"federation-queue",normalizedTitle:"federation queue",charIndex:4171},{level:2,title:"Shovel",slug:"shovel",normalizedTitle:"shovel",charIndex:4341}],headersStr:"搭建步骤 镜像队列 Haproxy+Keepalive实现高可用负载均衡 整体架构图 HAProxy Keepalived实现双机(主备)热备 Federation Exchange Federation Queue Shovel",content:'# 搭建步骤\n\n创建三台虚拟机，可以使用克隆，并修改3台机器的主机名称。\n\nvim /etc/hostname\n\n\n主机名尽量不要带符号！！！我带了 报错了。\n\n\n\n先知道本机的ip，使用ifconfig 命令查看，配置各个节点的hosts文件，让各个节点都能互相识别对方，三台机器保持一致即可。\n\nvim /etc/hosts\n\n\n\n\n确保各个节点的 cookie 文件使用的是同一个值，在centos1上执行远程操作命令:\n\nscp /var/lib/rabbitmq/.erlang.cookie root@centos2:/var/lib/rabbitmq/.erlang.cookie\nscp /var/lib/rabbitmq/.erlang.cookie root@centos3:/var/lib/rabbitmq/.erlang.cookie\n\n\n\n\n启动 RabbitMQ 服务，顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)\n\nrabbitmq-server -detached\n\n\n在节点 2 执行：\n\n# (rabbitmqctl stop 会将Erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务)\nrabbitmqctl stop_app\nrabbitmqctl reset\nrabbitmqctl join_cluster rabbit@centos1\n# 只启动应用服务：\nrabbitmqctl start_app\n\n\n\n\n在节点 3 执行：\n\nrabbitmqctl stop_app\nrabbitmqctl reset\nrabbitmqctl join_cluster rabbit@centos2\nrabbitmqctl start_app\n\n\n\n\n集群状态：\n\nrabbitmqctl cluster_status\n\n\n\n\n需要重新设置用户，三台机器随便哪一台设置，因为是集群，通用的：\n\n# 创建账号\nrabbitmqctl add_user admin 123\n\n# 设置用户角色\nrabbitmqctl set_user_tags admin administrator\n\n# 设置用户权限\nrabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"\n\n\n\n\n解除集群节点(centos2 和centos3机器分别执行，不解除不要执行)\n\nrabbitmqctl stop_app\nrabbitmqctl reset\nrabbitmqctl start_app\nrabbitmqctl cluster_status\nrabbitmqctl forget_cluster_node rabbit@node2 # (node1 机器上执行)\n\n\n\n# 镜像队列\n\n如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，一般不希望遇到因单点故障导致的服务不可用。\n\n引入镜像队列(Mirror Queue)的机制，可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。\n\n搭建步骤\n\n启动三台集群节点，随便找一个节点添加 policy：\n\n\n\n> Pattern根据自己的队列来配置\n\n\n\n在centos1上创建一个队列发送一条消息，队列存在镜像队列，停掉centos1之后发现centos2成为镜像队列：\n\n\n\n\n\n就算整个集群只剩下一台机器了，依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了。\n\n> 给centos1发消息，不处理消息，然后停掉centos1，这时centos2就可以消费消息\n\n\n\n\n# Haproxy+Keepalive实现高可用负载均衡\n\n> 文档里面含糊不清，直接复制的文档，后面接触到了再补\n\n\n# 整体架构图\n\n\n\n\n# HAProxy\n\nHAProxy 提供高可用性、负载均衡及基于TCPHTTP 应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 Twitter、Reddit、StackOverflow、GitHub 在内的多家知名互联网公司在使用。\n\nHAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。\n\n> nginx、lvs、haproxy之间的区别: http://www.ha97.com/5646.html\n\n搭建步骤：\n\n下载 haproxy(在centos1和centos2)\n\nyum -y install haproxy\n\n\n修改centos1和centos2的haproxy.cfg\n\nvim /etc/haproxy/haproxy.cfg\n\n\n需要修改红色 IP 为当前机器 IP\n\n\n\n在两台节点启动 haproxy\n\nhaproxy -f /etc/haproxy/haproxy.cfg\nps -ef | grep haproxy\n\n\n访问地址\n\nhttp://10.211.55.71:8888/stats\n\n\n# Keepalived实现双机(主备)热备\n\n如果配置的HAProxy主机突然宕机或者网卡失效，就算RbbitMQ集群没有任何故障但是对于外界的客户端来说所有的连接都会被断开，结果是灾难性的，为了确保负载均衡服务的可靠性同样显得十分重要。\n\nKeepalived它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移。\n\n搭建步骤：\n\n下载 keepalived\n\nyum -y install keepalived\n\n\n修改节点centos1配置文件：\n\nvim /etc/keepalived/keepalived.conf\n\n\n把资料里面的 keepalived.conf 修改之后替换\n\n> 没有资料\n\n节点centos2配置文件\n\n * 需要修改global_defs 的 router_id,如:nodeB\n * 其次要修改 vrrp_instance_VI 中 state 为"BACKUP"；\n * 最后要将priority 设置为小于 100 的值\n\n添加 haproxy_chk.sh\n\n(为了防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作)\n\n# 可以上传文件\nvim /etc/keepalived/haproxy_chk.sh\n# 修改权限 \nchmod 777 /etc/keepalived/haproxy_chk.sh\n\n\n> 这里也没有文件\n\n启动 keepalive(centos1和centos2启动)\n\nsystemctl start keepalived\n\n\n观察 Keepalived 的日志\n\ntail -f /var/log/messages -n 200\n\n\n观察最新添加的 vip\n\nip add show\n\n\ncentos1模拟 keepalived 关闭状态\n\nsystemctl stop keepalived\n\n\n使用 vip 地址来访问 rabbitmq 集群\n\n\n# Federation Exchange\n\n(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，(Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisherconfirm 机制或者事务机制的情况下，也可以迅速收到确认信息。\n\n此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息， 那么(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞。\n\n将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里使用 Federation 插件就可以很好地解决这个问题。\n\n\n\n搭建步骤：\n\n需要保证每台节点单独运行\n\n在每台机器上开启 federation 相关插件\n\nrabbitmq-plugins enable rabbitmq_federation\nrabbitmq-plugins enable rabbitmq_federation_management\n\n\n\n\n原理图(先运行 consumer 在contos2创建 fed_exchange)\n\n\n\n在 downstream(contos2)配置 upstream(contos1)\n\n\n\n添加 policy\n\n\n\n成功的前提\n\n\n\n\n# Federation Queue\n\n联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求。\n\n搭建步骤：\n\n\n\n添加 upstream(同上)\n\n添加 policy\n\n\n\n\n# Shovel\n\nFederation 具备的数据转发功能类似，Shovel 够可靠、持续地从一个 Broker 中的队列(作为源端，即source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上。Shovel 可以翻译为"铲子"，是一种比较形象的比喻，这个"铲子"可以将消息从一方"铲子"另一方。Shovel 行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。\n\n搭建步骤：\n\n开启插件(需要的机器都开启)\n\nrabbitmq-plugins enable rabbitmq_shovel\nrabbitmq-plugins enable rabbitmq_shovel_management\n\n\n\n\n原理图(在源头发送的消息直接回进入到目的地队列)\n\n\n\n添加 shovel 源和目的地\n\n',normalizedContent:'# 搭建步骤\n\n创建三台虚拟机，可以使用克隆，并修改3台机器的主机名称。\n\nvim /etc/hostname\n\n\n主机名尽量不要带符号！！！我带了 报错了。\n\n\n\n先知道本机的ip，使用ifconfig 命令查看，配置各个节点的hosts文件，让各个节点都能互相识别对方，三台机器保持一致即可。\n\nvim /etc/hosts\n\n\n\n\n确保各个节点的 cookie 文件使用的是同一个值，在centos1上执行远程操作命令:\n\nscp /var/lib/rabbitmq/.erlang.cookie root@centos2:/var/lib/rabbitmq/.erlang.cookie\nscp /var/lib/rabbitmq/.erlang.cookie root@centos3:/var/lib/rabbitmq/.erlang.cookie\n\n\n\n\n启动 rabbitmq 服务，顺带启动 erlang 虚拟机和 rbbitmq 应用服务(在三台节点上分别执行以下命令)\n\nrabbitmq-server -detached\n\n\n在节点 2 执行：\n\n# (rabbitmqctl stop 会将erlang 虚拟机关闭，rabbitmqctl stop_app 只关闭 rabbitmq 服务)\nrabbitmqctl stop_app\nrabbitmqctl reset\nrabbitmqctl join_cluster rabbit@centos1\n# 只启动应用服务：\nrabbitmqctl start_app\n\n\n\n\n在节点 3 执行：\n\nrabbitmqctl stop_app\nrabbitmqctl reset\nrabbitmqctl join_cluster rabbit@centos2\nrabbitmqctl start_app\n\n\n\n\n集群状态：\n\nrabbitmqctl cluster_status\n\n\n\n\n需要重新设置用户，三台机器随便哪一台设置，因为是集群，通用的：\n\n# 创建账号\nrabbitmqctl add_user admin 123\n\n# 设置用户角色\nrabbitmqctl set_user_tags admin administrator\n\n# 设置用户权限\nrabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*"\n\n\n\n\n解除集群节点(centos2 和centos3机器分别执行，不解除不要执行)\n\nrabbitmqctl stop_app\nrabbitmqctl reset\nrabbitmqctl start_app\nrabbitmqctl cluster_status\nrabbitmqctl forget_cluster_node rabbit@node2 # (node1 机器上执行)\n\n\n\n# 镜像队列\n\n如果 rabbitmq 集群中只有一个 broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失。可以将所有消息都设置为持久化，并且对应队列的durable属性也设置为true，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗。通过 publisherconfirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，一般不希望遇到因单点故障导致的服务不可用。\n\n引入镜像队列(mirror queue)的机制，可以将队列镜像到集群中的其他 broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性。\n\n搭建步骤\n\n启动三台集群节点，随便找一个节点添加 policy：\n\n\n\n> pattern根据自己的队列来配置\n\n\n\n在centos1上创建一个队列发送一条消息，队列存在镜像队列，停掉centos1之后发现centos2成为镜像队列：\n\n\n\n\n\n就算整个集群只剩下一台机器了，依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了。\n\n> 给centos1发消息，不处理消息，然后停掉centos1，这时centos2就可以消费消息\n\n\n\n\n# haproxy+keepalive实现高可用负载均衡\n\n> 文档里面含糊不清，直接复制的文档，后面接触到了再补\n\n\n# 整体架构图\n\n\n\n\n# haproxy\n\nhaproxy 提供高可用性、负载均衡及基于tcphttp 应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 twitter、reddit、stackoverflow、github 在内的多家知名互联网公司在使用。\n\nhaproxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数。\n\n> nginx、lvs、haproxy之间的区别: http://www.ha97.com/5646.html\n\n搭建步骤：\n\n下载 haproxy(在centos1和centos2)\n\nyum -y install haproxy\n\n\n修改centos1和centos2的haproxy.cfg\n\nvim /etc/haproxy/haproxy.cfg\n\n\n需要修改红色 ip 为当前机器 ip\n\n\n\n在两台节点启动 haproxy\n\nhaproxy -f /etc/haproxy/haproxy.cfg\nps -ef | grep haproxy\n\n\n访问地址\n\nhttp://10.211.55.71:8888/stats\n\n\n# keepalived实现双机(主备)热备\n\n如果配置的haproxy主机突然宕机或者网卡失效，就算rbbitmq集群没有任何故障但是对于外界的客户端来说所有的连接都会被断开，结果是灾难性的，为了确保负载均衡服务的可靠性同样显得十分重要。\n\nkeepalived它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移。\n\n搭建步骤：\n\n下载 keepalived\n\nyum -y install keepalived\n\n\n修改节点centos1配置文件：\n\nvim /etc/keepalived/keepalived.conf\n\n\n把资料里面的 keepalived.conf 修改之后替换\n\n> 没有资料\n\n节点centos2配置文件\n\n * 需要修改global_defs 的 router_id,如:nodeb\n * 其次要修改 vrrp_instance_vi 中 state 为"backup"；\n * 最后要将priority 设置为小于 100 的值\n\n添加 haproxy_chk.sh\n\n(为了防止 haproxy 服务挂掉之后 keepalived 还在正常工作而没有切换到 backup 上，所以这里需要编写一个脚本来检测 haproxy 务的状态,当 haproxy 服务挂掉之后该脚本会自动重启haproxy 的服务，如果不成功则关闭 keepalived 服务，这样便可以切换到 backup 继续工作)\n\n# 可以上传文件\nvim /etc/keepalived/haproxy_chk.sh\n# 修改权限 \nchmod 777 /etc/keepalived/haproxy_chk.sh\n\n\n> 这里也没有文件\n\n启动 keepalive(centos1和centos2启动)\n\nsystemctl start keepalived\n\n\n观察 keepalived 的日志\n\ntail -f /var/log/messages -n 200\n\n\n观察最新添加的 vip\n\nip add show\n\n\ncentos1模拟 keepalived 关闭状态\n\nsystemctl stop keepalived\n\n\n使用 vip 地址来访问 rabbitmq 集群\n\n\n# federation exchange\n\n(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题。有一个在北京的业务(client 北京) 需要连接(broker 北京)，向其中的交换器 exchangea 发送消息，此时的网络延迟很小，(client 北京)可以迅速将消息发送至 exchangea 中，就算在开启了 publisherconfirm 机制或者事务机制的情况下，也可以迅速收到确认信息。\n\n此时又有个在深圳的业务(client 深圳)需要向 exchangea 发送消息， 那么(client 深圳) (broker 北京)之间有很大的网络延迟，(client 深圳) 将发送消息至 exchangea 会经历一定的延迟，尤其是在开启了 publisherconfirm 机制或者事务机制的情况下，(client 深圳) 会等待很长的延迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞。\n\n将业务(client 深圳)部署到北京的机房可以解决这个问题，但是如果(client 深圳)调用的另些服务都部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？ 这里使用 federation 插件就可以很好地解决这个问题。\n\n\n\n搭建步骤：\n\n需要保证每台节点单独运行\n\n在每台机器上开启 federation 相关插件\n\nrabbitmq-plugins enable rabbitmq_federation\nrabbitmq-plugins enable rabbitmq_federation_management\n\n\n\n\n原理图(先运行 consumer 在contos2创建 fed_exchange)\n\n\n\n在 downstream(contos2)配置 upstream(contos1)\n\n\n\n添加 policy\n\n\n\n成功的前提\n\n\n\n\n# federation queue\n\n联邦队列可以在多个 broker 节点(或者集群)之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求。\n\n搭建步骤：\n\n\n\n添加 upstream(同上)\n\n添加 policy\n\n\n\n\n# shovel\n\nfederation 具备的数据转发功能类似，shovel 够可靠、持续地从一个 broker 中的队列(作为源端，即source)拉取数据并转发至另一个 broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为目的端的交换器可以同时位于同一个 broker，也可以位于不同的 broker 上。shovel 可以翻译为"铲子"，是一种比较形象的比喻，这个"铲子"可以将消息从一方"铲子"另一方。shovel 行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。\n\n搭建步骤：\n\n开启插件(需要的机器都开启)\n\nrabbitmq-plugins enable rabbitmq_shovel\nrabbitmq-plugins enable rabbitmq_shovel_management\n\n\n\n\n原理图(在源头发送的消息直接回进入到目的地队列)\n\n\n\n添加 shovel 源和目的地\n\n',charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"Linux虚拟机安装和设置ContOS7.6",frontmatter:{title:"Linux虚拟机安装和设置ContOS7.6",date:"2022-11-23T11:30:56.000Z",permalink:"/pages/e938xib2/",categories:["运维"],tags:["Linux","VMware"],author:"乔木先生"},regularPath:"/05.%E8%BF%90%E7%BB%B4/01.Linux/01.Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AEContOS7.6.html",relativePath:"05.运维/01.Linux/01.Linux虚拟机安装和设置ContOS7.6.md",key:"v-61944210",path:"/pages/e938xib2/",headers:[{level:2,title:"创建虚拟机",slug:"创建虚拟机",normalizedTitle:"创建虚拟机",charIndex:75},{level:2,title:"安装系统",slug:"安装系统",normalizedTitle:"安装系统",charIndex:746}],headersStr:"创建虚拟机 安装系统",content:"ContOS7.6下载地址：https://pan.baidu.com/s/10J6kJ1imTesjWSABWN52sw 提取码：5u05\n\n\n# 创建虚拟机\n\n> 新建虚拟机\n\n\n\n> 选择典型，下一步\n\n\n\n> 选择稍后安装操作系统，下一步\n\n\n\n> 客户机操作系统选择Linux，版本选择Red Hat Enterprise Linux 7 64 位， 因为CentOS是RedHat(红帽)的分支，安装的是7.6的版本所以这里选择红帽7的版本，下一步\n\n\n\n> 给虚拟机命名，以及选择安装位置，下一步\n\n\n\n> 最大磁盘大小填写20GB(不够以后还可以扩充)，选择将虚拟磁盘拆分成多个文件，下一步\n\n\n\n> 点击自定义硬件\n\n\n\n * 内存\n   \n   > 内存和虚拟内存按照建议的来，一般2GB够用\n\n\n\n * 处理器\n   \n   > 根据主机的处理器来配置，我的主机只有一个CPU处理器，一共有8个内核，自身主机也需要使用，这里给出一半，每个处理器的内核数量为4\n\n\n\n * 网络适配器\n   \n   > 网络连接中选择NAT模式\n   > \n   >  * 桥接模式： 虚拟系统可以和外部系统通迅，但是容易造成IP冲突\n   >  * NAT模式： 网络地址转换模式，虚拟系统可以和外部系统通迅，不造成IP冲突\n   >  * 仅主机模式： 独立的系统\n\n\n\n * 其他\n   \n   > 其他的默认即可\n\n> 点击关闭，再点击完成，选择刚刚创建好的虚拟机，右键选择设置\n\n\n\n> 选择CD/DVD，在使用ISO映像文件中选择下载的ContOS的镜像文件，点击确定\n\n\n\n> 开启此虚拟机，双击黑色窗口，即可将鼠标和键盘进入虚拟机中，等待一会后，进入设置界面\n\n\n\n\n# 安装系统\n\n> 选择中文-简体中文 (中国)，继续\n\n\n\n * 软件选择\n   \n   > 点击软件选择\n   > \n   > 一般生产环境选择 最小安装，里面什么都没有，而学习阶段选择 GNOME 桌面版，选中：\n   > \n   >  * [x] 传统 X Windows 系统的兼容性\n   >  * [x] 兼容性程序库\n   >  * [x] 开发工具\n   > \n   > 开发工具中包含了JDK，GCC，MySQL等等，不用自己再安装了，当然后续可以卸载或者更新\n   > \n   > 然后点击完成\n\n\n\n\n\n * 安装位置\n   \n   > 点击完成后，会出现安装源和软件选择检查软件依赖关系的等待时间，等待期间不要乱动，等待结束后，点击下面的安装位置。\n   > \n   > 一般选择自动配置分区，为了更能熟悉Linux系统，这里选择我要配置分区，点击完成。\n\n\n\n> 上面配置内存的时候，给了虚拟机20G的内存，而自定义分区的话，一般分成三个区\n> \n>  1. boot分区：引导分区，操作系统的内核及在引导过程中使用的文件，建议给1G\n>  2. swap分区：交换分区，当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间，建议跟内存大小一样2G\n>  3. 根分区：就是root分区，剩下17G都给根分区\n> \n> 点击 + 号，添加分区\n\n\n\n> 挂载点选择 /boot，期望容量输入1G，点击添加挂载点后，将设备类型改成标准分区，文件系统改成ext4\n\n\n\n\n\n> 同样方式创建swap分区(挂载点选择swap，期望容量输入2G)，将设备类型改成标准分区，文件系统改成swap\n> \n> 创建根分区(挂载点选择/，期望容量输入17G)，将设备类型改成标准分区，文件系统改成ext4\n> \n> 点击左上角完成后，点击接受更改\n\n\n\n * KDUMP\n   \n   > 用于系统崩溃时捕获信息，如果是生产环境建议勾选，如果是学习的话可以关掉，节省内存。\n\n\n\n * 网络和主机名\n   \n   > 选择网络和主机名\n   > \n   > 更改主机名后点应用，将右上角的以太网选项打开，表示联网，最后点击完成\n\n\n\n * SECURITY POLICY\n   \n   > 安全策略，用于密码的校验等等，可以根据需求关闭，这里我选择关闭\n\n\n\n> 点击开始安装\n\n\n\n> 设置root密码\n\n\n\n\n\n> 一般不用root登录，因为权限太大了，所以点击创建用户，然后点击完成\n\n\n\n\n\n> 配置完成后，等待一段时间安装，安装成功后，点击重启\n\n\n\n> 重启后，点击LICENSE INFORMATION，然后选择我同意许可协议，再点击完成，出来后点击完成配置\n\n\n\n> Linux默认情况下希望使用普通用户登录，如果需要使用root用户登录，可以点击未列出，输入用户名和密码然后点击登录即可，第一次可能需要等待时间较长\n\n\n\n\n\n\n\n>  1. 选择汉语，点击前进\n> \n>  2. 选择汉语拼音，点击前进\n> \n>  3. 位置服务可以选择关闭，点击前进\n> \n>  4. 登录账号，这里可以点击跳过\n> \n>  5. 配置和安装完成\n\n\n\n\n\n\n\n",normalizedContent:"contos7.6下载地址：https://pan.baidu.com/s/10j6kj1imtesjwsabwn52sw 提取码：5u05\n\n\n# 创建虚拟机\n\n> 新建虚拟机\n\n\n\n> 选择典型，下一步\n\n\n\n> 选择稍后安装操作系统，下一步\n\n\n\n> 客户机操作系统选择linux，版本选择red hat enterprise linux 7 64 位， 因为centos是redhat(红帽)的分支，安装的是7.6的版本所以这里选择红帽7的版本，下一步\n\n\n\n> 给虚拟机命名，以及选择安装位置，下一步\n\n\n\n> 最大磁盘大小填写20gb(不够以后还可以扩充)，选择将虚拟磁盘拆分成多个文件，下一步\n\n\n\n> 点击自定义硬件\n\n\n\n * 内存\n   \n   > 内存和虚拟内存按照建议的来，一般2gb够用\n\n\n\n * 处理器\n   \n   > 根据主机的处理器来配置，我的主机只有一个cpu处理器，一共有8个内核，自身主机也需要使用，这里给出一半，每个处理器的内核数量为4\n\n\n\n * 网络适配器\n   \n   > 网络连接中选择nat模式\n   > \n   >  * 桥接模式： 虚拟系统可以和外部系统通迅，但是容易造成ip冲突\n   >  * nat模式： 网络地址转换模式，虚拟系统可以和外部系统通迅，不造成ip冲突\n   >  * 仅主机模式： 独立的系统\n\n\n\n * 其他\n   \n   > 其他的默认即可\n\n> 点击关闭，再点击完成，选择刚刚创建好的虚拟机，右键选择设置\n\n\n\n> 选择cd/dvd，在使用iso映像文件中选择下载的contos的镜像文件，点击确定\n\n\n\n> 开启此虚拟机，双击黑色窗口，即可将鼠标和键盘进入虚拟机中，等待一会后，进入设置界面\n\n\n\n\n# 安装系统\n\n> 选择中文-简体中文 (中国)，继续\n\n\n\n * 软件选择\n   \n   > 点击软件选择\n   > \n   > 一般生产环境选择 最小安装，里面什么都没有，而学习阶段选择 gnome 桌面版，选中：\n   > \n   >  * [x] 传统 x windows 系统的兼容性\n   >  * [x] 兼容性程序库\n   >  * [x] 开发工具\n   > \n   > 开发工具中包含了jdk，gcc，mysql等等，不用自己再安装了，当然后续可以卸载或者更新\n   > \n   > 然后点击完成\n\n\n\n\n\n * 安装位置\n   \n   > 点击完成后，会出现安装源和软件选择检查软件依赖关系的等待时间，等待期间不要乱动，等待结束后，点击下面的安装位置。\n   > \n   > 一般选择自动配置分区，为了更能熟悉linux系统，这里选择我要配置分区，点击完成。\n\n\n\n> 上面配置内存的时候，给了虚拟机20g的内存，而自定义分区的话，一般分成三个区\n> \n>  1. boot分区：引导分区，操作系统的内核及在引导过程中使用的文件，建议给1g\n>  2. swap分区：交换分区，当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间，建议跟内存大小一样2g\n>  3. 根分区：就是root分区，剩下17g都给根分区\n> \n> 点击 + 号，添加分区\n\n\n\n> 挂载点选择 /boot，期望容量输入1g，点击添加挂载点后，将设备类型改成标准分区，文件系统改成ext4\n\n\n\n\n\n> 同样方式创建swap分区(挂载点选择swap，期望容量输入2g)，将设备类型改成标准分区，文件系统改成swap\n> \n> 创建根分区(挂载点选择/，期望容量输入17g)，将设备类型改成标准分区，文件系统改成ext4\n> \n> 点击左上角完成后，点击接受更改\n\n\n\n * kdump\n   \n   > 用于系统崩溃时捕获信息，如果是生产环境建议勾选，如果是学习的话可以关掉，节省内存。\n\n\n\n * 网络和主机名\n   \n   > 选择网络和主机名\n   > \n   > 更改主机名后点应用，将右上角的以太网选项打开，表示联网，最后点击完成\n\n\n\n * security policy\n   \n   > 安全策略，用于密码的校验等等，可以根据需求关闭，这里我选择关闭\n\n\n\n> 点击开始安装\n\n\n\n> 设置root密码\n\n\n\n\n\n> 一般不用root登录，因为权限太大了，所以点击创建用户，然后点击完成\n\n\n\n\n\n> 配置完成后，等待一段时间安装，安装成功后，点击重启\n\n\n\n> 重启后，点击license information，然后选择我同意许可协议，再点击完成，出来后点击完成配置\n\n\n\n> linux默认情况下希望使用普通用户登录，如果需要使用root用户登录，可以点击未列出，输入用户名和密码然后点击登录即可，第一次可能需要等待时间较长\n\n\n\n\n\n\n\n>  1. 选择汉语，点击前进\n> \n>  2. 选择汉语拼音，点击前进\n> \n>  3. 位置服务可以选择关闭，点击前进\n> \n>  4. 登录账号，这里可以点击跳过\n> \n>  5. 配置和安装完成\n\n\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"Linux虚拟机VMwareTools安装+使用详解",frontmatter:{title:"Linux虚拟机VMwareTools安装+使用详解",date:"2022-11-24T11:30:56.000Z",permalink:"/pages/45rn88gi/",categories:["运维"],tags:["Linux","VMware"],author:"乔木先生"},regularPath:"/05.%E8%BF%90%E7%BB%B4/01.Linux/02.Linux%E8%99%9A%E6%8B%9F%E6%9C%BAVMwareTools%E5%AE%89%E8%A3%85+%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.html",relativePath:"05.运维/01.Linux/02.Linux虚拟机VMwareTools安装+使用详解.md",key:"v-72d51d8a",path:"/pages/45rn88gi/",headers:[{level:2,title:"安装VMwareTools",slug:"安装vmwaretools",normalizedTitle:"安装vmwaretools",charIndex:67},{level:2,title:"添加共享文件夹",slug:"添加共享文件夹",normalizedTitle:"添加共享文件夹",charIndex:725}],excerpt:"<p>VMware安装后，可以使用VMware在Windows中更好的使用和管理虚拟机，<strong>设置Windows和CentOS共享文件夹</strong></p>\n",headersStr:"安装VMwareTools 添加共享文件夹",content:"VMware安装后，可以使用VMware在Windows中更好的使用和管理虚拟机，设置Windows和CentOS共享文件夹\n\n\n# 安装VMwareTools\n\n> 进入CentOS，右键选择桌面上的光驱图标，点击弹出，没有的话不用弹\n\n\n\n> 点击菜单的栏中的重新安装 VMware Tools，如果不是重新安装的话，就点安装VMtools即可\n\n\n\n> CentOS会出现一个VMware Tools的安装包，如果没有的话重复上一步点击取消安装，再重新安装一次试试\n\n\n\n> 打开这个光驱，可以看到一个VMwareTools...tar.gz的文件，把它拷贝到 /opt目录下\n> \n>  1. 双击主文件夹\n>  2. 选择“其他位置”\n>  3. 双击“计算机”\n>  4. 双击“opt”目录\n\n\n\n> 右键桌面，点击打开终端\n> \n> 执行下面的命令(一行一行执行)，第二行最后的是刚刚复制的文件名，改成自己的就好\n> \n> 手打麻烦的话，可以先输入文件名开头几个字母，比如VM，然后使用Tab键选择对应的文件\n\ncd /opt\ntar -zxvf VMwareTools...tar.gz\n\n\n\n\n> 解压后，可以看到 /opt文件夹下，多了一个文件夹\n> \n> 使用终端进入这个目录，以下命令依次执行，如果跟自己的文件名不一样，需要改成自己的\n\ncd vmware-tools-distrib/\n./vmware-install.pl\n\n\n> 这两条命令执行后，遇到选项直接一路回车，安装前确保系统有安装GCC，否则安装失败的（输入命令 gcc - v 如果有输出信息，说明有安装）\n\n\n\n\n\n> 看到这个说明安装成功\n\n\n\n\n# 添加共享文件夹\n\n> 首先在本地创建一个文件夹，里面随便放一个文件\n\n\n\n> 右键需要共享文件夹的虚拟机，选择设置\n\n\n\n> 依次选择下面的选项\n\n\n\n> 选择刚刚创建的文件夹，然后点击下一步\n> \n> 选择启用次共享，然后点击完成，再点确定\n\n\n\n> 在CentOS中，选择其他位置，再选择计算机，进入mnt文件夹\n> \n> 依次往下点击，可以看到刚刚创建的共享文件夹，也能看到刚刚创建的共享的文件\n\n",normalizedContent:"vmware安装后，可以使用vmware在windows中更好的使用和管理虚拟机，设置windows和centos共享文件夹\n\n\n# 安装vmwaretools\n\n> 进入centos，右键选择桌面上的光驱图标，点击弹出，没有的话不用弹\n\n\n\n> 点击菜单的栏中的重新安装 vmware tools，如果不是重新安装的话，就点安装vmtools即可\n\n\n\n> centos会出现一个vmware tools的安装包，如果没有的话重复上一步点击取消安装，再重新安装一次试试\n\n\n\n> 打开这个光驱，可以看到一个vmwaretools...tar.gz的文件，把它拷贝到 /opt目录下\n> \n>  1. 双击主文件夹\n>  2. 选择“其他位置”\n>  3. 双击“计算机”\n>  4. 双击“opt”目录\n\n\n\n> 右键桌面，点击打开终端\n> \n> 执行下面的命令(一行一行执行)，第二行最后的是刚刚复制的文件名，改成自己的就好\n> \n> 手打麻烦的话，可以先输入文件名开头几个字母，比如vm，然后使用tab键选择对应的文件\n\ncd /opt\ntar -zxvf vmwaretools...tar.gz\n\n\n\n\n> 解压后，可以看到 /opt文件夹下，多了一个文件夹\n> \n> 使用终端进入这个目录，以下命令依次执行，如果跟自己的文件名不一样，需要改成自己的\n\ncd vmware-tools-distrib/\n./vmware-install.pl\n\n\n> 这两条命令执行后，遇到选项直接一路回车，安装前确保系统有安装gcc，否则安装失败的（输入命令 gcc - v 如果有输出信息，说明有安装）\n\n\n\n\n\n> 看到这个说明安装成功\n\n\n\n\n# 添加共享文件夹\n\n> 首先在本地创建一个文件夹，里面随便放一个文件\n\n\n\n> 右键需要共享文件夹的虚拟机，选择设置\n\n\n\n> 依次选择下面的选项\n\n\n\n> 选择刚刚创建的文件夹，然后点击下一步\n> \n> 选择启用次共享，然后点击完成，再点确定\n\n\n\n> 在centos中，选择其他位置，再选择计算机，进入mnt文件夹\n> \n> 依次往下点击，可以看到刚刚创建的共享文件夹，也能看到刚刚创建的共享的文件\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"Git基础命令",frontmatter:{title:"Git基础命令",date:"2022-12-16T15:15:27.000Z",permalink:"/pages/eb9ks77i",categories:["工具"],tags:["Git"],author:{name:"乔木先生"}},regularPath:"/06.%E5%B7%A5%E5%85%B7/01.Git/01.Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4.html",relativePath:"06.工具/01.Git/01.Git基础命令.md",key:"v-62914f02",path:"/pages/eb9ks77i/",headers:[{level:2,title:"基本配置",slug:"基本配置",normalizedTitle:"基本配置",charIndex:387},{level:5,title:"乱码问题",slug:"乱码问题",normalizedTitle:"乱码问题",charIndex:732},{level:2,title:"基础操作指令",slug:"基础操作指令",normalizedTitle:"基础操作指令",charIndex:904},{level:3,title:"获取本地仓库",slug:"获取本地仓库",normalizedTitle:"获取本地仓库",charIndex:976},{level:3,title:"查看修改的状态(status)",slug:"查看修改的状态-status",normalizedTitle:"查看修改的状态(status)",charIndex:1028},{level:3,title:"添加工作区到暂存区(add)",slug:"添加工作区到暂存区-add",normalizedTitle:"添加工作区到暂存区(add)",charIndex:1080},{level:3,title:"提交暂存区到本地仓库(commit)",slug:"提交暂存区到本地仓库-commit",normalizedTitle:"提交暂存区到本地仓库(commit)",charIndex:1164},{level:3,title:"查看提交日志(log)",slug:"查看提交日志-log",normalizedTitle:"查看提交日志(log)",charIndex:1229},{level:3,title:"版本回退",slug:"版本回退",normalizedTitle:"版本回退",charIndex:1381},{level:3,title:"添加文件至忽略列表",slug:"添加文件至忽略列表",normalizedTitle:"添加文件至忽略列表",charIndex:1474}],headersStr:"基本配置 乱码问题 基础操作指令 获取本地仓库 查看修改的状态(status) 添加工作区到暂存区(add) 提交暂存区到本地仓库(commit) 查看提交日志(log) 版本回退 添加文件至忽略列表",content:' * Git GUI：Git提供的图形界面工具\n * Git Bash：Git提供的命令行工具\n\nGit工作流程图：\n\n\n\n命令如下：\n\n 1. **clone(克隆)：**从远程仓库中克隆代码到本地仓库\n 2. **checkout(检出)：**从本地仓库中检出一个仓库分支然后进行修订\n 3. **add(添加)：**在提交前先将代码提交到暂存区\n 4. **commit(提交)：**提交到本地仓库。本地仓库中保存修改的各个历史版本\n 5. **fetch(抓取)：**从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。\n 6. **pull(拉取)：**从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge\n 7. **push(推送)：**修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库\n\n\n# 基本配置\n\n * 设置用户名和邮箱：\n\ngit config --global user.name "name"\ngit config --global user.email "email"\n\n\n * 查看配置信息：\n\ngit config --global user.name\ngit config --global user.email\n\n\n * 常用指令配置别名：\n\n# 1. 创建文件\ntouch ~/.bashrc\n\n\n例如：\n\n#用于输出git提交日志\nalias git-log=\'git log --pretty=oneline --all --graph --abbrev-commit\'\n#用于输出当前目录所有文件及基本信息\nalias ll=\'ls -al\'\n\n\n# 乱码问题\n\n 1. 打开GitBash执行下面命令\n\ngit config --global core.quotepath false\n\n\n 2. ${git_home}/etc/bash.bashrc文件最后加入下面两行\n\nexport LANG="zh_CN.UTF-8"\nexport LC_ALL="zh_CN.UTF-8"\n\n\n\n# 基础操作指令\n\nGit工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着执行Git的命令而发生变化。\n\n\n\n\n# 获取本地仓库\n\ngit init\n\n\n\n\n\n\n如果创建成功后可在文件夹下看到隐藏的.git目录\n\n\n# 查看修改的状态(status)\n\n查看的修改的状态（暂存区、工作区）\n\ngit status\n\n\n\n# 添加工作区到暂存区(add)\n\n添加工作区一个或多个文件的修改到暂存区\n\ngit add 单个文件名|通配符\n# 将所有修改加入暂存区：\ngit add .\n\n\n\n# 提交暂存区到本地仓库(commit)\n\n提交暂存区内容到本地仓库的当前分支\n\ngit commit -m \'注释内容\'\n\n\n\n# 查看提交日志(log)\n\n查看提交记录\n\ngit log [option]\n# options：\n# --all 显示所有分支\n# --pretty=oneline 将提交信息显示为一行\n# --abbrev-commit 使得输出的commitId更简短\n# --graph 以图的形式显示\n\n\n\n# 版本回退\n\n版本切换，commitID 可以使用git log指令查看。\n\ngit reset --hard commitID\n\n\n查看已经删除的记录\n\ngit reflog\n\n\n\n# 添加文件至忽略列表\n\n在工作目录中创建一个名为.gitignore的文件（文件名称固定），列出要忽略的文件模式。\n\n例如：\n\n/log/\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**/target/\n!**/src/test/**/target/\n',normalizedContent:' * git gui：git提供的图形界面工具\n * git bash：git提供的命令行工具\n\ngit工作流程图：\n\n\n\n命令如下：\n\n 1. **clone(克隆)：**从远程仓库中克隆代码到本地仓库\n 2. **checkout(检出)：**从本地仓库中检出一个仓库分支然后进行修订\n 3. **add(添加)：**在提交前先将代码提交到暂存区\n 4. **commit(提交)：**提交到本地仓库。本地仓库中保存修改的各个历史版本\n 5. **fetch(抓取)：**从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。\n 6. **pull(拉取)：**从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于fetch+merge\n 7. **push(推送)：**修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库\n\n\n# 基本配置\n\n * 设置用户名和邮箱：\n\ngit config --global user.name "name"\ngit config --global user.email "email"\n\n\n * 查看配置信息：\n\ngit config --global user.name\ngit config --global user.email\n\n\n * 常用指令配置别名：\n\n# 1. 创建文件\ntouch ~/.bashrc\n\n\n例如：\n\n#用于输出git提交日志\nalias git-log=\'git log --pretty=oneline --all --graph --abbrev-commit\'\n#用于输出当前目录所有文件及基本信息\nalias ll=\'ls -al\'\n\n\n# 乱码问题\n\n 1. 打开gitbash执行下面命令\n\ngit config --global core.quotepath false\n\n\n 2. ${git_home}/etc/bash.bashrc文件最后加入下面两行\n\nexport lang="zh_cn.utf-8"\nexport lc_all="zh_cn.utf-8"\n\n\n\n# 基础操作指令\n\ngit工作目录下对于文件的修改(增加、删除、更新)会存在几个状态，这些修改的状态会随着执行git的命令而发生变化。\n\n\n\n\n# 获取本地仓库\n\ngit init\n\n\n\n\n\n\n如果创建成功后可在文件夹下看到隐藏的.git目录\n\n\n# 查看修改的状态(status)\n\n查看的修改的状态（暂存区、工作区）\n\ngit status\n\n\n\n# 添加工作区到暂存区(add)\n\n添加工作区一个或多个文件的修改到暂存区\n\ngit add 单个文件名|通配符\n# 将所有修改加入暂存区：\ngit add .\n\n\n\n# 提交暂存区到本地仓库(commit)\n\n提交暂存区内容到本地仓库的当前分支\n\ngit commit -m \'注释内容\'\n\n\n\n# 查看提交日志(log)\n\n查看提交记录\n\ngit log [option]\n# options：\n# --all 显示所有分支\n# --pretty=oneline 将提交信息显示为一行\n# --abbrev-commit 使得输出的commitid更简短\n# --graph 以图的形式显示\n\n\n\n# 版本回退\n\n版本切换，commitid 可以使用git log指令查看。\n\ngit reset --hard commitid\n\n\n查看已经删除的记录\n\ngit reflog\n\n\n\n# 添加文件至忽略列表\n\n在工作目录中创建一个名为.gitignore的文件（文件名称固定），列出要忽略的文件模式。\n\n例如：\n\n/log/\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**/target/\n!**/src/test/**/target/\n',charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"Git分支",frontmatter:{title:"Git分支",date:"2022-12-17T14:36:02.000Z",permalink:"/pages/34mo4hjp",categories:["工具"],tags:["Git"],author:{name:"乔木先生"}},regularPath:"/06.%E5%B7%A5%E5%85%B7/01.Git/02.Git%E5%88%86%E6%94%AF.html",relativePath:"06.工具/01.Git/02.Git分支.md",key:"v-1813f0ae",path:"/pages/34mo4hjp/",headers:[{level:2,title:"查看本地分支",slug:"查看本地分支",normalizedTitle:"查看本地分支",charIndex:77},{level:2,title:"创建本地分支",slug:"创建本地分支",normalizedTitle:"创建本地分支",charIndex:101},{level:2,title:"切换分支(checkout)",slug:"切换分支-checkout",normalizedTitle:"切换分支(checkout)",charIndex:129},{level:2,title:"合并分支(merge)",slug:"合并分支-merge",normalizedTitle:"合并分支(merge)",charIndex:201},{level:2,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:234},{level:2,title:"解决冲突",slug:"解决冲突",normalizedTitle:"解决冲突",charIndex:333},{level:2,title:"开发中分支使用原则与流程",slug:"开发中分支使用原则与流程",normalizedTitle:"开发中分支使用原则与流程",charIndex:462},{level:3,title:"master （生产）分支",slug:"master-生产-分支",normalizedTitle:"master （生产）分支",charIndex:578},{level:3,title:"develop（开发）分支",slug:"develop-开发-分支",normalizedTitle:"develop（开发）分支",charIndex:628},{level:3,title:"feature/xxxx分支",slug:"feature-xxxx分支",normalizedTitle:"feature/xxxx分支",charIndex:736},{level:3,title:"hotfifix/xxxx分支",slug:"hotfifix-xxxx分支",normalizedTitle:"hotfifix/xxxx分支",charIndex:818}],excerpt:"<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着可以把工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。</p>\n",headersStr:"查看本地分支 创建本地分支 切换分支(checkout) 合并分支(merge) 删除分支 解决冲突 开发中分支使用原则与流程 master （生产）分支 develop（开发）分支 feature/xxxx分支 hotfifix/xxxx分支",content:"几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着可以把工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。\n\n\n# 查看本地分支\n\ngit branch\n\n\n\n# 创建本地分支\n\ngit branch 分支名\n\n\n\n# 切换分支(checkout)\n\ngit checkout 分支名\n\n\n创建并切换一个分支：\n\ngit checkout -b 分支名\n\n\n\n# 合并分支(merge)\n\ngit merge 分支名称\n\n\n\n# 删除分支\n\n不能删除当前分支，只能删除其他分支\n\n# 删除分支时，需要做各种检查\ngit branch -d 分支名称\n\n# 不做任何检查，强制删除\ngit branch -D 分支名称\n\n\n\n# 解决冲突\n\n当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：\n\n 1. 处理文件中冲突的地方\n 2. 将解决完冲突的文件加入暂存区(add)\n 3. 提交到仓库(commit)\n\n\n\n\n# 开发中分支使用原则与流程\n\n几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的Bug修改、开发新的功能，以免影响开发主线。\n\n在开发中，一般有如下分支使用原则与流程：\n\n\n# master （生产）分支\n\n线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；\n\n\n# develop（开发）分支\n\n是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支，准备上线。\n\n\n# feature/xxxx分支\n\n从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。\n\n\n# hotfifix/xxxx分支\n\n从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、develop分支。\n\n还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。\n\n",normalizedContent:"几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着可以把工作从开发主线上分离开来进行重大的bug修改、开发新的功能，以免影响开发主线。\n\n\n# 查看本地分支\n\ngit branch\n\n\n\n# 创建本地分支\n\ngit branch 分支名\n\n\n\n# 切换分支(checkout)\n\ngit checkout 分支名\n\n\n创建并切换一个分支：\n\ngit checkout -b 分支名\n\n\n\n# 合并分支(merge)\n\ngit merge 分支名称\n\n\n\n# 删除分支\n\n不能删除当前分支，只能删除其他分支\n\n# 删除分支时，需要做各种检查\ngit branch -d 分支名称\n\n# 不做任何检查，强制删除\ngit branch -d 分支名称\n\n\n\n# 解决冲突\n\n当两个分支上对文件的修改可能会存在冲突，例如同时修改了同一个文件的同一行，这时就需要手动解决冲突，解决冲突步骤如下：\n\n 1. 处理文件中冲突的地方\n 2. 将解决完冲突的文件加入暂存区(add)\n 3. 提交到仓库(commit)\n\n\n\n\n# 开发中分支使用原则与流程\n\n几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来进行重大的bug修改、开发新的功能，以免影响开发主线。\n\n在开发中，一般有如下分支使用原则与流程：\n\n\n# master （生产）分支\n\n线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；\n\n\n# develop（开发）分支\n\n是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支，准备上线。\n\n\n# feature/xxxx分支\n\n从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完成后合并到develop分支。\n\n\n# hotfifix/xxxx分支\n\n从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、develop分支。\n\n还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等等。\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"Git远程仓库",frontmatter:{title:"Git远程仓库",date:"2022-12-18T13:05:49.000Z",permalink:"/pages/1cpd2f32/",categories:["工具"],tags:["Git"],author:{name:"乔木先生"}},regularPath:"/06.%E5%B7%A5%E5%85%B7/01.Git/03.Git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html",relativePath:"06.工具/01.Git/03.Git远程仓库.md",key:"v-2d4c79d3",path:"/pages/1cpd2f32/",headers:[{level:2,title:"配置SSH公钥",slug:"配置ssh公钥",normalizedTitle:"配置ssh公钥",charIndex:276},{level:3,title:"生成SSH公钥",slug:"生成ssh公钥",normalizedTitle:"生成ssh公钥",charIndex:288},{level:3,title:"获取公钥",slug:"获取公钥",normalizedTitle:"获取公钥",charIndex:341},{level:3,title:"验证是否配置成功",slug:"验证是否配置成功",normalizedTitle:"验证是否配置成功",charIndex:374},{level:2,title:"操作远程仓库",slug:"操作远程仓库",normalizedTitle:"操作远程仓库",charIndex:410},{level:3,title:"添加远程仓库",slug:"添加远程仓库",normalizedTitle:"添加远程仓库",charIndex:421},{level:3,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:611},{level:3,title:"推送到远程仓库",slug:"推送到远程仓库",normalizedTitle:"推送到远程仓库",charIndex:635},{level:3,title:"本地分支与远程分支的关联关系",slug:"本地分支与远程分支的关联关系",normalizedTitle:"本地分支与远程分支的关联关系",charIndex:921},{level:3,title:"从远程仓库克隆",slug:"从远程仓库克隆",normalizedTitle:"从远程仓库克隆",charIndex:958},{level:3,title:"从远程仓库中抓取和拉取",slug:"从远程仓库中抓取和拉取",normalizedTitle:"从远程仓库中抓取和拉取",charIndex:1044},{level:4,title:"抓取",slug:"抓取",normalizedTitle:"抓取",charIndex:1050},{level:4,title:"拉取",slug:"拉取",normalizedTitle:"拉取",charIndex:1053},{level:3,title:"解决合并冲突",slug:"解决合并冲突",normalizedTitle:"解决合并冲突",charIndex:1326}],excerpt:"<p>gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub。</p>\n<p>码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快。</p>\n<p>GitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。</p>\n",headersStr:"配置SSH公钥 生成SSH公钥 获取公钥 验证是否配置成功 操作远程仓库 添加远程仓库 查看远程仓库 推送到远程仓库 本地分支与远程分支的关联关系 从远程仓库克隆 从远程仓库中抓取和拉取 抓取 拉取 解决合并冲突",content:"gitHub（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名gitHub。\n\n码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快。\n\nGitLab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用Git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。\n\n\n# 配置SSH公钥\n\n\n# 生成SSH公钥\n\nssh-keygen -t rsa\n\n\n不断回车，如果公钥已经存在，则自动覆盖\n\n\n# 获取公钥\n\ncat ~/.ssh/id_rsa.pub\n\n\n\n# 验证是否配置成功\n\nssh -T git@gitee.com\n\n\n\n# 操作远程仓库\n\n\n# 添加远程仓库\n\n此操作是先初始化本地库，然后与已创建的远程库进行对接。\n\ngit remote add <远端名称> <仓库路径>\n# 远端名称，默认是origin，取决于远端服务器设置\n# 仓库路径，从远端服务器获取此URL\n# 例如: git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git\n\n\n\n# 查看远程仓库\n\ngit remote\n\n\n\n# 推送到远程仓库\n\ngit push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]\n\n# 如果远程分支名和本地分支名称相同，则可以只写本地分支\n# git push origin master\n\n# -f 表示强制覆盖\n\n# --set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。\n# git push --set-upstream origin master\n\n# 如果当前分支已经和远端分支关联，则可以省略分支名和远端名。\n# git push 将master分支推送到已关联的远端分支。\n\n\n\n# 本地分支与远程分支的关联关系\n\n git branch -vv\n\n\n\n# 从远程仓库克隆\n\n如果已经有一个远端仓库，可以直接clone到本地。\n\ngit clone <仓库路径> [本地目录]\n# 本地目录可以省略，会自动生成一个目录\n\n\n\n# 从远程仓库中抓取和拉取\n\n远程分支和本地的分支一样，可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。\n\n# 抓取\n\n抓取指令就是将仓库里的更新都抓取到本地，不会进行合并，如果不指定远端名称和分支名，则抓取所有分支。\n\ngit fetch [remote name] [branch name]\n\n\n# 拉取\n\n拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge，如果不指定远端名称和分支名，则抓取所有并更新当前分支。\n\ngit pull [remote name] [branch name]\n\n\n\n# 解决合并冲突\n\n远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同。",normalizedContent:"github（ 地址：https://github.com/ ）是一个面向开源及私有软件项目的托管平台，因为只支持 git 作为唯一的版本库格式进行托管，故名github。\n\n码云（地址： https://gitee.com/ ）是国内的一个代码托管平台，由于服务器在国内，所以相比于 github，码云速度会更快。\n\ngitlab （地址： https://about.gitlab.com/ ）是一个用于仓库管理系统的开源项目，使用git作 为代码管理工具，并在此基础上搭建起来的web服务,一般用于在企业、学校等内部网络搭建git私服。\n\n\n# 配置ssh公钥\n\n\n# 生成ssh公钥\n\nssh-keygen -t rsa\n\n\n不断回车，如果公钥已经存在，则自动覆盖\n\n\n# 获取公钥\n\ncat ~/.ssh/id_rsa.pub\n\n\n\n# 验证是否配置成功\n\nssh -t git@gitee.com\n\n\n\n# 操作远程仓库\n\n\n# 添加远程仓库\n\n此操作是先初始化本地库，然后与已创建的远程库进行对接。\n\ngit remote add <远端名称> <仓库路径>\n# 远端名称，默认是origin，取决于远端服务器设置\n# 仓库路径，从远端服务器获取此url\n# 例如: git remote add origin git@gitee.com:czbk_zhang_meng/git_test.git\n\n\n\n# 查看远程仓库\n\ngit remote\n\n\n\n# 推送到远程仓库\n\ngit push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]\n\n# 如果远程分支名和本地分支名称相同，则可以只写本地分支\n# git push origin master\n\n# -f 表示强制覆盖\n\n# --set-upstream 推送到远端的同时并且建立起和远端分支的关联关系。\n# git push --set-upstream origin master\n\n# 如果当前分支已经和远端分支关联，则可以省略分支名和远端名。\n# git push 将master分支推送到已关联的远端分支。\n\n\n\n# 本地分支与远程分支的关联关系\n\n git branch -vv\n\n\n\n# 从远程仓库克隆\n\n如果已经有一个远端仓库，可以直接clone到本地。\n\ngit clone <仓库路径> [本地目录]\n# 本地目录可以省略，会自动生成一个目录\n\n\n\n# 从远程仓库中抓取和拉取\n\n远程分支和本地的分支一样，可以进行merge操作，只是需要先把远端仓库里的更新都下载到本地，再进行操作。\n\n# 抓取\n\n抓取指令就是将仓库里的更新都抓取到本地，不会进行合并，如果不指定远端名称和分支名，则抓取所有分支。\n\ngit fetch [remote name] [branch name]\n\n\n# 拉取\n\n拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge，如果不指定远端名称和分支名，则抓取所有并更新当前分支。\n\ngit pull [remote name] [branch name]\n\n\n\n# 解决合并冲突\n\n远程分支也是分支，所以合并时冲突的解决方式也和解决本地分支冲突相同相同。",charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"MacOS安装Git",frontmatter:{title:"MacOS安装Git",date:"2022-12-19T11:44:19.000Z",permalink:"/pages/lp31htbk",categories:["工具"],tags:["Git","MacOS"],author:{name:"乔木先生"}},regularPath:"/06.%E5%B7%A5%E5%85%B7/01.Git/04.MacOS%E5%AE%89%E8%A3%85Git.html",relativePath:"06.工具/01.Git/04.MacOS安装Git.md",key:"v-f3d5199e",path:"/pages/lp31htbk/",headersStr:null,content:"首先查看电脑是否安装Git，终端输入：\n\ngit\n\n\n如果没有Git的话，会显示是否需要安装，然后点击安装：\n\n\n\n这里点同意：\n\n\n\n等慢慢下载：\n\n\n\n等待安装成功，命令行窗口输入git -v 查看版本号\n\n",normalizedContent:"首先查看电脑是否安装git，终端输入：\n\ngit\n\n\n如果没有git的话，会显示是否需要安装，然后点击安装：\n\n\n\n这里点同意：\n\n\n\n等慢慢下载：\n\n\n\n等待安装成功，命令行窗口输入git -v 查看版本号\n\n",charsets:{cjk:!0},lastUpdated:"2022/11/30, 16:24:57",lastUpdatedTimestamp:1669796697e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-452796f4",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-cfdc7134",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-8d31a9f4",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/logo.png",heroText:"乔木先生",tagline:"🚀Java后端技术博客，积跬步以至千里，致敬每个爱学习的你。",actionText:"现在阅读 →",actionLink:"/categories/",bannerBg:"none",features:[{title:"Java",details:"JavaSE、JavaWeb、Java新特性等Java技术"},{title:"Spring生态",details:"Spring、SpringBoot、SpringCloud等Spring生态"},{title:"技术",details:"技术文档、教程、技巧、总结等文章"}]},regularPath:"/",relativePath:"index.md",key:"v-25f34b1c",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/11/25, 18:48:06",lastUpdatedTimestamp:1669373286e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"Java",items:[{text:"JavaSE",link:"/pages/kas755c4/"}]},{text:"Java框架",items:[{text:"SpringCloud",link:"/pages/24j4ehty/"}]},{text:"数据库",items:[{text:"NoSQL",items:[{text:"Redis",link:"/pages/bp3ikv4g/"}]}]},{text:"中间件",items:[{text:"消息中间件",items:[{text:"RabbitMQ",link:"/pages/vd45cpcf/"}]}]},{text:"运维",items:[{text:"Linux",link:"/pages/e938xib2/"}]},{text:"工具",items:[{text:"Git",link:"/pages/eb9ks77i/"}]},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/logo.png",repo:"qaomuu",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.Java/":[{title:"JavaSE",collapsable:!0,children:[["01.JavaSE/01.Java概述&环境搭建.md","Java概述","/pages/kas755c4/"]]}],catalogue:{},"/02.Java框架/":[{title:"SpringCloud",collapsable:!0,children:[["01.SpringCloud/01.SpringCloud Eureka.md","SpringCloud Eureka","/pages/24j4ehty/"],["01.SpringCloud/02.SpringCloud Zookeeper.md","SpringCloud Zookeeper","/pages/09kei4a8/"],["01.SpringCloud/03.SpringCloud Consul.md","SpringCloud Consul","/pages/yuu0dk4i/"]]}],"/03.数据库/":[{title:"Redis",collapsable:!0,children:[["02.Redis/01.Redis概述&安装.md","Redis概述&安装","/pages/bp3ikv4g"],["02.Redis/02.Redis常用命令&数据类型.md","Redis常用命令&数据类型","/pages/0oaka83c"],["02.Redis/03.Redis配置文件.md","Redis配置文件","/pages/57aemd8k"],["02.Redis/04.Redis发布和订阅.md","Redis发布和订阅","/pages/3a16c7g6"],["02.Redis/05.Redis新数据类型.md","Redis新数据类型","/pages/wuy0993s/"],["02.Redis/06.Redis Java客户端Jedis.md","Redis Java客户端Jedis","/pages/a7v81744"],["02.Redis/07.SpringBoot整合Redis.md","SpringBoot整合Redis","/pages/jsf92i5m"]]}],"/04.中间件/":[{title:"消息中间件",collapsable:!0,children:[["01.消息中间件/01.MQ的相关概念.md","MQ的相关概念","/pages/sm8jwpla"],{title:"RabbitMQ",collapsable:!0,children:[["01.消息中间件/1001.RabbitMQ/01.RabbitMQ介绍.md","RabbitMQ介绍","/pages/vd45cpcf/"],["01.消息中间件/1001.RabbitMQ/02.RabbitMQ安装&常用命令.md","RabbitMQ安装&常用命令","/pages/kr5yv2xa/"],["01.消息中间件/1001.RabbitMQ/03.RabbitMQ入门程序.md","RabbitMQ入门程序","/pages/hs9by9nl/"],["01.消息中间件/1001.RabbitMQ/04.RabbitMQ工作队列.md","RabbitMQ工作队列","/pages/b2xtwkg7"],["01.消息中间件/1001.RabbitMQ/05.RabbitMQ发布确认.md","RabbitMQ发布确认","/pages/hf5rpdk0"],["01.消息中间件/1001.RabbitMQ/06.RabbitMQ交换机.md","RabbitMQ交换机","/pages/umb37yap"],["01.消息中间件/1001.RabbitMQ/07.RabbitMQ死信队列.md","RabbitMQ死信队列","/pages/l98puwie"],["01.消息中间件/1001.RabbitMQ/08.SpringBoot整合RabbitMQ.md","SpringBoot整合RabbitMQ","/pages/0dmo0ykv/"],["01.消息中间件/1001.RabbitMQ/09.RabbitMQ延时队列.md","RabbitMQ延时队列","/pages/8s5gukww"],["01.消息中间件/1001.RabbitMQ/10.RabbitMQ发布确认高级.md","RabbitMQ发布确认高级","/pages/mcht59cm"],["01.消息中间件/1001.RabbitMQ/11.RabbitMQ其他知识点.md","RabbitMQ其他知识点","/pages/5ctcr5a6/"],["01.消息中间件/1001.RabbitMQ/12.RabbitMQ集群.md","RabbitMQ集群","/pages/1kma3r88/"]]}]}],"/05.运维/":[{title:"Linux",collapsable:!0,children:[["01.Linux/01.Linux虚拟机安装和设置ContOS7.6.md","Linux虚拟机安装和设置ContOS7.6","/pages/e938xib2/"],["01.Linux/02.Linux虚拟机VMwareTools安装+使用详解.md","Linux虚拟机VMwareTools安装+使用详解","/pages/45rn88gi/"]]}],"/06.工具/":[{title:"Git",collapsable:!0,children:[["01.Git/01.Git基础命令.md","Git基础命令","/pages/eb9ks77i"],["01.Git/02.Git分支.md","Git分支","/pages/34mo4hjp"],["01.Git/03.Git远程仓库.md","Git远程仓库","/pages/1cpd2f32/"],["01.Git/04.MacOS安装Git.md","MacOS安装Git","/pages/lp31htbk"]]}]},pageStyle:"card",author:{name:"乔木先生"},footer:{createYear:2022,copyrightInfo:'| <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">浙ICP备2022027766号-1</a><br><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011002016801" target="_blank">浙公网安备 33011002016801号</a>'},extendFrontmatter:{author:{name:"乔木先生"}}}};var cl=t(88),ul=t.n(cl),dl=t(95),pl=t(96),ml=t(11);var hl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(ml.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(ml.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(ml.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,i=n.length;a<i;a++){const{frontmatter:{categories:i,tags:r}}=n[a];"array"===Object(ml.n)(i)&&i.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(ml.n)(r)&&r.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Gt.component(dl.default),Gt.component(pl.default);function gl(n){return n.toString().padStart(2,"0")}t(242);Gt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,362))),Gt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,96))),Gt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,95)));t(243);var fl=[ul.a,({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${gl(n.getUTCMonth()+1)}-${gl(n.getUTCDate())} ${gl(n.getUTCHours())}:${gl(n.getUTCMinutes())}:${gl(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(hl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},()=>{"undefined"!=typeof window&&function(n,e,t){function a(n){var t=e.createElement("div");t.className="heart",i.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var i=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){let t=!0;n.path&&n.path.forEach(n=>{1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)}),t&&(e&&e(),a(n))}}(),function n(){for(var t=0;t<i.length;t++)i[t].alpha<=0?(e.body.removeChild(i[t].el),i.splice(t,1)):(i[t].y--,i[t].scale+=.004,i[t].alpha-=.013,i[t].el.style.cssText="left:"+i[t].x+"px;top:"+i[t].y+"px;opacity:"+i[t].alpha+";transform:scale("+i[t].scale+","+i[t].scale+") rotate(45deg);background:"+i[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?72351396489bd466647ea26769f98b4a";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],bl=[];class vl extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(vl.prototype,{getPageAsyncComponent:ro,getLayoutAsyncComponent:so,getAsyncComponent:oo,getVueComponent:lo});var yl={install(n){const e=new vl;n.$vuepress=e,n.prototype.$vuepress=e}};function kl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var xl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return uo("pageKey",e),Gt.component(e)||Gt.component(e,ro(e)),Gt.component(e)?n(e):n("")}},wl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},El={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},_l=(t(244),t(245),Object(rl.a)(El,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Sl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use($s),Gt.use(yl),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),r={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),r),{computed:r}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},ll)),Gt.component("Content",xl),Gt.component("ContentSlotsDistributor",wl),Gt.component("OutboundLink",_l),Gt.component("ClientOnly",Sl),Gt.component("Layout",so("Layout")),Gt.component("NotFound",so("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"ff6c460"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ll.routerBase||ll.base,t=new $s({base:e,mode:"history",fallback:!1,routes:ol,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(kl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";kl(n,t)?a(t):a()}else a();else{const t=e.path+"/",i=e.path+".html";kl(n,i)?a(i):kl(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(fl.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:a,router:t,siteData:ll,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},bl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);