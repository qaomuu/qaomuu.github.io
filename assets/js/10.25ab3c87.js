(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{333:function(e,v,_){"use strict";_.r(v);var s=_(7),t=Object(s.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"redis库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis库"}},[e._v("#")]),e._v(" Redis库")]),e._v(" "),v("p",[e._v("默认16个数据库，类似数组下标从0开始，初始默认使用0号库。")]),e._v(" "),v("p",[e._v("统一密码管理，所有库同样密码。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("select <dbid>")]),e._v(" ：切换数据库")]),e._v(" "),v("li",[v("code",[e._v("dbsize")]),e._v(" ：查看当前数据库的key的数量")]),e._v(" "),v("li",[v("code",[e._v("flushdb")]),e._v(" ：清空当前库")]),e._v(" "),v("li",[v("code",[e._v("flushall")]),e._v(" ：通杀全部库")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/98ANGFOVTBAaehfUMKTwu4L5IWO8_9E3unSebG6rGvI.png",alt:"image"}})]),e._v(" "),v("h2",{attrs:{id:"redis键"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis键"}},[e._v("#")]),e._v(" Redis键")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("keys *")]),e._v(" ：查看当前库所有key")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("keys *1")]),e._v(" ：匹配key")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("exists key")]),e._v(" ：判断某个key是否存在")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("type key")]),e._v(" ：查看key的类型")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("del key")]),e._v(" ：删除指定的key数据")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("unlink key")]),e._v(" ：根据value选择非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("expire key 10")]),e._v(" ：为key设置过期时间(单位 秒)")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("ttl key")]),e._v(" ：查看还有多少秒过期（-1表示永不过期，-2表示已过期）")])])]),e._v(" "),v("h2",{attrs:{id:"redis常用五大数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis常用五大数据类型"}},[e._v("#")]),e._v(" Redis常用五大数据类型")]),e._v(" "),v("p",[e._v("Redis存储的是："),v("code",[e._v("key,value")]),e._v("格式的数据，其中key都是字符串，value有5种不同的数据结构")]),e._v(" "),v("p",[v("strong",[e._v("value的数据结构：")])]),e._v(" "),v("ul",[v("li",[v("code",[e._v("string")]),e._v("：字符串类型   。")]),e._v(" "),v("li",[v("code",[e._v("hash")]),e._v("：哈希类型，map格式    。")]),e._v(" "),v("li",[v("code",[e._v("list")]),e._v("：列表类型，LinkedList格式，支持重复元素  。")]),e._v(" "),v("li",[v("code",[e._v("set")]),e._v("：集合类型，不允许重复元素  。")]),e._v(" "),v("li",[v("code",[e._v("sortedset")]),e._v("：有序集合类型，不允许重复元素，且元素有顺序。")])]),e._v(" "),v("h3",{attrs:{id:"字符串类型-string"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字符串类型-string"}},[e._v("#")]),e._v(" 字符串类型 string")]),e._v(" "),v("p",[e._v("string是Redis最基本的类型，一个key对应一个value。")]),e._v(" "),v("p",[e._v("string类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。")]),e._v(" "),v("p",[e._v("string类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。")]),e._v(" "),v("h4",{attrs:{id:"常用命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[e._v("#")]),e._v(" 常用命令")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("set <key> <value>")]),e._v(" "),v("strong",[e._v("：添加键值对")])])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/0WIpB_O4oS8udkkwBJGBRaAV7-Hb-fHCIdntIdQ4bBc.png",alt:"image"}})]),e._v(" "),v("blockquote",[v("ul",[v("li",[e._v("NX：当数据库中key不存在时，添加")]),e._v(" "),v("li",[e._v("XX：当数据库中key存在时，添加，与NX参数互斥")]),e._v(" "),v("li",[e._v("EX：key的超时秒数")]),e._v(" "),v("li",[e._v("PX：key的超时毫秒数，与EX互斥")])])]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("setnx <key> <value>")]),e._v("：只有在key不存在时，添加键值对")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("get <key>")]),e._v(" "),v("strong",[e._v("：查询对应键值")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("strlen <key>")]),e._v("：获得值的长度")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("del <key>")]),v("strong",[e._v("：删除键值对")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("getrange <key> <起始位置> <结束位置>")]),e._v(" ：获得值的范围，类似java中的substring，"),v("strong",[e._v("前包后包")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("setrange <key> <起始位置> <value>")]),e._v(" ：用"),v("value",[e._v("覆写"),v("key",[e._v("所储存的字符串值，从<起始位置>开始("),v("strong",[e._v("索引从0开始")]),e._v(")。")])],1)],1)]),e._v(" "),v("li",[v("p",[v("code",[e._v("incr <key>")]),e._v("：将key中储存的数字值增1，只能对数字值操作，如果为空，新增值为1")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("decr <key>")]),e._v("：将key中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("incrby/decrby <key> <步长>")]),e._v("：将 key 中储存的数字值增减，自定义步长")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("append <key> <value>")]),e._v("：将给定的"),v("code",[e._v("<value>")]),e._v("追加到原值的末尾")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("mset <key1> <value1> <key2> <value2> ....")]),e._v("：同时设置一个或多个 key-value对（要么全成功，要么全失败）")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("mget <key1> <key2> <key3> .....")]),e._v("：同时获取一个或多个value（要么全成功，要么全失败）")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("msetnx <key1> <value1> <key2> <value2> .....")]),e._v("：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在（要么全成功，要么全失败）")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("setex <key> <过期时间> <value>")]),v("strong",[e._v("：设置键值的同时，设置过期时间，单位秒。")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("getset <key> <value>")]),e._v("：以新换旧，设置了新值同时获得旧值。")])])]),e._v(" "),v("h4",{attrs:{id:"数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),v("p",[e._v("string的数据结构为简单动态字符串(Simple Dynamic String，缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/cxHTegXQ5pCT0hiRBSzMFhKQTyKYau81w8tQQHA3nX4.png",alt:"image"}})]),e._v(" "),v("p",[e._v("如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。"),v("strong",[e._v("字符串最大长度为512M。")])]),e._v(" "),v("h3",{attrs:{id:"列表类型-list"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#列表类型-list"}},[e._v("#")]),e._v(" 列表类型 list")]),e._v(" "),v("p",[v("strong",[e._v("单键多值")])]),e._v(" "),v("p",[e._v("Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。")]),e._v(" "),v("p",[e._v("它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/Ts-f_L9FMxl_26BxYnRys7y2LMvzNe51L6tyESJ1qCQ.png",alt:"image"}})]),e._v(" "),v("h4",{attrs:{id:"常用命令-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-2"}},[e._v("#")]),e._v(" 常用命令")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("lpush <key> <value1> <value2> <value3> ...")]),e._v(" ：将一个或多个元素加入列表左边")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("rpush <key> <value1> <value2> <value3> ...")]),e._v(" ：将一个或多个元素加入列表右边")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("lpop <key>")]),e._v(" ：从左边吐出一个值。值在键在，值光键亡。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("rpop <key>")]),e._v(" ：从右边吐出一个值。值在键在，值光键亡。")])])]),e._v(" "),v("p"),e._v(" "),v("ul",[v("li",[v("code",[e._v("rpoplpush <key1> <key2>")]),e._v(" ：从"),v("key1",[e._v("列表右边吐出一个值，插到"),v("key2",[e._v("列表左边。")])],1)],1),e._v(" "),v("li",[v("code",[e._v("lrange <key> <start> <stop>")]),e._v(" ：按照索引下标获得元素(从左到右)")]),e._v(" "),v("li",[v("code",[e._v("lrange mylist 0 -1")]),e._v(" ： 0左边第一个，-1右边第一个，（0-1表示获取所有）")]),e._v(" "),v("li",[v("code",[e._v("lindex <key> <index>")]),e._v(" ：按照索引下标获得元素(从左到右)")]),e._v(" "),v("li",[v("code",[e._v("llen <key>")]),e._v(" ：获得列表长度")])]),e._v(" "),v("p"),e._v(" "),v("ul",[v("li",[v("code",[e._v("linsert <key> before <value> <newvalue>")]),e._v(" ：在"),v("value",[e._v("的后面插入"),v("newvalue",[e._v("插入值")])],1)],1),e._v(" "),v("li",[v("code",[e._v("lrem <key> <n> <value>")]),e._v(" ：从左边删除n个value(从左到右)")]),e._v(" "),v("li",[v("code",[e._v("lset<key> <index> <value>")]),e._v(" ：将列表key下标为index的值替换成value")])]),e._v(" "),v("h4",{attrs:{id:"数据结构-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-2"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),v("p",[e._v("List的数据结构为快速链表quickList。")]),e._v(" "),v("p",[e._v("首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。")]),e._v(" "),v("p",[e._v("它将所有的元素紧挨着一起存储，分配的是一块连续的内存。")]),e._v(" "),v("p",[e._v("当数据量比较多的时候才会改成quicklist。")]),e._v(" "),v("p",[e._v("因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/ix7jclKjhqL-XkEoW1mtNmAQ6eAUT6MQiBnKJHsdy2s.png",alt:"image"}})]),e._v(" "),v("p",[e._v("Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。")]),e._v(" "),v("h3",{attrs:{id:"集合类型-set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集合类型-set"}},[e._v("#")]),e._v(" 集合类型 set")]),e._v(" "),v("p",[e._v("Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set可以"),v("strong",[e._v("自动排重")]),e._v("，当需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。")]),e._v(" "),v("p",[e._v("Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的"),v("strong",[e._v("复杂度都是O(1)")]),e._v("。")]),e._v(" "),v("p",[e._v("一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变。")]),e._v(" "),v("h4",{attrs:{id:"常用命令-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-3"}},[e._v("#")]),e._v(" 常用命令")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("sadd <key> <value1> <value2> .....")]),e._v(" ：将一个或多个元素加入到集合key中，已经存在的元素将被忽略")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("smembers <key>")]),e._v(" ：取出该集合的所有值")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("sismember <key> <value>")]),e._v(" ：判断集合"),v("key",[e._v("是否为含有该"),v("value",[e._v("值，有1，没有0")])],1)],1)]),e._v(" "),v("li",[v("p",[v("code",[e._v("scard <key>")]),e._v(" ：返回该集合的元素个数")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("spop <key>")]),e._v("："),v("strong",[e._v("随机从该集合中吐出一个值。")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("srandmember <key> <n>")]),e._v(" ：随机从该集合中取出n个值，不会从集合中删除")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("srem <key> <value1> <value2> ....")]),e._v(" ：删除集合中的某个元素")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("smove <source><destination>")]),e._v(" ：value把集合中一个值从一个集合移动到另一个集合")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("sinter <key1><key2>")]),e._v(" ：返回两个集合的交集元素。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("sunion <key1><key2>")]),e._v(" ：返回两个集合的并集元素。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("sdiff <key1><key2>")]),e._v(" ：返回两个集合的"),v("strong",[e._v("差集")]),e._v("元素(key1中的，不包含key2中的)")])])]),e._v(" "),v("h4",{attrs:{id:"数据结构-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-3"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),v("p",[e._v("Set数据结构是dict字典，字典是用哈希表实现的。")]),e._v(" "),v("p",[e._v("Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。")]),e._v(" "),v("h3",{attrs:{id:"哈希类型-hash"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哈希类型-hash"}},[e._v("#")]),e._v(" 哈希类型 hash")]),e._v(" "),v("p",[e._v("Redis hash 是一个键值对集合。")]),e._v(" "),v("p",[e._v("Redis hash是一个string类型的"),v("code",[e._v("field")]),e._v("和"),v("code",[e._v("value")]),e._v("的映射表，hash特别适合用于存储对象。类似Java里面的"),v("code",[e._v("Map<String, Object>")])]),e._v(" "),v("p",[e._v("用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储")]),e._v(" "),v("p",[e._v("主要有以下2种存储方式：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/oHzRgvs85HS5_ZsCYnklXirI4USuG6F9T3qbRPfgbac.png",alt:"image"}})]),e._v(" "),v("p",[e._v("通过"),v("code",[e._v("key(用户ID) + field(属性标签)")]),e._v("就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/hjh-eti05vGkUVC8bnITTlrT6comePYR7W7T4wTfjJ8.png",alt:"image"}})]),e._v(" "),v("h4",{attrs:{id:"常用命令-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-4"}},[e._v("#")]),e._v(" 常用命令")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("hset <key> <field> <value>")]),e._v(" ：给"),v("key",[e._v("集合中的"),v("field",[e._v("键赋值"),v("value")],1)],1)],1),e._v(" "),v("li",[v("code",[e._v("hget <key> <field>")]),e._v(" ：从"),v("key",[e._v("集合"),v("field",[e._v("取出 value")])],1)],1),e._v(" "),v("li",[v("code",[e._v("hmset <key> <field1> <value1> <field2> <value2>...")]),e._v(" ：批量设置hash的值")]),e._v(" "),v("li",[v("code",[e._v("hexists <key> <field>")]),e._v(" ：查看哈希表key中，给定域field是否存在。")]),e._v(" "),v("li",[v("code",[e._v("hkeys <key>")]),e._v(" ：列出该hash集合的所有field")]),e._v(" "),v("li",[v("code",[e._v("hvals <key>")]),e._v(" ：列出该hash集合的所有value")]),e._v(" "),v("li",[v("code",[e._v("hincrby <key> <field> <increment>")]),e._v(" ：为哈希表 key 中的域 field 的值加上增量 1   -1")]),e._v(" "),v("li",[v("code",[e._v("hsetnx <key> <field> <value>")]),e._v(" ：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在")])]),e._v(" "),v("h4",{attrs:{id:"数据结构-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-4"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),v("p",[e._v("Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。")]),e._v(" "),v("h3",{attrs:{id:"有序集合类型-sortedset"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有序集合类型-sortedset"}},[e._v("#")]),e._v(" 有序集合类型 sortedset")]),e._v(" "),v("p",[e._v("Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。")]),e._v(" "),v("p",[e._v("不同之处是有序集合的每个成员都关联了一个"),v("strong",[e._v("评分（score）")]),e._v("，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。"),v("strong",[e._v("集合的成员是唯一的，但评分可以重复。")])]),e._v(" "),v("p",[e._v("因为元素是有序的，所以可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。")]),e._v(" "),v("p",[e._v("访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。")]),e._v(" "),v("h4",{attrs:{id:"常用命令-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用命令-5"}},[e._v("#")]),e._v(" 常用命令")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("zadd <key> <score1> <value1> <score2> <value2>…")]),e._v(" ：将一个或多个元素及score值加入到有序集key中")]),e._v(" "),v("li",[v("code",[e._v("zrange <key> <start> <stop> [withscores]")]),e._v(" ：返回有序集key中下标在"),v("start",[v("stop",[e._v("之间的元素，带"),v("code",[e._v("withscores")]),e._v("，可以让分数一起和值返回到结果集")])],1)],1),e._v(" "),v("li",[v("code",[e._v("zrangebyscore key min max [withscores] [limit offset count]")]),e._v(" ：返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列")]),e._v(" "),v("li",[v("code",[e._v("zrevrangebyscore key max min [withscores] [limit offset count]")]),e._v("  ： 同上，改为从大到小排列。")]),e._v(" "),v("li",[v("code",[e._v("zincrby <key> <increment> <value>")]),e._v(" ：为元素的score加上增量")]),e._v(" "),v("li",[v("code",[e._v("zrem <key> <value>")]),e._v(" ：删除该集合下指定值的元素")]),e._v(" "),v("li",[v("code",[e._v("zcount <key> <min> <max>")]),e._v(" ：统计该集合，分数区间内的元素个数")]),e._v(" "),v("li",[v("code",[e._v("zrank <key> <value>")]),e._v(" ：返回该值在集合中的排名，从0开始")])]),e._v(" "),v("h4",{attrs:{id:"数据结构-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-5"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),v("p",[e._v("SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构"),v("code",[e._v("Map<String, Double>")]),e._v("，可以给每一个元素value赋予一个权重score，另一方面它又类似于"),v("code",[e._v("TreeSet")]),e._v("，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。")]),e._v(" "),v("p",[v("strong",[e._v("zset底层使用了两个数据结构：")])]),e._v(" "),v("ol",[v("li",[e._v("hash：hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。")]),e._v(" "),v("li",[e._v("跳跃表：跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。")])]),e._v(" "),v("h5",{attrs:{id:"跳跃表-跳表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#跳跃表-跳表"}},[e._v("#")]),e._v(" "),v("strong",[e._v("跳跃表（跳表）")])]),e._v(" "),v("p",[e._v("有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。")]),e._v(" "),v("p",[e._v("Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。")]),e._v(" "),v("p",[v("strong",[e._v("有序链表：")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/5C9yMT3f9_aMU0OC8rPpWiDEK_3Ymcdpi2YgYB6U2FE.png",alt:"image"}})]),e._v(" "),v("p",[e._v("要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到，共需要6次比较。")]),e._v(" "),v("p",[v("strong",[e._v("跳跃表：")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://file.qaomuu.com/blog/YpZsAmLH3sn6OJ48yMB9bdxDDjMEEgB9YnGyao2JpCQ.png",alt:"image"}})]),e._v(" "),v("ol",[v("li",[e._v("从第2层开始，1节点比51节点小，向后比较。")]),e._v(" "),v("li",[e._v("21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层。")]),e._v(" "),v("li",[e._v("在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下")]),e._v(" "),v("li",[e._v("在第0层，51节点为要查找的节点，节点被找到，共查找4次。")])]),e._v(" "),v("p",[e._v("从此可以看出跳跃表比有序链表效率要高。")])])}),[],!1,null,null,null);v.default=t.exports}}]);